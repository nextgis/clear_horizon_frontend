{"version":3,"file":"main-68903daebe3d950.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/updateQmsOptions.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/loadJson.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/getSubmodulesFromOriginUrl.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/QmsKit.ts","webpack://clear_horizon/./@nextgis/packages/tree/src/treeFilter.ts"],"sourcesContent":["import type { LayerAdaptersOptions, AdapterOptions } from '@nextgis/webmap';\n\nimport type { QmsBasemap, QmsLayerType } from '../interfaces';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE',\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap,\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  let serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  if (!qms.y_origin_top) {\n    serviceUrl = serviceUrl.replace('{y}', '{-y}');\n  }\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min,\n  };\n}\n","import { fixUrlStr } from '@nextgis/utils';\n\nexport function loadJson<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","export function getSubdomainsOriginUrl(originUrl: string): [string, string[]] {\n  const submodules: string[] = [];\n  originUrl = originUrl.replace(/{switch:(.*?)}/, (m, group) => {\n    if (typeof group === 'string') {\n      group.split(',').forEach((s) => submodules.push(s));\n    }\n    return '{s}';\n  });\n  return [originUrl, submodules];\n}\n","import { mixinProperties } from '@nextgis/utils';\nimport { alias, updateQmsOptions } from './updateQmsOptions';\nimport { loadJson } from './loadJson';\nimport { getSubdomainsOriginUrl } from './getSubmodulesFromOriginUrl';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport type {\n  QmsAdapterOptions,\n  QmsBasemap,\n  QmsAdapter as QA,\n} from '../interfaces';\n\nconst URL = 'https://qms.nextgis.com';\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = URL,\n  createOpt: Partial<QmsAdapterOptions> = {},\n): Type<MainLayerAdapter> {\n  if (!url) {\n    url = URL;\n  }\n  class QmsAdapter<M = any> implements MainLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      const opt = { ...createOpt, ...options };\n      this.options = opt;\n      this.options.baselayer = true;\n      if (opt.qms) {\n        this.qms = opt.qms;\n      }\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        try {\n          this.qms = await loadJson<QmsBasemap>(\n            url + '/api/v1/geoservices/' + options.qmsId,\n          );\n        } catch (er) {\n          console.error(er);\n        }\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const WebMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (WebMapAdapter) {\n          mixinProperties(QmsAdapter, WebMapAdapter, [\n            'showLayer',\n            'hideLayer',\n          ]);\n          if (type === 'TILE') {\n            options = {\n              order: 0,\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms),\n            };\n            if (qms.origin_url) {\n              const [url, subdomains] = getSubdomainsOriginUrl(qms.origin_url);\n              if (subdomains.length) {\n                options.subdomains = subdomains;\n                options.url = url;\n              }\n            }\n            this.options = options;\n            const adapter = new WebMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","import { createQmsAdapter } from './utils/createQmsAdapter';\n\nimport type {\n  WebMap,\n  StarterKit,\n  Type,\n  MainLayerAdapter,\n  LayerAdapterCreators,\n} from '@nextgis/webmap';\nimport type { QmsOptions } from './interfaces';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter,\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com',\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap)),\n      },\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<MainLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\n\nimport type { PropertyFilter } from '@nextgis/properties-filter';\nimport type {\n  DefaultTreeItem,\n  RelationFunction,\n  SelfFilter,\n  TreeRelation,\n} from './interfaces';\n\ntype D = DefaultTreeItem;\n\ntype TreeFunction<X extends D> = (\n  item: X | X[],\n  filter: SelfFilter<X>,\n  relation: TreeRelation<X>,\n) => X | X[] | boolean | undefined;\n\ntype ItemPrepareFunction<F extends D> = (item: D) => F;\n\nexport function treeEvery<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): boolean {\n  return !!treeWrapper<F>(item, filter, relation, treeEvery_, itemPrepare);\n}\n\nexport function treeSome<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): boolean {\n  return !!treeWrapper<F>(item, filter, relation, treeFind_, itemPrepare);\n}\n\nexport function treeFind<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): F | undefined {\n  return treeWrapper<F>(item, filter, relation, treeFind_, itemPrepare) as F;\n}\n\nexport function treeFilter<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): F[] {\n  return treeWrapper<F>(\n    item,\n    filter,\n    relation,\n    treeFilter_,\n    itemPrepare,\n  ) as F[];\n}\n\nexport function getChildren<F extends D = D>(\n  item: F,\n  relation: TreeRelation<F> = 'children',\n): F[] | undefined {\n  let children: F[] = [];\n  const relationFunction: RelationFunction<F> =\n    typeof relation === 'function' ? relation : (i): F[] => i[relation];\n  const relChild = relationFunction(item);\n  if (relChild) {\n    if (Array.isArray(relChild)) {\n      children = relChild;\n    } else {\n      children.push(relChild);\n    }\n  }\n  return relChild ? children : undefined;\n}\n\nfunction treeWrapper<F extends D = D>(\n  item: F | F[],\n  filter: PropertyFilter | SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F> = 'children',\n  treeFunction: TreeFunction<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): F[] | F | boolean | undefined {\n  const filterFunction: SelfFilter<F> =\n    typeof filter === 'function'\n      ? filter\n      : (i: F): boolean => propertiesFilter(i, filter);\n  if (itemPrepare) {\n    return treeFunction(\n      item,\n      (i: F): boolean => filterFunction(itemPrepare(i)),\n      relation,\n    );\n  }\n  return treeFunction(item, filterFunction, relation);\n}\n\nfunction treeFind_<F extends D = D>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F>,\n  _filtered: F[] = [],\n): F | undefined {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      return item;\n    }\n    const relChildren = getChildren(item, relation);\n    if (relChildren) {\n      children = relChildren;\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      const result = treeFind_(children[fry], filterFunc, relation, _filtered);\n      if (result) {\n        return result;\n      }\n    }\n  }\n}\n\nfunction treeFilter_<F extends D = D>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F>,\n  _filtered: F[] = [],\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChildren = getChildren(item, relation);\n    if (relChildren) {\n      children = relChildren;\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      treeFilter_(children[fry], filterFunc, relation, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n\nfunction treeEvery_<F extends D = D>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F>,\n  _filtered: F[] = [],\n): boolean {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (!filter) {\n      return false;\n    }\n    const relChildren = getChildren(item, relation);\n    if (relChildren) {\n      children = relChildren;\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      const res = treeEvery_(children[fry], filterFunc, relation, _filtered);\n      if (!res) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n"],"names":["alias","tms","updateQmsOptions","qms","protocol","location","serviceUrl","url","replace","y_origin_top","name","attribution","copyright_text","maxZoom","z_max","minZoom","z_min","loadJson","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","fixUrlStr","send","getSubdomainsOriginUrl","originUrl","submodules","m","group","split","forEach","s","push","URL","createQmsAdapter","webMap","createOpt","QmsAdapter","map","options","this","opt","baselayer","qmsId","console","error","type","WebMapAdapter","mapAdapter","layerAdapters","mixinProperties","order","origin_url","subdomains","length","adapter","addLayer","QmsKit","createAdapter","webmap","_createAdapter","treeEvery","item","filter","relation","itemPrepare","treeWrapper","treeEvery_","treeSome","treeFind_","treeFind","treeFilter","treeFilter_","getChildren","children","relationFunction","i","relChild","Array","isArray","undefined","x","treeFunction","filterFunction","propertiesFilter","filterFunc","_filtered","relChildren","fry","result","res"],"sourceRoot":""}