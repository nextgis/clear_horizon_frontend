{"version":3,"sources":["webpack://clear_horizon/./@nextgis/packages/properties-filter/src/propertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/updateQmsOptions.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/loadJson.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/getSubmodulesFromOriginUrl.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/QmsKit.ts"],"names":["like","b","a","iLike","String","toUpperCase","re","replace","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","indexOf","notin","ilike","checkIfPropertyFilter","filter","pf","length","featureFilter","feature","filters","properties","$id","id","propertiesFilter","logic","filterFunction","p","operation","operationExec","value_","match","cleanField","filters_","x","Array","isArray","some","every","alias","tms","loadJson","url","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","send","createQmsAdapter","webMap","map","options","this","baselayer","addLayer","qms","qmsId","console","error","type","webMapAdapter","mapAdapter","layerAdapters","QmsAdapter","order","maxZoom","minZoom","protocol","location","serviceUrl","y_origin_top","name","attribution","copyright_text","z_max","z_min","updateQmsOptions","origin_url","originUrl","submodules","m","group","split","forEach","s","push","subdomains","getLayerAdapters","createAdapter","webmap","_createAdapter","utils"],"mappings":"maA6CA,SAASA,EAAKC,EAAWC,EAAWC,GAGlC,IAFAD,EAAIE,OAAOF,OACXD,EAAIG,OAAOH,IACE,OAAO,EACpB,GAAIE,GAASD,EAAEG,gBAAkBJ,EAAEI,cAAe,OAAO,EACzD,IAAMC,GAAK,KAAI,QAASJ,GAAE,KAAIK,QAAQ,KAAM,MAAMA,QAAQ,IAAK,KAC/D,OAAoD,OAA7C,IAAIC,OAAOF,EAAIH,EAAQ,IAAM,IAAIM,KAAKR,GAGxC,IAAMS,EAET,CAEFC,GAAI,SAACT,EAAQD,GAAW,OAAAC,EAAID,GAE5BW,GAAI,SAACV,EAAQD,GAAW,OAAAC,EAAID,GAE5BY,GAAI,SAACX,EAAQD,GAAW,OAAAC,GAAKD,GAE7Ba,GAAI,SAACZ,EAAQD,GAAW,OAAAC,GAAKD,GAE7Bc,GAAI,SAACb,EAAQD,GAAW,OAAAC,IAAMD,GAE9Be,GAAI,SAACd,EAAQD,GAAW,OAAAC,IAAMD,GAE9BgB,GAAI,SAACf,EAAQD,GAAa,OAAkB,IAAlBA,EAAEiB,QAAQhB,IACpCiB,MAAO,SAACjB,EAAQD,GAAa,OAAkB,IAAlBA,EAAEiB,QAAQhB,IAEvCF,KAAM,SAACE,EAAWD,GAChB,OAAOD,EAAKE,EAAGD,IAGjBmB,MAAO,SAAClB,EAAWD,GACjB,OAAOD,EAAKE,EAAGD,GAAG,KAIf,SAASoB,EACdC,GAEA,IAAMC,EAAKD,EACX,OACgB,IAAdC,EAAGC,QACc,iBAAVD,EAAG,IACO,iBAAVA,EAAG,GAOP,SAASE,EACdC,EACAC,GAEA,IAAMC,EAAU,KAA2BF,EAAQE,YACnD,QAAIA,IAEFA,EAAWC,IAAMH,EAAQI,GAClBC,EAAiBH,EAAYD,IAKjC,SAASI,EACdH,EACAD,GAEA,IAAMK,EAA8B,iBAAfL,EAAQ,GAAkBA,EAAQ,GAAK,MACtDM,EAAiB,SAACC,GACtB,GAAIb,EAAsBa,GAAI,CACrB,MAA2BA,EAAC,GAArBC,EAAoBD,EAAC,GAAV,EAASA,EAAC,GAC7BE,EAAgB1B,EAAkByB,GACxC,GAAIC,EAAe,CACjB,IAAkB,SAAdD,GAAsC,UAAdA,IACL,iBAAV,EAAoB,CAC7B,IAAI,EAAO,GACLE,EAAS,EAAM9B,QAAQ,eAAe,SAAC+B,EAAOC,GAElD,OADA,EAAOX,EAAWW,GACX,EAAMhC,QAAQgC,EAAY,MAEnC,OAAOH,EAAc,EAAMC,GAG/B,OAAOD,EAAcR,EAAW,GAAQ,GAE1C,OAAO,EAEP,OAAOG,EAAiBH,EAAYM,IAGlCM,EAAWb,EAAQL,QAAO,SAACmB,GAAM,OAAAC,MAAMC,QAAQF,MAIrD,MAAiB,QAAVT,EACHQ,EAASI,KAAKX,GACdO,EAASK,MAAMZ,K,mFC1IRa,EAA+D,CAC1EC,IAAK,QCHA,SAASC,EAAkBC,GAChC,OAAO,IAAIC,SAAW,SAACC,EAASC,GAC9B,IAAMC,EAAU,IAAIC,eACpBD,EAAQE,mBAAqB,WAC3B,GAA2B,IAAvBF,EAAQG,YAAuC,MAAnBH,EAAQI,QAClCJ,EAAQK,aACV,IACEP,EAAQQ,KAAKC,MAAMP,EAAQK,eAC3B,MAAOG,GACPT,EAAOS,KAKfR,EAAQS,KAAK,OAAO,QAAUb,IAAM,GACpCI,EAAQU,U,mNCVL,SAASC,EACdC,EACAhB,GAyDA,YAzDA,IAAAA,MAAA,2BAEA,WAME,WAAYiB,EAAQC,GAClBC,KAAKF,IAAMA,EACXE,KAAKD,QAAUA,EACfC,KAAKD,QAAQE,WAAY,EA6C7B,OA1CQ,YAAAC,SAAN,SAAeH,G,gpCAERC,KAAKG,MAAOJ,EAAQK,MAArB,Y,iBAEW,O,sBAAX,EAAAJ,KAAW,GAAMpB,EACfC,EAAM,uBAAyBkB,EAAQK,Q,cADzC,EAAKD,IAAM,S,+BAIXE,QAAQC,MAAM,G,aAIlB,OADMH,EAAMH,KAAKG,OAETI,EAAO7B,EAAMyB,EAAII,MAAQ,QACzBC,EAAgBX,EAAOY,WAAWC,cAAcH,OAEpD,QAAgBI,EAAYH,EAAe,CACzC,YACA,cAEW,SAATD,KACFR,EAAU,EAAH,GACLa,MAAO,EACPC,QAAShB,EAAOE,QAAQc,QACxBC,QAASjB,EAAOE,QAAQe,SACrBd,KAAKD,SFxCf,SACLI,GAEA,IAAMY,GAAkC,WAAtBC,SAASD,SAAwB,QAAU,QAAU,MACnEE,EAAad,EAAItB,IAAI1C,QAAQ,qBAAsB4E,GAIvD,OAHKZ,EAAIe,eACPD,EAAaA,EAAW9E,QAAQ,MAAO,SAElC,CACL0C,IAAKoC,EACLE,KAAMhB,EAAIgB,KACVC,YAAajB,EAAIkB,eACjBR,QAASV,EAAImB,MACbR,QAASX,EAAIoB,OE4BAC,CAAiBrB,IAElBA,EAAIsB,aCnDmBC,EDoDwBvB,EAAIsB,WCnD3DE,EAAuB,GDmDX,EC5CX,CANPD,EAAYA,EAAUvF,QAAQ,kBAAkB,SAACyF,EAAGC,GAIlD,MAHqB,iBAAVA,GACTA,EAAMC,MAAM,KAAKC,SAAQ,SAACC,GAAM,OAAAL,EAAWM,KAAKD,MAE3C,SAEUL,GD4CA,QAAKO,EAAU,MACP9E,SACb2C,EAAQmC,WAAaA,EACrBnC,EAAQlB,IAAM,IAGlBmB,KAAKD,QAAUA,EAER,CAAP,EADgB,IAAIS,EAAcR,KAAKF,IAAKC,GAC7BG,SAASH,K,IC5D7B,IAAgC2B,EAC/BC,M,gSDgEN,EAtDA,G,mNEDF,aAWE,WAAY5B,GANZ,KAAAA,QAAsB,CACpBlB,IAAK,2BAMLmB,KAAKD,QAAU,OAAKC,KAAKD,SAAYA,GACrCC,KAAKnB,IAAMmB,KAAKD,QAAQlB,IAgB5B,OAbE,YAAAsD,iBAAA,sBACE,OAAOrD,QAAQC,QAAQ,CACrB,CACEoC,KAAM,MACNiB,cAAe,SAACC,GACd,OAAAvD,QAAQC,QAAQ,EAAKuD,eAAeD,SAKpC,YAAAC,eAAR,SAAuBzC,GACrB,OAAOD,EAAiBC,EAAQG,KAAKnB,MA1BhC,EAAA0D,MAAQ,CACb3C,iBAAgB,GA2BpB,EA7BA","file":"main-6a679f1af299dae.js","sourcesContent":["import { Feature, GeoJsonProperties } from 'geojson';\nimport { reEscape } from '@nextgis/utils';\n\n/**\n * gt - greater (\\>)\n * lt - lower (\\<)\n * ge - greater or equal (\\>=)\n * le - lower or equal (\\<=)\n * eq - equal (=)\n * ne - not equal (!=)\n * like - LIKE SQL statement (for strings compare)\n * ilike - ILIKE SQL statement (for strings compare)\n */\nexport type Operations =\n  | 'gt'\n  | 'lt'\n  | 'ge'\n  | 'le'\n  | 'eq'\n  | 'ne'\n  | 'in'\n  | 'notin'\n  | 'like'\n  | 'ilike';\n\ntype Properties = GeoJsonProperties;\n\n/**\n * field, operation, value\n * ['foo', 'eq', 'bar']\n * ['count', 'ge', 20]\n */\nexport type PropertyFilter<T extends Properties = Properties> = [\n  keyof T | string,\n  Operations,\n  any\n];\n\nexport type PropertiesFilter<T extends Properties = Properties> = (\n  | 'all'\n  | 'any'\n  | PropertyFilter<T>\n  | PropertiesFilter<T>\n)[];\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operations]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter\n): boolean {\n  const properties: GeoJsonProperties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter(\n  properties: { [field: string]: any },\n  filters: PropertiesFilter\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (checkIfPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n","import { LayerAdaptersOptions, AdapterOptions } from '@nextgis/webmap';\n\nimport { QmsBasemap, QmsLayerType } from '../interfaces';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE',\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  let serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  if (!qms.y_origin_top) {\n    serviceUrl = serviceUrl.replace('{y}', '{-y}');\n  }\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min,\n  };\n}\n","import { fixUrlStr } from '@nextgis/utils';\n\nexport function loadJson<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","import { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport { Type, mixinProperties } from '@nextgis/utils';\nimport { QmsAdapterOptions, QmsBasemap, QmsAdapter as QA } from '../interfaces';\nimport { alias, updateQmsOptions } from './updateQmsOptions';\nimport { loadJson } from './loadJson';\nimport { getSubdomainsOriginUrl } from './getSubmodulesFromOriginUrl';\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com'\n): Type<MainLayerAdapter> {\n  class QmsAdapter<M = any> implements MainLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baselayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        try {\n          this.qms = await loadJson<QmsBasemap>(\n            url + '/api/v1/geoservices/' + options.qmsId\n          );\n        } catch (er) {\n          console.error(er);\n        }\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          mixinProperties(QmsAdapter, webMapAdapter, [\n            'showLayer',\n            'hideLayer',\n          ]);\n          if (type === 'TILE') {\n            options = {\n              order: 0,\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms),\n            };\n            if (qms.origin_url) {\n              const [url, subdomains] = getSubdomainsOriginUrl(qms.origin_url);\n              if (subdomains.length) {\n                options.subdomains = subdomains;\n                options.url = url;\n              }\n            }\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","export function getSubdomainsOriginUrl(originUrl: string): [string, string[]] {\n  const submodules: string[] = [];\n  originUrl = originUrl.replace(/{switch:(.*?)}/, (m, group) => {\n    if (typeof group === 'string') {\n      group.split(',').forEach((s) => submodules.push(s));\n    }\n    return '{s}';\n  });\n  return [originUrl, submodules];\n}\n","import {\n  WebMap,\n  StarterKit,\n  Type,\n  MainLayerAdapter,\n  LayerAdapterCreators,\n} from '@nextgis/webmap';\nimport { QmsOptions } from './interfaces';\nimport { createQmsAdapter } from './utils/createQmsAdapter';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter,\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com',\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap)),\n      },\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<MainLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n"],"sourceRoot":""}