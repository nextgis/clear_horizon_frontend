{"version":3,"sources":["webpack://clear_horizon/./@nextgis/packages/cache/src/Cache.ts","webpack://clear_horizon/./@nextgis/packages/cache/src/index.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/CancelError.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/PromiseControl.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/TimeoutError.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/CancelablePromise.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/index.ts"],"names":["Cache","instance","this","cache","length","key","valueToSet","options","value","exist","_find","Function","options_","JSON","parse","stringify","objectRemoveEmpty","cacheItem","push","Promise","catch","er","delete","cacheRecord","filter","x","_filter","map","e","index","indexOf","splice","find","item","objectDeepEqual","CancelError","Object","setPrototypeOf","prototype","Error","PromiseControl","Map","_promises","size","promise","has","_onStop","get","name","onStart","isLoaded","set","finally","remove","forEach","cancel","clear","func","add","bind","target","descriptor","originalMethod","args","result","apply","WaitForMe","onStop","TimeoutError","handleCallback","resolve","reject","callback","r","ID","Symbol","toStringTag","CancelablePromise","executor","timeout","_cancelPromise","resolve_","reject_","_setCanceledCallback","promises","attach","_isPending","error","handler","_cancelHandlers","setTimeout","_promise","race","opt","values","all","then","v","p","_isCanceled","_children","onfulfilled","onrejected","_parentPromise","undefined","onfinally","parent","_getTopParent","_destroy","hasParent"],"mappings":"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","file":"main-e8f745b52446814.js","sourcesContent":["import { objectDeepEqual, objectRemoveEmpty } from '@nextgis/utils';\n\ntype CacheValue<T> = T;\ntype CacheOptions<T> = Record<keyof T, T[keyof T]>;\n\ninterface CacheItem<T extends any = any, O = any> {\n  key: string;\n  value: CacheValue<T>;\n  options?: CacheOptions<O>;\n}\n\nexport class Cache<\n  T extends any = any,\n  O extends Record<string, any> = Record<string, any>,\n> {\n  private static instance: Cache<any, any>;\n  private readonly cache: CacheItem<T, O>[] = [];\n\n  constructor() {\n    if (Cache.instance) {\n      return Cache.instance;\n    }\n\n    Cache.instance = this;\n\n    return this;\n  }\n\n  clean(): void {\n    this.cache.length = 0;\n  }\n\n  all(): CacheItem<T, O>[] {\n    return this.cache;\n  }\n\n  add(\n    key: string,\n    valueToSet: CacheValue<T> | (() => CacheValue<T>),\n    options?: CacheOptions<O>,\n  ): CacheValue<T> {\n    const exist = this._find(key, options);\n    if (!exist) {\n      let value: CacheValue<T>;\n      if (valueToSet instanceof Function) {\n        value = valueToSet();\n      } else {\n        value = valueToSet;\n      }\n      const options_ =\n        options && JSON.parse(JSON.stringify(objectRemoveEmpty(options)));\n\n      const cacheItem = {\n        key,\n        value,\n        options: options_,\n      } as CacheItem<T, O>;\n\n      this.cache.push(cacheItem);\n      if (value instanceof Promise) {\n        value.catch((er) => {\n          this.delete(key, options);\n          throw er;\n        });\n        return value;\n      }\n      return value;\n    } else {\n      return exist.value;\n    }\n  }\n\n  match(key: string, options?: CacheOptions<O>): CacheValue<T> | undefined {\n    const cacheRecord = this._find(key, options);\n\n    if (cacheRecord) {\n      return cacheRecord.value;\n    }\n  }\n\n  matchAll(key?: string, options?: CacheOptions<O>): CacheValue<T>[] {\n    if (key) {\n      return this.cache\n        .filter((x) => this._filter(x, key, options))\n        .map((x) => x.value);\n    }\n    return this.cache.map((x) => x.value);\n  }\n\n  delete(key: string, options?: CacheOptions<O>): void {\n    const exist = this.cache.filter((x) => this._filter(x, key, options));\n    for (const e of exist) {\n      const index = this.cache.indexOf(e);\n      this.cache.splice(index, 1);\n    }\n  }\n\n  private _find(\n    key: string,\n    options?: CacheOptions<O>,\n  ): CacheItem<T> | undefined {\n    return this.cache.find((x) => this._filter(x, key, options));\n  }\n\n  private _filter(\n    item: CacheItem,\n    key: string,\n    options?: CacheOptions<O>,\n  ): boolean {\n    if (item.key === key) {\n      if (options) {\n        return objectDeepEqual(item.options || {}, objectRemoveEmpty(options));\n      }\n      return true;\n    }\n    return false;\n  }\n}\n","/**\n * Caching for asynchronous functions\n *\n * @packageDocumentation\n * @module cache\n */\nimport { Cache } from './Cache';\n\nexport default Cache;\n","export class CancelError extends Error {\n  name = 'CancelError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, CancelError.prototype);\n  }\n}\n","import CancelablePromise from '.';\n\nexport interface PromiseControlOptions {\n  onStart?: () => void;\n  onStop?: () => void;\n}\n\ntype Key = CancelablePromise | string | number | symbol;\n\nexport class PromiseControl {\n  private _promises: Map<Key, CancelablePromise> = new Map();\n\n  get isLoaded(): boolean {\n    return this._promises.size > 0;\n  }\n\n  constructor(private options: PromiseControlOptions = {}) {}\n\n  remove(promise: Key): void {\n    if (this._promises.has(promise)) {\n      this._promises.delete(promise);\n      this._onStop();\n    }\n  }\n\n  get(promise: Key): CancelablePromise | undefined {\n    return this._promises.get(promise);\n  }\n\n  add<T extends CancelablePromise = CancelablePromise>(\n    promise: T,\n    name?: string | number | symbol,\n  ): CancelablePromise<T> {\n    const key = name ? name : promise;\n    const exist = this._promises.get(key);\n    if (this.options.onStart && !this.isLoaded) {\n      this.options.onStart();\n    }\n    if (exist) {\n      return exist;\n    }\n    this._promises.set(key, promise);\n    promise.finally(() => {\n      this.remove(key);\n    });\n    return promise;\n  }\n\n  abort(): void {\n    if (this.isLoaded) {\n      this._promises.forEach((x) => {\n        if (x.cancel) {\n          x.cancel();\n        }\n      });\n      this._promises.clear();\n      this._onStop();\n    }\n  }\n\n  waitFunc<T>(func: () => any, name = ''): CancelablePromise<T> {\n    name = name || func.name;\n    const exist = this.get(name);\n    if (exist) {\n      return exist;\n    }\n    return this.add(func(), name);\n  }\n\n  WaitForMe(name: string | symbol = ''): MethodDecorator {\n    const get = this.get.bind(this);\n    const add = this.add.bind(this);\n    return function (\n      target: unknown,\n      key: string | symbol,\n      descriptor: PropertyDescriptor,\n    ): PropertyDescriptor {\n      const originalMethod = descriptor.value;\n      name = name || key;\n      descriptor.value = function (...args: any[]) {\n        const exist = get(name);\n        if (exist) {\n          return exist;\n        }\n        const result = add(originalMethod.apply(this, args), name);\n        return result;\n      };\n\n      return descriptor;\n    };\n  }\n\n  /** @deprecated use {@link PromiseControl.WaitForMe } instead */\n  GetOrCreateDecorator(name: string | symbol = ''): MethodDecorator {\n    return this.WaitForMe(name);\n  }\n\n  private _onStop(): void {\n    if (this.options.onStop && !this.isLoaded) {\n      this.options.onStop();\n    }\n  }\n}\n","export class TimeoutError extends Error {\n  name = 'TimeoutError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n","import { CancelError } from './CancelError';\nimport { PromiseControl, PromiseControlOptions } from './PromiseControl';\nimport { TimeoutError } from './TimeoutError';\n\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\nexport type OnCancelFunction = (cancelHandler: () => void) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T,\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nlet ID = 0;\n\n/**\n * Promise that can be canceled\n *\n * @example\n * Catch `CancelError`\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject) => {\n *  setTimeout(() => resolve(), 100);\n * }).catch((er) => {\n *  if (er.name === \"CancelError\") {\n *    // handle cancel error\n *  }\n *  throw er;\n * });\n *\n * promise.cancel();\n * ```\n * @example\n * Handle `onCancel` callback\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject, onCancel) => {\n *   const xhr = new XMLHttpRequest();\n *   xhr.open(\"GET\", url, true);\n *   xhr.onload = () => {\n *     resolve(xhr.responseText);\n *   };\n *   xhr.onerror = (er) => {\n *     reject(er);\n *   };\n *\n *   onCancel(() => {\n *     xhr.abort();\n *   });\n *\n *   xhr.send();\n * });\n *\n * promise.cancel();\n * ```\n * @public\n */\nexport class CancelablePromise<T = any> implements Promise<T> {\n  static CancelError = CancelError;\n  static TimeoutError = TimeoutError;\n  static PromiseControl = PromiseControl;\n\n  readonly [Symbol.toStringTag]: string;\n  readonly id = ID++;\n  private _isCanceled = false;\n  private _isPending = true;\n  private _promise?: Promise<T>;\n  private _cancelPromise?: Promise<T>;\n  private _cancelHandlers: (() => void)[] = [];\n  private _setCanceledCallback?: (er?: any) => void;\n  private _parentPromise?: CancelablePromise;\n  private _children: CancelablePromise[] = [];\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancelFunction,\n    ) => void,\n    timeout?: number,\n  ) {\n    this._cancelPromise = new Promise<any>((resolve_, reject_) => {\n      this._setCanceledCallback = (er) => resolve_(er || new CancelError());\n    });\n    const promises = [\n      this._cancelPromise,\n      new Promise<T>((resolve, reject) => {\n        const onResolve = (value?: T | PromiseLike<T>) => {\n          if (value instanceof CancelablePromise) {\n            this.attach(value);\n          } else {\n            this._isPending = false;\n          }\n          // TODO: fix types, `undefined` not allowed since 19.12.2020\n          resolve(value as T | PromiseLike<T>);\n        };\n\n        const onReject = (error: any) => {\n          this._isPending = false;\n          reject(error);\n        };\n\n        const onCancel: OnCancelFunction = (handler) => {\n          if (!this._isPending) {\n            throw new Error(\n              'The `onCancel` handler was attached after the promise settled.',\n            );\n          }\n\n          this._cancelHandlers.push(handler);\n        };\n\n        return executor(onResolve, onReject, onCancel);\n      }),\n    ];\n    if (timeout) {\n      promises.push(\n        new Promise((resolve, reject) => {\n          setTimeout(() => {\n            if (this._isPending) {\n              try {\n                this.cancel();\n              } finally {\n                reject(new TimeoutError());\n              }\n            }\n          }, timeout);\n        }),\n      );\n    }\n    this._promise = Promise.race(promises);\n  }\n\n  static createControl(opt?: PromiseControlOptions): PromiseControl {\n    return new PromiseControl(opt);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve) => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values).then(resolve).catch(reject);\n    }).catch((er) => {\n      if (er instanceof this.CancelError) {\n        for (const v of values) {\n          if ('cancel' in v) {\n            (v as CancelablePromise).cancel();\n          }\n        }\n      }\n      throw er;\n    });\n  }\n\n  attach(p: CancelablePromise): void {\n    if (this._isCanceled) {\n      p.cancel();\n    } else {\n      this._children.push(p);\n    }\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise((resolve, reject) => {\n      if (this._promise) {\n        const reject_ = (r: any) => {\n          if (onrejected) {\n            handleCallback(resolve, reject, onrejected, r);\n          } else {\n            reject(r);\n          }\n        };\n        this._promise.then((r) => {\n          if (this._isCanceled) {\n            reject_(r);\n          } else {\n            if (onfulfilled) {\n              handleCallback(resolve, reject, onfulfilled, r);\n            } else {\n              resolve(r);\n            }\n          }\n        }, reject_);\n      }\n    });\n    p._parentPromise = this;\n    this._children.push(p);\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: Error) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null,\n  ): CancelablePromise<T | TResult> {\n    if (this._isCanceled && onrejected) {\n      onrejected(new CancelError());\n    }\n    return this.then(undefined, onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    if (this._isCanceled) {\n      return Promise.reject(new CancelError());\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  cancel(): this {\n    // No reason to run cancel action if promise is already complete\n    if (this._isCanceled || !this._isPending) {\n      return this;\n    }\n    this._isCanceled = true;\n    const parent = this._getTopParent();\n    if (parent) {\n      parent.cancel();\n    }\n\n    if (this._children) {\n      this._children.forEach((x) => x.cancel());\n    }\n\n    if (this._isPending) {\n      if (this._cancelHandlers.length) {\n        try {\n          for (const handler of this._cancelHandlers) {\n            handler();\n          }\n        } catch (error) {\n          // this._setCanceledCallback(error);\n        }\n      }\n      if (this._setCanceledCallback) {\n        this._setCanceledCallback();\n      }\n    }\n    this._destroy();\n\n    return this;\n  }\n\n  private _getTopParent() {\n    let parent = this._parentPromise;\n    let hasParent = !!parent;\n    while (hasParent) {\n      if (parent && parent._parentPromise) {\n        parent = parent._parentPromise;\n        hasParent = !!parent;\n      } else {\n        hasParent = false;\n      }\n    }\n    return parent;\n  }\n\n  private _destroy() {\n    this._setCanceledCallback = undefined;\n    this._cancelPromise = undefined;\n    this._promise = undefined;\n  }\n}\n\nObject.setPrototypeOf(CancelablePromise.prototype, Promise.prototype);\n","/**\n * A promise you can stop\n *\n * @packageDocumentation\n * @module cancelable-promise\n */\nimport { CancelablePromise } from './CancelablePromise';\n\nexport default CancelablePromise;\n"],"sourceRoot":""}