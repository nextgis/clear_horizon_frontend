{"version":3,"file":"main-7f623ce74a578ff.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/cache/src/Cache.ts","webpack://clear_horizon/./@nextgis/packages/cache/src/index.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/CancelError.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/PromiseControl.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/TimeoutError.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/CancelablePromise.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/index.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/utils/evaluateArgs.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/decisionExpressions.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/constants/colors.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/utils/color.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/interpolationExpressions/interpolate.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/interpolationExpressions/index.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/interpolationExpressions/step.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/lookupExpressions.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/mathExpressions.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/stringExpressions.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/utils/tryConvert.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/utils/fallback.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expression.ts","webpack://clear_horizon/./@nextgis/packages/expression/src/expressions/typeExpressions.ts"],"sourcesContent":["import { full, objectDeepEqual, objectRemoveEmpty } from '@nextgis/utils';\n\ntype CacheValue<T> = T;\ntype CacheMatchProps<T> = Record<keyof T, T[keyof T]>;\n\ninterface CacheItem<T = any, O = any> {\n  key: string;\n  value: CacheValue<T>;\n  props?: CacheMatchProps<O>;\n  /** @deprecated use {@link CacheItem.props} instead */\n  options?: CacheMatchProps<O>;\n}\n\nexport interface CacheOptions {\n  /**\n   * Cache Scope Separator\n   * @defaultValue 'default'\n   */\n  namespace?: string;\n}\n\n/**\n * @example\n * ```javascript\n * const cache1 = new Cache();\n * cache1.add('foo', 'value');\n *\n * const cache2 = new Cache();\n * cache2.match('foo'); // value\n *\n * const cache3 = new Cache({ namespace: 'foo' });\n * cache3.match('foo'); // undefined\n * ```\n *\n * @example\n * ```javascript\n * let COUNTER = 0;\n * const createPromise = () => new Promise((res) => {\n *   COUNTER++\n *   setTimeout(() => res('Ok'), 300)\n * });\n *\n * const cache = new Cache();\n * for (let i = 0; i < 10; i++) {\n *   cache.add('foo', createPromise).then((data) => {\n *     console.log(data); // 'Ok'\n *   });\n * }\n * console.log(COUNTER); // 1\n * ```\n */\nexport class Cache<\n  V = any,\n  O extends Record<string, unknown> = Record<string, unknown>,\n> {\n  private static instance: Record<\n    string,\n    Cache<unknown, Record<string, unknown>>\n  > = {};\n  private readonly cache: CacheItem<V, O>[] = [];\n\n  constructor(options: CacheOptions = {}) {\n    const namespace = options.namespace ?? 'default';\n    if (Cache.instance[namespace]) {\n      return Cache.instance[namespace] as Cache<V, O>;\n    }\n    Cache.instance[namespace] = this;\n    return this;\n  }\n\n  clean(): void {\n    this.cache.length = 0;\n  }\n\n  all(): CacheItem<V, O>[] {\n    return this.cache;\n  }\n\n  /**\n   * Caching only a non-empty value.\n   *\n   * Useful for get or create strategy\n   * @example\n   * ```javascript\n   * const cache = new Cache();\n   * const getItemFunc = () => fetch(url).then((data) => {\n   *  return data.json(); // undefined\n   * });\n   * const item = await cache.addFull('foo', getItemFunc);\n   * if (!item) {\n   *   await createItem(); // 'New item'\n   * }\n   *\n   * // somewhere else in the code\n   * const item = await cache.addFull('foo', getItemFunc).then((resp) => {\n   *   console.log(resp); // 'New item'\n   * })\n   *\n   * ```\n   */\n  addFull(\n    key: string,\n    valueToSet: CacheValue<V> | (() => CacheValue<V>),\n    props?: CacheMatchProps<O>,\n  ): CacheValue<V> {\n    return this.add(key, valueToSet, props, true);\n  }\n\n  add(\n    key: string,\n    valueToSet: CacheValue<V> | (() => CacheValue<V>),\n    props?: CacheMatchProps<O>,\n    onlyFull?: boolean,\n  ): CacheValue<V> {\n    const exist = this._find(key, props);\n    if (!exist) {\n      let value: CacheValue<V>;\n      if (valueToSet instanceof Function) {\n        value = valueToSet();\n      } else {\n        value = valueToSet;\n      }\n      const props_ =\n        props && JSON.parse(JSON.stringify(objectRemoveEmpty(props)));\n\n      const cacheItem: CacheItem<V, O> = {\n        key,\n        value,\n        props: props_,\n        // TODO: remove backward compatibility use only props\n        options: props_,\n      };\n      if (onlyFull && !full(value)) {\n        return value;\n      }\n      this.cache.push(cacheItem);\n      if (value instanceof Promise) {\n        value.catch((er) => {\n          this.delete(key, props);\n          throw er;\n        });\n        if (onlyFull) {\n          value.then((x) => {\n            if (!full(x)) {\n              this.delete(key, props);\n            }\n            return x;\n          });\n        }\n        return value;\n      }\n      return value;\n    } else {\n      return exist.value;\n    }\n  }\n\n  match(key: string, props?: CacheMatchProps<O>): CacheValue<V> | undefined {\n    const cacheRecord = this._find(key, props);\n\n    if (cacheRecord) {\n      return cacheRecord.value;\n    }\n  }\n\n  matchAll(key?: string, props?: CacheMatchProps<O>): CacheValue<V>[] {\n    if (key) {\n      return this.cache\n        .filter((x) => this._filter(x, key, props))\n        .map((x) => x.value);\n    }\n    return this.cache.map((x) => x.value);\n  }\n\n  delete(item: CacheItem): void;\n  delete(key: string, props?: CacheMatchProps<O>): void;\n  delete(keyOrItem: string | CacheItem, props?: CacheMatchProps<O>): void {\n    let exist: CacheItem[] = [];\n    if (typeof keyOrItem === 'string') {\n      exist = this.cache.filter((x) => this._filter(x, keyOrItem, props));\n    } else {\n      exist.push(keyOrItem);\n    }\n    for (const e of exist) {\n      const index = this.cache.indexOf(e);\n      this.cache.splice(index, 1);\n    }\n  }\n\n  private _find(\n    key: string,\n    props?: CacheMatchProps<O>,\n  ): CacheItem<V> | undefined {\n    return this.cache.find((x) => this._filter(x, key, props));\n  }\n\n  private _filter(\n    item: CacheItem,\n    key: string,\n    props?: CacheMatchProps<O>,\n  ): boolean {\n    if (item.key === key) {\n      if (props) {\n        // TODO: remove backward compatibility\n        const itemProps = item.props || item.options;\n        return objectDeepEqual(itemProps || {}, objectRemoveEmpty(props));\n      }\n      return true;\n    }\n    return false;\n  }\n}\n","/**\n * Caching for asynchronous functions\n *\n * @packageDocumentation\n * @module cache\n */\nimport { Cache } from './Cache';\n\nexport default Cache;\n","export class CancelError extends Error {\n  name = 'CancelError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, CancelError.prototype);\n  }\n}\n","import type CancelablePromise from '.';\n\nexport interface PromiseControlOptions {\n  onStart?: () => void;\n  onStop?: () => void;\n}\n\ntype Key = CancelablePromise | string | number | symbol;\n\nexport class PromiseControl {\n  private _promises: Map<Key, CancelablePromise> = new Map();\n\n  constructor(private options: PromiseControlOptions = {}) {}\n\n  get isLoaded(): boolean {\n    return this._promises.size > 0;\n  }\n\n  remove(promise: Key): void {\n    if (this._promises.has(promise)) {\n      this._promises.delete(promise);\n      this._onStop();\n    }\n  }\n\n  get(promise: Key): CancelablePromise | undefined {\n    return this._promises.get(promise);\n  }\n\n  add<T extends CancelablePromise = CancelablePromise>(\n    promise: T,\n    name?: string | number | symbol,\n  ): CancelablePromise<T> {\n    const key = name ? name : promise;\n    const exist = this._promises.get(key);\n    if (this.options.onStart && !this.isLoaded) {\n      this.options.onStart();\n    }\n    if (exist) {\n      return exist;\n    }\n    this._promises.set(key, promise);\n    promise.finally(() => {\n      this.remove(key);\n    });\n    return promise;\n  }\n\n  abort(): void {\n    if (this.isLoaded) {\n      this._promises.forEach((x) => {\n        if (x.cancel) {\n          x.cancel();\n        }\n      });\n      this._promises.clear();\n      this._onStop();\n    }\n  }\n\n  waitFunc<T>(func: () => any, name = ''): CancelablePromise<T> {\n    name = name || func.name;\n    const exist = this.get(name);\n    if (exist) {\n      return exist;\n    }\n    return this.add(func(), name);\n  }\n\n  WaitForMe(name: string | symbol = ''): MethodDecorator {\n    const get = this.get.bind(this);\n    const add = this.add.bind(this);\n    return function (\n      target: unknown,\n      key: string | symbol,\n      descriptor: PropertyDescriptor,\n    ): PropertyDescriptor {\n      const originalMethod = descriptor.value;\n      name = name || key;\n      descriptor.value = function (...args: any[]) {\n        const exist = get(name);\n        if (exist) {\n          return exist;\n        }\n        const result = add(originalMethod.apply(this, args), name);\n        return result;\n      };\n\n      return descriptor;\n    };\n  }\n\n  /** @deprecated use {@link PromiseControl.WaitForMe } instead */\n  GetOrCreateDecorator(name: string | symbol = ''): MethodDecorator {\n    return this.WaitForMe(name);\n  }\n\n  private _onStop(): void {\n    if (this.options.onStop && !this.isLoaded) {\n      this.options.onStop();\n    }\n  }\n}\n","export class TimeoutError extends Error {\n  name = 'TimeoutError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n","import { CancelError } from './CancelError';\nimport { PromiseControl } from './PromiseControl';\nimport { TimeoutError } from './TimeoutError';\n\nimport type { PromiseControlOptions } from './PromiseControl';\n\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\nexport type OnCancelFunction = (cancelHandler: () => void) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T,\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nlet ID = 0;\n\n/**\n * Promise that can be canceled\n *\n * @example\n * Catch `CancelError`\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject) => {\n *  setTimeout(() => resolve(), 100);\n * }).catch((er) => {\n *  if (er.name === \"CancelError\") {\n *    // handle cancel error\n *  }\n *  throw er;\n * });\n *\n * promise.cancel();\n * ```\n * @example\n * Handle `onCancel` callback\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject, onCancel) => {\n *   const xhr = new XMLHttpRequest();\n *   xhr.open(\"GET\", url, true);\n *   xhr.onload = () => {\n *     resolve(xhr.responseText);\n *   };\n *   xhr.onerror = (er) => {\n *     reject(er);\n *   };\n *\n *   onCancel(() => {\n *     xhr.abort();\n *   });\n *\n *   xhr.send();\n * });\n *\n * promise.cancel();\n * ```\n */\nexport class CancelablePromise<T = any> implements Promise<T> {\n  static CancelError = CancelError;\n  static TimeoutError = TimeoutError;\n  static PromiseControl = PromiseControl;\n\n  // @ts-ignore\n  readonly [Symbol.toStringTag]: string;\n  readonly id = ID++;\n  private _isCanceled = false;\n  private _isPending = true;\n  private _promise?: Promise<T>;\n  private _cancelPromise?: Promise<T>;\n  private _cancelHandlers: (() => void)[] = [];\n  private _setCanceledCallback?: (er?: any) => void;\n  private _parentPromise?: CancelablePromise;\n  private _children: CancelablePromise[] = [];\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancelFunction,\n    ) => void,\n    timeout?: number,\n  ) {\n    this._cancelPromise = new Promise<any>((resolve_, reject_) => {\n      this._setCanceledCallback = (er) => resolve_(er || new CancelError());\n    });\n    const promises = [\n      this._cancelPromise,\n      new Promise<T>((resolve, reject) => {\n        const onResolve = (value?: T | PromiseLike<T>) => {\n          if (value instanceof CancelablePromise) {\n            this.attach(value);\n          } else {\n            this._isPending = false;\n          }\n          // TODO: fix types, `undefined` not allowed since 19.12.2020\n          resolve(value as T | PromiseLike<T>);\n        };\n\n        const onReject = (error: any) => {\n          this._isPending = false;\n          reject(error);\n        };\n\n        const onCancel: OnCancelFunction = (handler) => {\n          if (!this._isPending) {\n            throw new Error(\n              'The `onCancel` handler was attached after the promise settled.',\n            );\n          }\n\n          this._cancelHandlers.push(handler);\n        };\n\n        return executor(onResolve, onReject, onCancel);\n      }),\n    ];\n    if (timeout) {\n      promises.push(\n        new Promise((resolve, reject) => {\n          setTimeout(() => {\n            if (this._isPending) {\n              try {\n                this.cancel();\n              } finally {\n                reject(new TimeoutError());\n              }\n            }\n          }, timeout);\n        }),\n      );\n    }\n    this._promise = Promise.race(promises);\n  }\n\n  static createControl(opt?: PromiseControlOptions): PromiseControl {\n    return new PromiseControl(opt);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve) => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values).then(resolve).catch(reject);\n    }).catch((er) => {\n      if (er instanceof this.CancelError) {\n        for (const v of values) {\n          const v_ = v as CancelablePromise;\n          if ('cancel' in v_) {\n            v_.cancel();\n          }\n        }\n      }\n      throw er;\n    });\n  }\n\n  attach(p: CancelablePromise): void {\n    if (this._isCanceled) {\n      p.cancel();\n    } else {\n      this._children.push(p);\n    }\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise((resolve, reject) => {\n      if (this._promise) {\n        const reject_ = (r: any) => {\n          if (onrejected) {\n            handleCallback(resolve, reject, onrejected, r);\n          } else {\n            reject(r);\n          }\n        };\n        this._promise.then((r) => {\n          if (this._isCanceled) {\n            reject_(r);\n          } else {\n            if (onfulfilled) {\n              handleCallback(resolve, reject, onfulfilled, r);\n            } else {\n              resolve(r);\n            }\n          }\n        }, reject_);\n      }\n    });\n    p._parentPromise = this;\n    this._children.push(p);\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: Error) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null,\n  ): CancelablePromise<T | TResult> {\n    if (this._isCanceled && onrejected) {\n      onrejected(new CancelError());\n    }\n    return this.then(undefined, onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    if (this._isCanceled) {\n      return Promise.reject(new CancelError());\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  cancel(): this {\n    // No reason to run cancel action if promise is already complete\n    if (this._isCanceled || !this._isPending) {\n      return this;\n    }\n    this._isCanceled = true;\n    const parent = this._getTopParent();\n    if (parent) {\n      parent.cancel();\n    }\n\n    if (this._children) {\n      this._children.forEach((x) => x.cancel());\n    }\n\n    if (this._isPending) {\n      if (this._cancelHandlers.length) {\n        try {\n          for (const handler of this._cancelHandlers) {\n            handler();\n          }\n        } catch (error) {\n          // this._setCanceledCallback(error);\n        }\n      }\n      if (this._setCanceledCallback) {\n        this._setCanceledCallback();\n      }\n    }\n    this._destroy();\n\n    return this;\n  }\n\n  private _getTopParent() {\n    let parent = this._parentPromise;\n    let hasParent = !!parent;\n    while (hasParent) {\n      if (parent && parent._parentPromise) {\n        parent = parent._parentPromise;\n        hasParent = !!parent;\n      } else {\n        hasParent = false;\n      }\n    }\n    return parent;\n  }\n\n  private _destroy() {\n    this._setCanceledCallback = undefined;\n    this._cancelPromise = undefined;\n    this._promise = undefined;\n  }\n}\n\nObject.setPrototypeOf(CancelablePromise.prototype, Promise.prototype);\n","/**\n * A promise you can stop\n *\n * @packageDocumentation\n * @module cancelable-promise\n */\nimport { CancelError } from './CancelError';\nimport { CancelablePromise } from './CancelablePromise';\n\nexport { CancelError };\n\nexport default CancelablePromise;\n","import type {\n  ExpressionCbFunc,\n  ExpressionFunc,\n  MapToCallback,\n  SimpleType,\n} from '../interfaces';\n\nexport default function evaluateArgs<\n  T extends SimpleType[] = SimpleType[],\n  R = T[0],\n>(cb: ExpressionFunc<T, R>): ExpressionCbFunc<T, R> {\n  return (args: MapToCallback<T>, data) => {\n    const unwrap = args.map((a) => a()) as T;\n    return cb(unwrap, data);\n  };\n}\n","import e from '../utils/evaluateArgs';\n\nimport type { DecisionExpressionName, ExpressionCbFunc } from '../interfaces';\n\nfunction not([expr]: [boolean]): boolean {\n  return !expr;\n}\n\nfunction notEqual([a, b]: [value1: any, value2: any]): boolean {\n  return a !== b;\n}\n\nfunction lessThan([left, right]: [value1: any, value2: any]): boolean {\n  return left < right;\n}\n\nfunction lessThanOrEqual([left, right]: [value1: any, value2: any]): boolean {\n  return left <= right;\n}\n\nfunction equal([left, right]: [value1: any, value2: any]): boolean {\n  return left === right;\n}\n\nfunction greaterThan([left, right]: [value1: any, value2: any]): boolean {\n  return left > right;\n}\n\nfunction greaterThanOrEqual([left, right]: [\n  value1: any,\n  value2: any,\n]): boolean {\n  return left >= right;\n}\n\nconst coalesce: ExpressionCbFunc<any[], any> = (args) => {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]();\n    if (arg !== null && arg !== undefined) {\n      return arg;\n    }\n  }\n  return null;\n};\n\nconst all: ExpressionCbFunc<any[], boolean> = (args) => {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]();\n    if (!arg) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst any: ExpressionCbFunc<any[], boolean> = (args) => {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]();\n    if (arg) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst match: ExpressionCbFunc<any[]> = (args) => {\n  const [lookupFn, ...cases] = args;\n  const lookup = lookupFn();\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry]();\n    if (key === lookup) {\n      return cases[fry + 1]();\n    }\n  }\n  return defValue();\n};\n\ntype OutputType = any;\nconst caseFunc: ExpressionCbFunc<\n  [boolean, OutputType, ...Array<boolean | OutputType>],\n  OutputType\n> = (args) => {\n  if (args.length < 2) {\n    throw new Error(\n      'The \"case\" function requires at least a condition and a corresponding output.',\n    );\n  }\n\n  if (args.length % 2 === 0) {\n    throw new Error(\n      'Missing a fallback value or unmatched condition-output pair.',\n    );\n  }\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = args[i]() as boolean;\n    const value = args[i + 1]() as OutputType;\n    if (condition) {\n      return value;\n    }\n  }\n  const fallback = args[args.length - 1];\n  return fallback();\n};\n\nexport const decisionExpressions: Record<\n  DecisionExpressionName,\n  ExpressionCbFunc\n> = {\n  '!': e(not),\n  '!=': e(notEqual),\n  '<': e(lessThan),\n  '<=': e(lessThanOrEqual),\n  '==': e(equal),\n  '>': e(greaterThan),\n  '>=': e(greaterThanOrEqual),\n  coalesce,\n  all,\n  any,\n  case: caseFunc,\n  match,\n};\n","export const COLORS = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#00ffff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000000',\n  blanchedalmond: '#ffebcd',\n  blue: '#0000ff',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgreen: '#006400',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#ff00ff',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  'indianred ': '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgrey: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#00ff00',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370d8',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#d87093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#ff0000',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#ffffff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ffff00',\n  yellowgreen: '#9acd32',\n};\n","import { COLORS } from '../constants/colors';\n\nexport type ColorArray = [r: number, g: number, b: number, a?: number];\n\nexport type ColorObject = {\n  r: number;\n  g: number;\n  b: number;\n  a?: number;\n};\nexport type Color = string | ColorObject;\n\nfunction isHex(hex: any): hex is string {\n  return typeof hex === 'string' && /^#([A-Fa-f0-9]{3}){1,2}$/.test(hex);\n}\n\nfunction isRgb(hex: any): hex is string {\n  const r =\n    // eslint-disable-next-line max-len\n    /^rgb(a?)\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)(?:\\s*,\\s*([01](?:\\.\\d+)?))?\\s*\\)$/;\n  return typeof hex === 'string' && r.test(hex);\n}\n\nfunction isColorObj(obj: any): obj is ColorObject {\n  if (typeof obj === 'object' && obj !== null) {\n    const hasRgb = 'r' in obj && 'g' in obj && 'b' in obj;\n    const hasValidAlpha =\n      !('a' in obj) || (typeof obj.a === 'number' && obj.a >= 0 && obj.a <= 1);\n    return hasRgb && hasValidAlpha;\n  }\n  return false;\n}\n\nfunction isColorName(name: any): name is keyof typeof COLORS {\n  if (typeof name === 'string' && name in COLORS) {\n    return true;\n  }\n  return false;\n}\n\nexport function isColor(value: any): value is Color {\n  return [isColorName, isHex, isRgb, isColorObj].some((c) => c(value));\n}\n\nexport function toColor(value: Color): ColorArray {\n  if (isHex(value)) {\n    return hexToColor(value);\n  } else if (isColorName(value)) {\n    return colorNameToColor(value);\n  } else if (isRgb(value)) {\n    return rgbToColor(value);\n  } else if (isColorObj(value)) {\n    return colorObjectToColor(value);\n  }\n  throw new Error(`The '${value}' cannot be converted to color`);\n}\n\nfunction colorNameToColor(name: keyof typeof COLORS) {\n  return hexToColor(COLORS[name]);\n}\n\nfunction hexToColor(hex: string): ColorArray {\n  const shortRGB = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;\n  const shortRGBA = /^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/;\n  const longRGB = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;\n  const longRGBA =\n    /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;\n\n  let result;\n\n  if ((result = shortRGB.exec(hex))) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n    ];\n  } else if ((result = shortRGBA.exec(hex))) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      parseInt(result[4] + result[4], 16) / 255,\n    ];\n  } else if ((result = longRGB.exec(hex))) {\n    return [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16),\n    ];\n  } else if ((result = longRGBA.exec(hex))) {\n    return [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16),\n      parseInt(result[4], 16) / 255,\n    ];\n  }\n  throw new Error(`The '${hex}' Is not valid hex`);\n}\n\nfunction rgbToColor(rgb: string): ColorArray {\n  const rgbPattern = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/;\n  const rgbaPattern = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)$/;\n\n  let matches;\n\n  if ((matches = rgb.match(rgbPattern))) {\n    return [\n      parseInt(matches[1], 10),\n      parseInt(matches[2], 10),\n      parseInt(matches[3], 10),\n    ];\n  } else if ((matches = rgb.match(rgbaPattern))) {\n    return [\n      parseInt(matches[1], 10),\n      parseInt(matches[2], 10),\n      parseInt(matches[3], 10),\n      parseFloat(matches[4]),\n    ];\n  }\n\n  throw new Error(`The '${rgb}' Is not valid rgb`);\n}\n\nexport function colorObjectToColor({ r, g, b, a }: ColorObject): ColorArray {\n  return [r, g, b, ...(a !== undefined ? [a] : [])] as ColorArray;\n}\n\nexport function colorToRGB(array: ColorArray): string {\n  return `rgb(${array.join(',')})`;\n}\n","import { type ColorArray, colorToRGB, toColor } from '../../utils/color';\n\nimport type { ExpressionCbFunc } from '../../interfaces';\n\ntype LinearInterpolation = ['linear'];\ntype ExponentialInterpolation = [name: 'exponential', base: number];\ntype CubicBezierInterpolation = [\n  name: 'cubic-bezier',\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n];\ntype Interpolation =\n  | LinearInterpolation\n  | ExponentialInterpolation\n  | CubicBezierInterpolation;\n\ntype OutputType = any;\n\ntype InterpolateArgs = [\n  interpolation: Interpolation,\n  input: number,\n  ...stops: (number | OutputType)[],\n];\n\nfunction linearInterpolation(\n  input: number,\n  input1: number,\n  output1: OutputType,\n  input2: number,\n  output2: OutputType,\n): OutputType {\n  if (typeof output1 === 'number' && typeof output2 === 'number') {\n    return (\n      output1 + ((input - input1) / (input2 - input1)) * (output2 - output1)\n    );\n  }\n\n  try {\n    const outputColor1 = toColor(output1);\n    const outputColor2 = toColor(output2);\n    return colorToRGB(\n      outputColor1.map((val, index) => {\n        return Math.ceil(\n          linearInterpolation(input, input1, val, input2, outputColor2[index]),\n        );\n      }) as ColorArray,\n    );\n  } catch (er) {\n    console.log(er);\n  }\n\n  throw new Error('Unsupported output type for linear interpolation.');\n}\n\nexport const interpolate: ExpressionCbFunc<InterpolateArgs, OutputType> = ([\n  interpolationFn,\n  inputFn,\n  ...stops\n]) => {\n  if (stops.length < 2) {\n    throw new Error('At least two stops are required');\n  }\n  if (stops.length < 2 || stops.length % 2 !== 0) {\n    throw new Error('Invalid stops provided.');\n  }\n  const input = inputFn();\n\n  if (typeof input !== 'number') {\n    throw new Error('Input must be a number.');\n  }\n  const interpolation = interpolationFn();\n  for (let i = 0; i < stops.length - 2; i += 2) {\n    const stopInput1 = stops[i]() as number;\n    const stopOutput1 = stops[i + 1]() as OutputType;\n    const stopInput2 = stops[i + 2]() as number;\n    const stopOutput2 = stops[i + 3]() as OutputType;\n\n    if (input >= stopInput1 && input <= stopInput2) {\n      if (interpolation[0] === 'linear') {\n        return linearInterpolation(\n          input,\n          stopInput1,\n          stopOutput1,\n          stopInput2,\n          stopOutput2,\n        );\n      }\n      // else if (interpolation[0] === 'exponential') {\n      //   const base = interpolation[1];\n      //   return exponentialInterpolation(\n      //     input,\n      //     base,\n      //     stopInput1,\n      //     stopOutput1,\n      //     stopInput2,\n      //     stopOutput2,\n      //   );\n      // }\n    }\n  }\n\n  throw new Error('Invalid interpolation type.');\n};\n","import { interpolate } from './interpolate';\nimport { step } from './step';\n\nimport type {\n  ExpressionFunc,\n  InterpolationExpressionName,\n} from '../../interfaces';\n\nexport const interpolationExpressions: Record<\n  InterpolationExpressionName,\n  ExpressionFunc\n> = {\n  step,\n  interpolate,\n};\n","import type { ExpressionCbFunc } from '../../interfaces';\n\ntype OutputType = number | string | boolean | null;\n\nexport const step: ExpressionCbFunc<(number | OutputType)[], OutputType> = (\n  args,\n) => {\n  const [inputFn, defaultValue, ...stops] = args;\n  const input = inputFn();\n\n  if (typeof input !== 'number') {\n    return defaultValue() as OutputType;\n  }\n\n  for (let i = 0; i < stops.length - 2; i += 2) {\n    const stopInput = stops[i]() as number;\n    const stopOutput = stops[i + 1]() as OutputType;\n    const nextStopInput = stops[i + 2]() as number;\n\n    if (input >= stopInput && input < nextStopInput) {\n      return stopOutput;\n    }\n  }\n\n  if (input >= (stops[stops.length - 2]() as number)) {\n    return stops[stops.length - 1]();\n  }\n\n  return defaultValue();\n};\n","import e from '../utils/evaluateArgs';\n\nimport type {\n  Data,\n  ExpressionCbFunc,\n  LookupExpressionName,\n  SimpleType,\n} from '../interfaces';\n\ntype GetArg = [key: string] | [key: string, obj: Record<string, any>];\n\nfunction get([key, objExp]: GetArg, data: Data): SimpleType | null {\n  const target = objExp || data;\n  if (target && typeof target === 'object' && key in target) {\n    return target[key];\n  }\n  return null;\n}\n\nfunction has([key, objExp]: GetArg, data: Data): boolean {\n  const target = objExp || data;\n  return !!(target && typeof target === 'object' && key in target);\n}\n\nfunction at([index, array]: [index: number, array: any[]]): SimpleType {\n  return array[index];\n}\n\ntype InArgs = [keyword: string | boolean | number, input: string | any[]];\nfunction inFunc([keyword, input]: InArgs): boolean {\n  if (typeof input === 'string') {\n    return input.includes(String(keyword));\n  } else if (Array.isArray(input)) {\n    return input.includes(keyword);\n  }\n  throw new Error(\n    `Invalid input type for 'in'. Expected string or array, got ${typeof input}.`,\n  );\n}\n\nconst length = ([item]: [string | any[]]) => {\n  if (typeof item === 'string' || Array.isArray(item)) {\n    return item.length;\n  }\n  return undefined;\n};\n\ntype IndexOfArgs =\n  | [keyword: string | boolean | number, input: string | any[]]\n  | [keyword: string | boolean | number, input: string | any[], index: number];\nfunction indexOf([keyword, input, startIndex]: IndexOfArgs): number {\n  if (typeof input === 'string') {\n    return input.indexOf(String(keyword), startIndex);\n  } else if (Array.isArray(input)) {\n    return input.indexOf(keyword, startIndex);\n  }\n\n  throw new Error(\n    `Invalid input type for 'index-of'. Expected string or array, got ${typeof input}.`,\n  );\n}\n\ntype SliceArgs =\n  | [input: string | any[], startIndex: number]\n  | [input: string | any[], startIndex: number, endIndex: number];\n\nfunction slice(args: SliceArgs): string | any[] {\n  const [input, startIndex, endIndex] = args;\n\n  if (typeof input === 'string') {\n    return input.slice(startIndex, endIndex);\n  } else if (Array.isArray(input)) {\n    return input.slice(startIndex, endIndex);\n  }\n\n  throw new Error(\n    `Invalid input type for 'slice'. Expected string or array, got ${typeof input}.`,\n  );\n}\n\nexport const lookupExpressions: Record<LookupExpressionName, ExpressionCbFunc> =\n  {\n    get: e(get),\n    length: e(length),\n    at: e(at),\n    has: e(has),\n    in: e(inFunc),\n    'index-of': e(indexOf),\n    slice: e(slice),\n  };\n","import e from '../utils/evaluateArgs';\n\nimport type { ExpressionCbFunc, MathExpressionName } from '../interfaces';\n\nexport const mathExpressions: Record<\n  MathExpressionName,\n  ExpressionCbFunc<number[], number>\n> = {\n  '+': e((args) => args.reduce((a, b) => a + b, 0)),\n  '-': e((args) => args.reduce((a, b) => a - b)),\n  '*': e((args) => args.reduce((a, b) => a * b, 1)),\n  '/': e((args) => args.reduce((a, b) => a / b)),\n  '%': e((args) => args[0] % args[1]),\n  '^': e((args) => Math.pow(args[0], args[1])),\n  abs: e((args) => Math.abs(args[0])),\n  acos: e((args) => Math.acos(args[0])),\n  asin: e((args) => Math.asin(args[0])),\n  atan: e((args) => Math.atan(args[0])),\n  ceil: e((args) => Math.ceil(args[0])),\n  cos: e((args) => Math.cos(args[0])),\n  e: () => Math.E,\n  floor: e((args) => Math.floor(args[0])),\n  ln: e((args) => Math.log(args[0])),\n  ln2: () => Math.LN2,\n  log10: e((args) => Math.log10(args[0])),\n  log2: e((args) => Math.log2(args[0])),\n  max: e((args) => Math.max(...args)),\n  min: e((args) => Math.min(...args)),\n  pi: () => Math.PI,\n  round: e((args) => Math.round(args[0])),\n  sin: e((args) => Math.sin(args[0])),\n  sqrt: e((args) => Math.sqrt(args[0])),\n  tan: e((args) => Math.tan(args[0])),\n};\n","import e from '../utils/evaluateArgs';\n\nimport type { ExpressionCbFunc, StringExpressionName } from '../interfaces';\n\nexport const stringExpressions: Record<\n  StringExpressionName,\n  ExpressionCbFunc<string[], string>\n> = {\n  concat: e((args) => args.reduce((a, b) => String(a) + String(b), '')),\n  downcase: e((args) => String(args[0]).toLowerCase()),\n  upcase: e((args) => String(args[0]).toUpperCase()),\n};\n","export const tryConvert = (\n  converter: (arg: any, data: any) => any,\n  arg: any,\n  data: any,\n): any => {\n  try {\n    const result = converter(arg, data);\n    if (result !== undefined) {\n      return result;\n    }\n  } catch {\n    // ignore errors\n  }\n  return undefined;\n};\n","import { tryConvert } from './tryConvert';\n\nimport type { ExpressionFunc, SimpleType } from '../interfaces';\n\nexport default function fallback<\n  T extends SimpleType[] = SimpleType[],\n  R = T[0],\n>(cb: ExpressionFunc<T, R | undefined>): ExpressionFunc<T[], R> {\n  return (args: T[], data) => {\n    for (const arg of args) {\n      const result = tryConvert(cb, arg, data);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n    throw new Error(`Received a mismatched type`);\n  };\n}\n","import { decisionExpressions } from './expressions/decisionExpressions';\nimport { interpolationExpressions } from './expressions/interpolationExpressions';\nimport { lookupExpressions } from './expressions/lookupExpressions';\nimport { mathExpressions } from './expressions/mathExpressions';\nimport { stringExpressions } from './expressions/stringExpressions';\nimport { typeExpressions } from './expressions/typeExpressions';\n\nimport type {\n  Data,\n  Expression,\n  ExpressionFunc,\n  ExpressionName,\n  SimpleType,\n} from './interfaces';\n\nexport function isExpression(value: any): value is Expression {\n  if (Array.isArray(value)) {\n    const [lookup, ...cases] = value;\n    const l = lookup as ExpressionName;\n    return (\n      typeof l === 'string' &&\n      l !== 'literal' &&\n      l in expressions &&\n      cases.length > 0\n    );\n  }\n  return false;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFunc } = {\n  ...mathExpressions,\n  ...typeExpressions,\n  ...stringExpressions,\n  ...lookupExpressions,\n  ...decisionExpressions,\n  ...interpolationExpressions,\n};\n\nexport function evaluate<T extends SimpleType[] = SimpleType[], R = T[0]>(\n  expression: Expression,\n  data: Data = {},\n): R {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(\n      args.map((arg) => () => (isExpression(arg) ? evaluate(arg, data) : arg)),\n      data,\n    );\n  }\n  throw new Error(`Expression \"${name}\" is not supported.`);\n}\n","import e from '../utils/evaluateArgs';\nimport f from '../utils/fallback';\n\nimport type { ExpressionCbFunc, TypeExpressionName } from '../interfaces';\n\ntype ArrayType = 'string' | 'number' | 'boolean';\n\ntype ArrayArgs =\n  | [value: any[]]\n  | [type: ArrayType, value: any[]]\n  | [type: ArrayType, n: number, value: any[]];\n\nconst array = (args: ArrayArgs): any[] => {\n  const [firstArg, secondArg, thirdArg] = args;\n  let requiredType: ArrayType | undefined = undefined;\n  let requiredLength: number | undefined = undefined;\n  let value: any[] | undefined;\n\n  if (\n    typeof firstArg === 'string' &&\n    ['string', 'number', 'boolean'].includes(firstArg)\n  ) {\n    requiredType = firstArg;\n\n    if (typeof secondArg === 'number') {\n      requiredLength = secondArg;\n      value = thirdArg;\n    } else {\n      value = secondArg;\n    }\n  } else if (Array.isArray(firstArg)) {\n    value = firstArg;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error('Expected an array');\n  }\n  if (requiredType && !value.every((item) => typeof item === requiredType)) {\n    throw new Error(\n      `Expected all items in array to be of type ${requiredType}`,\n    );\n  }\n\n  if (requiredLength && value.length !== requiredLength) {\n    throw new Error(`Expected array of length ${requiredLength}`);\n  }\n  return value;\n};\n\nfunction typeOfValue(value: any): string {\n  if (value === null) return 'null';\n  switch (typeof value) {\n    case 'string':\n      return 'string';\n    case 'number':\n      return 'number';\n    case 'boolean':\n      return 'boolean';\n    case 'object':\n      if (Array.isArray(value)) {\n        let arrayType = 'value';\n        if (value.every((item) => typeof item === 'number')) {\n          arrayType = 'number';\n        } else if (value.every((item) => typeof item === 'string')) {\n          arrayType = 'string';\n        } else if (value.every((item) => typeof item === 'boolean')) {\n          arrayType = 'boolean';\n        }\n        return `array<${arrayType}, ${value.length}>`;\n      } else {\n        return 'object';\n      }\n    default:\n      return 'undefined';\n  }\n}\n\nexport const typeExpressions: Record<TypeExpressionName, ExpressionCbFunc> = {\n  array: e(array),\n  boolean: e(\n    f<boolean[]>((arg) => (typeof arg === 'boolean' ? arg : undefined)),\n  ),\n  literal: e(([arg]) => arg),\n  number: e(f<number[]>((arg) => (typeof arg === 'number' ? arg : undefined))),\n  object: e(\n    f<Record<string, any>[]>((arg) =>\n      arg !== null && typeof arg === 'object' && !Array.isArray(arg)\n        ? arg\n        : undefined,\n    ),\n  ),\n\n  string: e(f((arg) => (typeof arg === 'string' ? arg : undefined))),\n  'to-boolean': e(f(Boolean)),\n  'to-number': e(f(Number)),\n  'to-string': e(f(String)),\n  typeof: e(([arg]) => typeOfValue(arg)),\n};\n"],"names":["Cache","constructor","_options$namespace","options","arguments","length","undefined","_defineProperty","namespace","instance","this","clean","cache","all","addFull","key","valueToSet","props","add","onlyFull","exist","_find","value","Function","props_","JSON","parse","stringify","objectRemoveEmpty","cacheItem","full","push","Promise","catch","er","delete","then","x","match","cacheRecord","matchAll","filter","_filter","map","keyOrItem","e","index","indexOf","splice","find","item","itemProps","objectDeepEqual","CancelError","Error","super","Object","setPrototypeOf","prototype","PromiseControl","Map","isLoaded","_promises","size","remove","promise","has","_onStop","get","name","onStart","set","finally","abort","forEach","cancel","clear","waitFunc","func","WaitForMe","bind","target","descriptor","originalMethod","_len","args","Array","_key","apply","GetOrCreateDecorator","onStop","TimeoutError","handleCallback","resolve","reject","callback","r","ID","_Symbol$toStringTag","Symbol","toStringTag","CancelablePromise","executor","timeout","_cancelPromise","resolve_","reject_","_setCanceledCallback","promises","attach","_isPending","error","handler","_cancelHandlers","setTimeout","_promise","race","static","opt","values","v","p","_isCanceled","_children","onfulfilled","onrejected","_parentPromise","onfinally","parent","_getTopParent","_destroy","hasParent","evaluateArgs","cb","data","unwrap","a","decisionExpressions","_ref","expr","_ref2","b","_ref3","left","right","_ref4","_ref5","_ref6","_ref7","coalesce","i","arg","any","case","condition","fallback","lookupFn","cases","lookup","defValue","fry","COLORS","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","honeydew","hotpink","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","toColor","hex","test","hexToColor","isRgb","rgb","matches","parseInt","parseFloat","concat","rgbToColor","obj","hasRgb","hasValidAlpha","isColorObj","g","colorObjectToColor","result","exec","linearInterpolation","input","input1","output1","input2","output2","outputColor1","outputColor2","array","val","Math","ceil","join","console","log","interpolationExpressions","step","inputFn","defaultValue","stops","stopInput","stopOutput","nextStopInput","interpolate","interpolationFn","interpolation","stopInput1","stopOutput1","stopInput2","stopOutput2","lookupExpressions","objExp","isArray","at","in","keyword","includes","String","startIndex","slice","endIndex","mathExpressions","reduce","pow","abs","acos","asin","atan","cos","E","floor","ln","ln2","LN2","log10","log2","max","min","pi","PI","round","sin","sqrt","stringExpressions","downcase","toLowerCase","upcase","toUpperCase","tryConvert","converter","isExpression","expressions","firstArg","secondArg","thirdArg","requiredType","requiredLength","every","boolean","f","literal","number","object","string","Boolean","Number","typeof","arrayType","typeOfValue","evaluate","expression","expressionFun"],"sourceRoot":""}