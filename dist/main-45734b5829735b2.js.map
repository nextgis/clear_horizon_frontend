{"version":3,"file":"main-45734b5829735b2.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/NetworkError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/NgwError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/loadData.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/isObject.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/template.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/apiRequest.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/ResourceNotFoundError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/InsufficientPermissionsError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/activeConnectors.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/resourceToQuery.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/ResourcesControl.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/resourceCompare.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/NgwConnector.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/index.ts"],"sourcesContent":["/**\n * Thrown when...\n */\nexport class NetworkError extends Error {\n  name = 'NetworkError';\n\n  constructor(url: string) {\n    super();\n    Object.setPrototypeOf(this, NetworkError.prototype);\n    this.message = `Unable to request ${url}.\n    Possibly invalid NGW URL entered or CORS not configured to get request from ${location.origin}`; // /control-panel/cors\n  }\n}\n","import { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when...\n */\nexport class NgwError extends Error {\n  name = 'NgwError';\n\n  title!: string;\n  message!: string;\n  detail!: string;\n  exception!: NgwExceptions;\n  status_code!: number | 404 | 500;\n  data?: Record<string, any>;\n  guru_meditation!: string;\n\n  constructor(er?: Partial<NgwError>) {\n    super();\n    Object.assign(this, er);\n    Object.setPrototypeOf(this, NgwError.prototype);\n  }\n}\n","import {\n  RequestOptions as NgwRequestOptions,\n  RequestMethods,\n} from '../interfaces';\nimport { NetworkError } from '../errors/NetworkError';\nimport { NgwError } from '../errors/NgwError';\nimport { isError } from '../errors/isError';\nimport { isObject } from './isObject';\n\n// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\ntype LoadData = (\n  url: string,\n  callback: (...args: any[]) => any,\n  options: NgwRequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (cancelHandler: () => void) => void,\n) => void;\n\nlet loadData: LoadData;\n// @ts-ignore\nif (__BROWSER__) {\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): void => {\n    options.method = options.method || 'GET';\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n    if (options.responseType === 'blob') {\n      xhr.responseType = options.responseType;\n    }\n    const getResponseText = () => {\n      try {\n        return JSON.parse(xhr.responseText);\n      } catch (er) {\n        return xhr.responseText;\n      }\n    };\n    const processingResponse = (forError = false) => {\n      const cb = forError ? error : callback;\n      if (options.responseType === 'blob') {\n        cb(xhr.response);\n      } else {\n        if (xhr.responseText) {\n          cb(getResponseText());\n        } else {\n          error({ message: '' });\n        }\n      }\n    };\n    xhr.onload = () => {\n      if ([401, 403, 404, 422, 500].indexOf(xhr.status) !== -1) {\n        error(new NgwError(getResponseText()));\n      }\n      processingResponse();\n    };\n\n    // xhr.onreadystatechange = () => {\n    //   if (\n    //     (xhr.readyState === 4 && xhr.status === 200) ||\n    //     (xhr.readyState === 3 && xhr.status === 201)\n    //   ) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 3 && xhr.status === 400) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 500) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 401) {\n    //     error(xhr.statusText);\n    //   } else if (xhr.readyState === 4) {\n    //     error('request error');\n    //   }\n    // };\n\n    xhr.onerror = (er) => {\n      if (xhr.status === 0) {\n        error(new NetworkError(url));\n      } else {\n        error(er);\n      }\n    };\n\n    xhr.upload.onprogress = function (e) {\n      if (e.lengthComputable) {\n        const percentComplete = (e.loaded / e.total) * 100;\n        if (options.onProgress) {\n          options.onProgress(percentComplete, e);\n        }\n        // console.log(percentComplete + '% uploaded');\n      }\n    };\n\n    const headers = options.headers;\n    if (headers) {\n      for (const h in headers) {\n        const header = headers[h];\n        if (typeof header === 'string') {\n          xhr.setRequestHeader(h, header);\n        }\n      }\n    }\n    if (options.withCredentials !== undefined) {\n      xhr.withCredentials = options.withCredentials;\n    }\n\n    let data: FormData | any;\n    if (options.file) {\n      data = new FormData();\n      data.append('file', options.file);\n      if (options.data) {\n        for (const d in options.data) {\n          data.append(d, data[d]);\n        }\n      }\n    } else {\n      data = options.data\n        ? typeof options.data === 'string'\n          ? options.data\n          : JSON.stringify(options.data)\n        : null;\n    }\n    if (onCancel) {\n      onCancel(() => {\n        xhr.abort();\n      });\n    }\n    xhr.send(data);\n  };\n} else {\n  const url = require('url');\n  const http = require('http');\n  const https = require('https');\n  const FormData = require('form-data');\n\n  const adapterFor = (inputUrl: string) => {\n    const adapters: Record<string, any> = {\n      'http:': http,\n      'https:': https,\n    };\n    const protocol = url.parse(inputUrl).protocol || 'https:';\n    return adapters[protocol];\n  };\n\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions<RequestMethods> = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): Promise<unknown> => {\n    const { file, headers, method, data, responseType } = options;\n\n    const request = new Promise((resolve, reject) => {\n      const adapter = adapterFor(url);\n      if (adapter) {\n        const requestOpt = {\n          headers: headers || {},\n          method,\n        };\n        const body = typeof data === 'string' ? data : JSON.stringify(data);\n        // https://stackoverflow.com/questions/35589109/node-http-delete-request-no-longer-works-after-upgrading-from-0-10-40\n        let form;\n        let uploadedFile = file;\n        if (file) {\n          const fileMeta = {};\n          if (\n            isObject(file) &&\n            'file' in file &&\n            ('filename' in file || 'name' in file)\n          ) {\n            const {\n              file: file_,\n              name,\n              ...fileMeta_\n            } = file as Record<string, any>;\n            if (name && !fileMeta_.filename) {\n              fileMeta_.filename = name;\n            }\n            Object.assign(fileMeta, fileMeta_);\n            uploadedFile = file_ as File;\n          }\n          form = new FormData();\n          form.append('file', uploadedFile, fileMeta);\n          if (data) {\n            for (const d in data) {\n              form.append(d, data[d]);\n            }\n          }\n          Object.assign(requestOpt.headers, {\n            // 'content-length': form.getLengthSync(),\n            ...form.getHeaders(),\n          });\n        }\n\n        if (body !== undefined) {\n          Object.assign(requestOpt.headers, {\n            'content-type': 'application/json',\n            'content-length': Buffer.byteLength(body),\n          });\n        }\n        const req = adapter.request(url, requestOpt, (resp: any) => {\n          let data = '';\n          resp.on('data', (chunk: any) => {\n            data += chunk;\n          });\n          resp.on('end', () => {\n            if (data) {\n              if (responseType === 'blob') {\n                resolve(data);\n              } else {\n                let json: Record<string, any> | undefined;\n                try {\n                  json = JSON.parse(data);\n                  if (json && json.status_code && json.status_code) {\n                    reject(json.message);\n                  }\n                } catch (er) {\n                  reject(er);\n                }\n                if (json !== undefined) {\n                  if (isError(json)) {\n                    reject('extractError(json)');\n                  } else {\n                    resolve(json);\n                  }\n                }\n              }\n            }\n            reject('no data');\n          });\n        });\n        if (form) {\n          form.pipe(req);\n        }\n        req.on('error', (err: any) => {\n          reject(err);\n        });\n        if (body) {\n          req.write(body);\n        }\n        onCancel(() => {\n          req.abort();\n        });\n        req.end();\n      } else {\n        throw new Error(`Given URL '${url}' is not correct`);\n      }\n    });\n    return request\n      .then((data) => {\n        if (callback) {\n          callback(data);\n        }\n        return data;\n      })\n      .catch((er) => {\n        if (error) {\n          error(er);\n        } else {\n          throw new Error(er);\n        }\n      });\n  };\n}\n\nexport { loadData };\n","export function isObject(val: unknown): val is Record<string | number, any> {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n","// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }): string {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { template } from './template';\nimport type { NgwConnector } from '../NgwConnector';\nimport type {\n  RequestItemKeys,\n  RequestItemsParams,\n  RequestOptions,\n} from '../interfaces';\nimport type { RequestItemsParamsMap } from '../types/RequestItemsParamsMap';\n\ninterface ApiRequestOptions<K extends keyof RequestItemsParamsMap> {\n  name: string;\n  connector: NgwConnector;\n  params: RequestItemsParams<K>;\n  requestOptions: RequestOptions;\n}\n\nexport function apiRequest<\n  K extends keyof RequestItemsParamsMap,\n  P extends RequestItemKeys = RequestItemKeys,\n>(opt: ApiRequestOptions<K>): CancelablePromise<P[K]> {\n  const params = opt.params;\n  return new CancelablePromise((resolve, reject) => {\n    opt.connector\n      .connect()\n      .then((apiItems) => {\n        let apiItem = apiItems && apiItems[opt.name];\n        if (apiItem) {\n          apiItem = [...apiItem];\n          let url = apiItem.shift();\n          if (apiItem.length) {\n            const replaceParams: {\n              [num: number]: string;\n            } = {};\n            for (let fry = 0; fry < apiItem.length; fry++) {\n              const arg = apiItem[fry];\n              replaceParams[fry] = '{' + arg + '}';\n              if (params[arg] === undefined) {\n                throw new Error(\n                  '`' + arg + '`' + ' url api argument is not specified',\n                );\n              }\n            }\n            if (url) {\n              url = template(url, replaceParams);\n            }\n          }\n          // Transfer part of the parameters from `params` to the URL string\n          if (params) {\n            const paramArray = [];\n            const paramList = params.paramList;\n            if (Array.isArray(paramList)) {\n              delete params.paramList;\n              paramList.forEach((x) => {\n                paramArray.push(`${x[0]}=${x[1]}`);\n              });\n            }\n            for (const p in params) {\n              if (apiItem.indexOf(p) === -1) {\n                paramArray.push(`${p}=${params[p]}`);\n              }\n            }\n            if (paramArray.length) {\n              url = url + '?' + paramArray.join('&');\n            }\n          }\n          if (url) {\n            resolve(opt.connector.makeQuery(url, params, opt.requestOptions));\n          } else {\n            reject(new Error('request url is not set'));\n          }\n        } else {\n          resolve(undefined);\n        }\n      })\n      .catch((er) => {\n        reject(er);\n      });\n  });\n}\n","import { NgwError } from './NgwError';\nimport { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class ResourceNotFoundError extends NgwError {\n  name = 'ResourceNotFoundError';\n  exception: NgwExceptions = 'nextgisweb.resource.exception.ResourceNotFound';\n\n  constructor(obj?: ResourceNotFoundError) {\n    super(obj);\n    Object.setPrototypeOf(this, ResourceNotFoundError.prototype);\n  }\n}\n","import { NgwError } from './NgwError';\nimport { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class InsufficientPermissionsError extends NgwError {\n  name = 'InsufficientPermissionsError';\n  exception: NgwExceptions =\n    'nextgisweb.core.exception.InsufficientPermissions';\n\n  constructor(obj: InsufficientPermissionsError) {\n    super(obj);\n    Object.setPrototypeOf(this, InsufficientPermissionsError.prototype);\n  }\n}\n","import { NgwConnectorOptions } from './interfaces';\nimport { NgwConnector } from './NgwConnector';\nimport { objectDeepEqual } from '@nextgis/utils';\n\nexport const CONNECTORS: NgwConnector[] = [];\n\nexport function addConnector(connector: NgwConnector): void {\n  CONNECTORS.push(connector);\n}\n\nexport function findConnector(\n  options: NgwConnectorOptions,\n): NgwConnector | undefined {\n  return CONNECTORS.find((x) => {\n    if (x.options.baseUrl === options.baseUrl) {\n      if (options.auth) {\n        if (x.options.auth) {\n          return objectDeepEqual(x.options.auth, options.auth);\n        }\n      } else {\n        // if auth not in find options; use first connector with same url\n        return true;\n      }\n    }\n  });\n}\n\nexport function removeConnector(connector: NgwConnector): void {\n  const index = CONNECTORS.indexOf(connector);\n  if (index !== -1) {\n    CONNECTORS.splice(index, 1);\n  }\n}\n\nexport function findAndRemoveConnector(options: NgwConnectorOptions): void {\n  const exist = findConnector(options);\n  if (exist) {\n    removeConnector(exist);\n  }\n}\n","import { DeepPartial, defined } from '@nextgis/utils';\nimport { Resource } from '../types/ResourceItem';\nimport { isObject } from './isObject';\n\nconst exclude = ['description'];\n\n/**\n * @remarks\n * https://docs.nextgis.ru/docs_ngweb_dev/doc/developer/resource.html#search-resources\n *\n * ```\n * { keyname, owner_user: { id }} > { keyname, owner_user__id }\n * ```\n *\n * @param resource - Any property from NGW resource item\n */\nexport function resourceToQuery(\n  resource: DeepPartial<Resource>,\n  prefix = '',\n): Record<string, unknown> {\n  prefix = prefix ? prefix + '__' : '';\n  const query: Record<string, any> = {};\n  for (const [key, value] of Object.entries(resource)) {\n    if (exclude.indexOf(key) === -1) {\n      if (isObject(value)) {\n        if (key === 'owner_user') {\n          const children = resourceToQuery(value as DeepPartial<Resource>, key);\n          Object.assign(query, children);\n        } else if (key === 'parent' && 'id' in value) {\n          query.parent_id = value.id;\n        }\n      } else if (defined(value)) {\n        query[prefix + key] = value;\n      }\n    }\n  }\n  return query;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined } from '@nextgis/utils';\nimport Cache from '@nextgis/cache';\n\nimport { resourceToQuery } from './utils/resourceToQuery';\nimport { resourceCompare } from './utils/resourceCompare';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\n\nimport { isObject } from './utils/isObject';\n\nimport type { DeepPartial } from '@nextgis/utils';\nimport type { NgwConnector } from './NgwConnector';\nimport type { ResourceItem, Resource } from './types/ResourceItem';\nimport type {\n  GetChildrenOfOptions,\n  ResourceDefinition,\n  RequestOptions,\n} from './interfaces';\n\nexport class ResourcesControl {\n  cache = new Cache<\n    CancelablePromise<ResourceItem | undefined>,\n    { id?: number | string }\n  >();\n\n  constructor(private connector: NgwConnector) {}\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Receive resource from NGW by id, keyname or search-object parameter.\n   * @param resource - Resource id, keyname or search-object\n   *\n   * @remarks\n   * Fetching resource would be cached to speed up next call\n   */\n  getOne(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const cache = new Cache();\n    const forCache: { keyname?: string; id?: number } = {};\n    const opt = { ...requestOptions, cache: false };\n    if (typeof resource === 'string') {\n      forCache.keyname = resource;\n    } else if (typeof resource === 'number') {\n      forCache.id = resource;\n    } else if (isObject(resource)) {\n      if (resource.id !== undefined) {\n        forCache.id = resource.id;\n      } else if (resource.keyname) {\n        forCache.keyname = resource.keyname;\n      }\n    }\n    const makeRequest = () => {\n      if (typeof resource === 'string') {\n        return this._fetchResourceBy({ keyname: resource }, opt);\n      } else if (typeof resource === 'number') {\n        return this._fetchResourceById(resource, opt);\n      } else if (isObject(resource)) {\n        return this._fetchResourceBy(resource, opt);\n      }\n      return CancelablePromise.resolve(undefined);\n    };\n\n    return cache.addFull('resource', makeRequest, forCache);\n  }\n\n  getOneOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem> {\n    return this.getOne(resource, requestOptions).then((res) => {\n      if (res) {\n        return res;\n      }\n      throw new ResourceNotFoundError();\n    });\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * There are situations when exactly the resource id is needed\n   * (for example, to compose the correct request to the api)\n   * then this method will come in handy to facilitate the extraction of the identifier\n   * if the resource is specified through a keyname or other parameters.\n   */\n  getId(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number | undefined> {\n    if (typeof resource === 'number') {\n      return CancelablePromise.resolve(resource);\n    } else if (typeof resource === 'string' || isObject(resource)) {\n      return this.getOne(resource, requestOptions).then((res) => {\n        if (res) {\n          return res.resource.id;\n        }\n      });\n    }\n    return CancelablePromise.resolve(undefined);\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * Similar with {@link NgwConnector.getResourceId | getResourceId} but rise error if resource is not exist.\n   * To not make one more checks if the resource is definitely exists\n   */\n  getIdOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number> {\n    return this.getId(resource, requestOptions).then((resp) => {\n      if (resp === undefined) {\n        throw new Error();\n      }\n      return resp;\n    });\n  }\n\n  getMany(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this._resourceCacheFilter(resource).then((items) => {\n      if (!items.length) {\n        const query: Record<string, unknown> = {};\n        if (resource.keyname) {\n          query.keyname = resource.keyname;\n        } else {\n          Object.assign(query, resourceToQuery(resource));\n        }\n        return this.connector\n          .get('resource.search', requestOptions, {\n            serialization: 'full',\n            ...query,\n          })\n          .then((resources) => {\n            if (resources) {\n              for (const x of resources) {\n                this.cache.add('resource.item', CancelablePromise.resolve(x), {\n                  id: x.resource.id,\n                });\n              }\n            }\n            return resources;\n          });\n      }\n      return items;\n    });\n  }\n\n  getParent(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getOne(resource, requestOptions).then((child) => {\n      if (child) {\n        return this.getOne(child.resource.parent.id, requestOptions);\n      }\n      return CancelablePromise.resolve(undefined);\n    });\n  }\n\n  getChildrenOf(\n    resource: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.getIdOrFail(resource).then((parent) =>\n      this._getChildrenOf(parent, requestOptions),\n    );\n  }\n\n  update(\n    resource: ResourceDefinition,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.put('resource.item', { data }, { id });\n      }\n    });\n  }\n\n  /**\n   * Fast way to delete resource from NGW and clean cache.\n   * @param resource - Resource definition\n   */\n  delete(resource: ResourceDefinition): CancelablePromise<void> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.delete('resource.item', null, { id }).then(() => {\n          this._cleanResourceItemCache(id);\n          return undefined;\n        });\n      }\n    });\n  }\n\n  private _getChildrenOf(\n    parent: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n    _items: ResourceItem[] = [],\n  ): CancelablePromise<ResourceItem[]> {\n    return this.connector\n      .get(\n        'resource.collection',\n        { cache: true, ...requestOptions },\n        {\n          parent,\n        },\n      )\n      .then((items) => {\n        const recursivePromises = [];\n        for (const item of items) {\n          this.cache.add('resource.item', CancelablePromise.resolve(item), {\n            id: item.resource.id,\n          });\n          _items.push(item);\n          if (requestOptions?.recursive && item.resource.children) {\n            recursivePromises.push(\n              this._getChildrenOf(item.resource.id, requestOptions, _items),\n            );\n          }\n        }\n        if (recursivePromises.length) {\n          return CancelablePromise.all(recursivePromises).then(() => {\n            return _items;\n          });\n        }\n        return _items;\n      });\n  }\n\n  private async _cleanResourceItemCache(id: number) {\n    const all = this.cache.all();\n    const toDelete: typeof all = [];\n    for (const c of all) {\n      const cid = c.options && c.options.id;\n      if (['resource.item', 'resource'].includes(c.key) && cid !== undefined) {\n        if (typeof cid === 'number') {\n          if (cid === id) {\n            toDelete.push(c);\n          }\n        } else {\n          const rid = await this.getId(cid);\n          if (rid === id) {\n            toDelete.push(c);\n          }\n        }\n      }\n    }\n    for (const d of toDelete) {\n      this.cache.delete(d);\n    }\n  }\n\n  private _fetchResourceById(\n    id: number,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const promise = () =>\n      this.connector.get('resource.item', requestOptions, { id });\n\n    return this.cache\n      .add('resource.item', promise, {\n        id,\n      })\n      .catch((er) => {\n        if (!(er instanceof ResourceNotFoundError)) {\n          throw er;\n        }\n        return undefined;\n      });\n  }\n\n  private _fetchResourceBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getMany(resource, requestOptions).then((resources) => {\n      return resources[0];\n    });\n  }\n\n  private _resourceCacheFilter(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem[]> {\n    return CancelablePromise.all(this.cache.matchAll('resource.item')).then(\n      (resources) => {\n        const items: ResourceItem[] = [];\n        resources.filter((x) => {\n          if (x) {\n            // identical by uniq props\n            if (resource.keyname && x.resource.keyname) {\n              return resource.keyname === x.resource.keyname;\n            }\n            if (defined(resource.id) && defined(x.resource.id)) {\n              return resource.id === x.resource.id;\n            }\n            return resourceCompare(resource, x.resource);\n          }\n        });\n        return items;\n      },\n    );\n  }\n}\n","import { objectDeepEqual } from '@nextgis/utils';\nimport type { DeepPartial } from '@nextgis/utils';\nimport type { Resource } from '../types/ResourceItem';\n\nexport function resourceCompare(\n  res1: DeepPartial<Resource>,\n  res2: DeepPartial<Resource>,\n): boolean {\n  return objectDeepEqual(res1, res2);\n}\n","import { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { objectRemoveEmpty } from '@nextgis/utils';\nimport { fixUrlStr } from '@nextgis/utils';\nimport Cache from '@nextgis/cache';\n\nimport { loadData } from './utils/loadData';\nimport { template } from './utils/template';\nimport { NgwError } from './errors/NgwError';\nimport { apiRequest } from './utils/apiRequest';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\nimport { InsufficientPermissionsError } from './errors/InsufficientPermissionsError';\nimport {\n  addConnector,\n  findConnector,\n  removeConnector,\n} from './activeConnectors';\nimport { ResourcesControl } from './ResourcesControl';\n\nimport type { DeepPartial } from '@nextgis/utils';\nimport type {\n  DeleteRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  PostRequestItemsResponseMap,\n  GetRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  RequestTransformFunction,\n  GetChildrenOfOptions,\n  ResourceIdKeynameDef,\n  NgwConnectorOptions,\n  ResourceDefinition,\n  RequestItemsParams,\n  RequestItemKeys,\n  RequestHeaders,\n  RequestOptions,\n  PyramidRoute,\n  Credentials,\n  UserInfo,\n  Params,\n} from './interfaces';\nimport type { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport type { ResourceItem, Resource } from './types/ResourceItem';\n\nlet ID = 0;\n\nexport class NgwConnector {\n  static errors = {\n    NgwError,\n    ResourceNotFoundError,\n  };\n  id = ID++;\n\n  emitter = new EventEmitter();\n  user?: UserInfo;\n\n  resources!: ResourcesControl;\n\n  private routeStr = '/api/component/pyramid/route';\n  private activeRequests: CancelablePromise[] = [];\n  private requestTransform?: RequestTransformFunction | null;\n\n  constructor(public options: NgwConnectorOptions) {\n    const exist = findConnector(options);\n    if (exist) {\n      return exist;\n    } else {\n      if (this.options.route) {\n        this.routeStr = this.options.route;\n      }\n      if (this.options.requestTransform) {\n        this.requestTransform = this.options.requestTransform;\n      }\n      this.resources = new ResourcesControl(this);\n      addConnector(this);\n    }\n  }\n\n  static create(options: NgwConnectorOptions): NgwConnector {\n    return new this(options);\n  }\n\n  setRequestTransform(\n    requestTransform: RequestTransformFunction | undefined | null,\n  ) {\n    this.requestTransform = requestTransform;\n  }\n\n  /**\n   * Fast way to specify the connection address to NextGIS Web.\n   * The current connection will be severed.\n   * @param baseUrl - NGW url\n   */\n  setNgw(baseUrl: string): void {\n    this.logout();\n    this.options.baseUrl = baseUrl;\n    addConnector(this);\n  }\n\n  /**\n   * Establishing a connection with NextGIS Web to fulfill all other requests.\n   * @remarks\n   * This method need not be called manually as it is used when forming a request in {@link NgwConnector.apiRequest | apiRequest}.\n   * Can be used to check connection.\n   * @example\n   * ```javascript\n   * const connector = new NgwConnector({baseUrl: 'https://demo.nextgis.com'});\n   * connector.connect()\n   *   .then(() => console.log('Ok'))\n   *   .catch((er) => console.log('Connection problem', er));\n   * ```\n   */\n  connect(): CancelablePromise<PyramidRoute> {\n    const cache = new Cache();\n    const auth = this.options.auth;\n    const makeConnect = () =>\n      new CancelablePromise((resolve, reject) => {\n        const makeQuery = () => {\n          return this.makeQuery<PyramidRoute>(this.routeStr, {}, {})\n            .then((route) => {\n              resolve(route);\n            })\n            .catch((er) => {\n              reject(er);\n            });\n        };\n        if (auth) {\n          const { login, password } = auth;\n          if (login && password) {\n            return this._login({ login, password })\n              .then(() => {\n                return makeQuery();\n              })\n              .catch((er) => reject(er));\n          }\n        }\n        return makeQuery();\n      });\n    return cache.add('route', makeConnect, {\n      id: this.id,\n      auth,\n      baseUrl: this.options.baseUrl,\n    });\n  }\n\n  /**\n   * Quick way to change NextGIS Web user.\n   * @param credentials - New user credentials\n   */\n  login(\n    credentials: Credentials,\n    options?: RequestOptions,\n  ): CancelablePromise<UserInfo> {\n    this.logout();\n    addConnector(this);\n    return this._login(credentials, options);\n  }\n\n  /**\n   * Disconnecting a user. Aborting all current requests\n   */\n  logout(): void {\n    this.abort();\n    removeConnector(this);\n    this.options.auth = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n    this.resources.cache.clean();\n  }\n\n  getUserInfo(\n    credentials?: Credentials,\n    options?: RequestOptions,\n  ): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options_: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials),\n      // withCredentials: true\n      ...options,\n    };\n\n    // Do not use apiRequest('auth.current_user') to avoid circular-references\n    return this.makeQuery<UserInfo>(\n      '/api/component/auth/current_user',\n      {},\n      options_,\n    );\n  }\n\n  /**\n   * Obtaining the required Headers for authentication of requests in the NGW.\n   */\n  getAuthorizationHeaders(\n    credentials?: Credentials,\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client,\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials): string | undefined {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      const str = unescape(encodeURIComponent(`${login}:${password}`));\n      // @ts-ignore\n      if (__BROWSER__) {\n        return window.btoa(str);\n      } else {\n        return Buffer.from(str).toString('base64');\n      }\n    }\n  }\n\n  /** Stop all api requests */\n  abort() {\n    for (const req of this.activeRequests) {\n      req.cancel();\n    }\n    this.activeRequests = [];\n  }\n\n  getActiveApiRequests() {\n    return [...this.activeRequests];\n  }\n\n  /**\n   * Send request to NGW api router.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param params - Request item params or query params\n   * @param requestOptions - Request options\n   *\n   * @example\n   * ```javascript\n   *\n   * // there is such an NGW route item\n   * // \"feature_layer.feature.item\": [\n   * //   \"/api/resource/{0}/feature/{1}\",\n   * //   \"id\",\n   * //   \"fid\"\n   * // ],\n   *\n   * const connector = new NgwConnector({ baseUrl: 'https://example.nextgis.com' });\n   * connector.apiRequest('feature_layer.feature.item', {\n   *   // request params for {0} and {1}\n   *   'id': 2011,\n   *   'fid': 101,\n   *   // query params\n   *   'srs': 4326,\n   *   'geom_format': 'geojson',\n   * }, { method: 'GET' });\n   * // send get-request to 'https://example.nextgis.com/api/resource/2011/feature/101?srs=4326&geom_format=geojson'\n   *\n   * ```\n   */\n  apiRequest<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys,\n  >(\n    name: K,\n    params_: RequestItemsParams<K> = {},\n    requestOptions: RequestOptions = {},\n  ): CancelablePromise<P[K]> {\n    const { method, headers, withCredentials, responseType } = requestOptions;\n    const params = objectRemoveEmpty(params_);\n    const makeApiRequest = () =>\n      apiRequest({ name, params, requestOptions, connector: this });\n    if (requestOptions.cache && method === 'GET') {\n      const cache = new Cache<CancelablePromise<P[K]>>();\n      return cache.add(name, makeApiRequest, {\n        params,\n        ...objectRemoveEmpty({\n          headers,\n          withCredentials,\n          responseType,\n          baseUrl: this.options.baseUrl,\n          userId: this.user?.id,\n        }),\n      });\n    }\n    return makeApiRequest();\n  }\n\n  /**\n   * Shortcut method for send POST request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   *\n   * @example\n   * ```javascript\n   * connector.post('resource.collection', { data: POST_PAYLOAD })\n   *   .then((newResource) => console.log(newResource))\n   *   .catch((error) => console.warn(error));\n   * ```\n   */\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    return this.apiRequest<K, PostRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send GET request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    return this.apiRequest<K, GetRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PATCH request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    return this.apiRequest<K, PatchRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PUT request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    return this.apiRequest<K, PutRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send DELETE request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    return this.apiRequest<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Send request to NGW.\n   * @param url - URL address to NGW\n   * @param params - Query params\n   * @param options - Request options\n   */\n  makeQuery<R = unknown>(\n    url: string,\n    params?: Params | null,\n    options: RequestOptions = {},\n  ): CancelablePromise<R> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      url = encodeURI(fixUrlStr(url));\n      return this._loadData(url, options);\n    } else {\n      throw new Error('Empty `url` not allowed');\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * {@inheritDoc ResourcesControl.getOne}\n   */\n  getResource(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getOneOrFail}\n   */\n  getResourceOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem> {\n    return this.resources.getOneOrFail(resource, requestOptions);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceBy(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceByKeyname(\n    keyname: string,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(keyname);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceById(id: number): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(id);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getId}\n   */\n  getResourceId(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number | undefined> {\n    return this.resources.getId(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getIdOrFail}\n   */\n  getResourceIdOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<number> {\n    return this.resources.getIdOrFail(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getMany}\n   */\n  getResourcesBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getMany(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getParent}\n   */\n  getResourceParent(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getParent(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getChildrenOf}\n   */\n  getResourceChildren(\n    resource: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getChildrenOf(resource, requestOptions);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.update}\n   */\n  updateResource(\n    resource: ResourceIdKeynameDef,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.update(resource, data);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.delete}\n   */\n  deleteResource(resource: ResourceIdKeynameDef): CancelablePromise<void> {\n    return this.resources.delete(resource);\n  }\n\n  /**\n   * @internal\n   */\n  protected _loadData(\n    url: string,\n    options: RequestOptions,\n  ): CancelablePromise<any> {\n    options.responseType = options.responseType || 'json';\n\n    const request = new CancelablePromise((resolve, reject, onCancel) => {\n      if (this.user) {\n        options = options || {};\n        // options.withCredentials = true;\n        options.headers = {\n          ...this.getAuthorizationHeaders(),\n          ...options.headers,\n        };\n      }\n\n      if (this.requestTransform) {\n        const [transUrl, transOptions] = this.requestTransform(url, options);\n        url = transUrl;\n        options = transOptions;\n      }\n      loadData(url, resolve, options, reject, onCancel);\n    })\n      .then((resp) => {\n        this._cleanActiveRequests(request);\n        return resp;\n      })\n      .catch((httpError) => {\n        this._cleanActiveRequests(request);\n        if (httpError instanceof CancelablePromise.CancelError) {\n          // not need to handle cancel error because onCancel method is used\n        } else {\n          // @ts-ignore\n          if (__DEV__) {\n            console.warn('DEV WARN', httpError);\n          }\n          const er = this._handleHttpError(httpError);\n          if (er) {\n            throw er;\n          }\n        }\n      });\n    if (\n      options.signal &&\n      typeof options.signal.addEventListener === 'function'\n    ) {\n      options.signal.addEventListener('abort', () => {\n        request.cancel();\n        this._cleanActiveRequests(request);\n      });\n    }\n    this.activeRequests.push(request);\n    return request;\n  }\n\n  private _login(\n    credentials: Credentials,\n    options?: RequestOptions,\n  ): CancelablePromise<UserInfo> {\n    return this.getUserInfo(credentials, options)\n      .then((data) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch((er) => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  private _cleanActiveRequests(request: CancelablePromise) {\n    const activeRequestIndex = this.activeRequests.indexOf(request);\n    if (activeRequestIndex !== -1) {\n      this.activeRequests.splice(activeRequestIndex, 1);\n    }\n  }\n\n  private _handleHttpError(er: Error) {\n    if (er) {\n      if (er instanceof NgwError) {\n        if (er.exception === 'nextgisweb.resource.exception.ResourceNotFound') {\n          throw new ResourceNotFoundError(er);\n        } else if (\n          er.exception === 'nextgisweb.core.exception.InsufficientPermissions'\n        ) {\n          throw new InsufficientPermissionsError(er);\n        }\n      }\n    }\n    return er;\n  }\n}\n","/**\n * A lightweight HTTP client optimized for use with {@link http://docs.nextgis.ru/docs_ngweb_dev/doc/developer/toc.html | NextGIS Web} API\n *\n * @remarks\n * Make sure CORS is registered in the {@link https://docs.nextgis.com/docs_ngcom/source/CORS.html | NextGIS Web settings } to be able to send requests.\n *\n * @packageDocumentation\n * @module ngw-connector\n */\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\n// export { NgwConnector };\nexport default NgwConnector;\n"],"names":["NetworkError","url","Object","setPrototypeOf","prototype","message","location","origin","Error","loadData","NgwError","er","assign","isObject","val","toString","call","callback","options","error","onCancel","method","xhr","XMLHttpRequest","open","responseType","getResponseText","JSON","parse","responseText","processingResponse","forError","cb","response","onload","indexOf","status","onerror","upload","onprogress","e","lengthComputable","percentComplete","loaded","total","onProgress","data","headers","h","header","setRequestHeader","undefined","withCredentials","file","FormData","append","d","stringify","abort","send","templateRe","template","str","replace","s","key","value","apiRequest","opt","params","CancelablePromise","resolve","reject","connector","connect","then","apiItems","apiItem","name","shift","length","replaceParams","fry","arg","paramArray","paramList","p","Array","isArray","forEach","x","push","join","makeQuery","requestOptions","catch","ResourceNotFoundError","obj","InsufficientPermissionsError","CONNECTORS","addConnector","exclude","resourceToQuery","resource","prefix","query","entries","children","parent_id","id","defined","ResourcesControl","Cache","cache","forCache","keyname","addFull","_fetchResourceBy","_fetchResourceById","this","getOne","res","getId","resp","_resourceCacheFilter","items","get","serialization","resources","add","child","parent","getIdOrFail","_getChildrenOf","put","delete","_cleanResourceItemCache","_items","recursivePromises","item","recursive","all","toDelete","c","cid","includes","getMany","matchAll","filter","res1","res2","objectDeepEqual","ID","NgwConnector","EventEmitter","exist","find","baseUrl","auth","findConnector","route","routeStr","requestTransform","logout","login","password","_login","credentials","index","splice","user","emitter","emit","clean","options_","getAuthorizationHeaders","client","makeClientId","Authorization","unescape","encodeURIComponent","window","btoa","activeRequests","cancel","params_","objectRemoveEmpty","makeApiRequest","userId","encodeURI","fixUrlStr","_loadData","getOneOrFail","getParent","getChildrenOf","update","request","transUrl","transOptions","_cleanActiveRequests","httpError","_handleHttpError","signal","addEventListener","getUserInfo","activeRequestIndex","exception"],"sourceRoot":""}