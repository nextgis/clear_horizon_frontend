{"version":3,"file":"main-4aa8b69de44906e.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/icons/src/index.ts","webpack://clear_horizon/./@nextgis/packages/item/src/TreeHelper.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/BaseProperty.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/CheckProperty.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/ItemProperties.ts","webpack://clear_horizon/./@nextgis/packages/item/src/Item.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/convertMapClickEvent.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/createControl.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/Attribution.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/boundsToArray.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/geometries.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/detectType.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/createMouseEvent.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/callAjax.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageOverlay.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/makeRemoteTileLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/TileAdapter/TileLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/TileAdapter/TileAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/WmsAdapter/WmsLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/WmsAdapter/WmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/LeafletMapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/createButtonControl.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/index.ts"],"sourcesContent":["/**\n * @module icons\n */\n\n// tslint:disable:max-line-length\nimport { IconOptions as WebmapIcoOptions } from '@nextgis/paint';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star: '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>',\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'circle'\n    | 'brill'\n    | 'rect'\n    | 'marker'\n    | 'star'\n    | 'asterisk'\n    | 'triangle'\n    | 'plus'\n    | 'minus';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string,\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): WebmapIcoOptions {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg,\n  };\n}\n","import { treeFind, treeFilter, treeEvery, treeSome } from '@nextgis/tree';\nimport { Item } from './Item';\nimport { ItemOptions } from './interfaces';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  setParent(parent: Item): void {\n    this._parent = parent;\n  }\n\n  addChild(child: Item): void {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return treeFilter<I>(\n        parent,\n        filterFunc,\n        (x: I) => x.tree.getParent() as I,\n      );\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n\n  find(filterFunc?: (item: Item) => boolean): Item<ItemOptions> | undefined {\n    return treeFind(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  every<I extends Item = Item>(filterFunc?: (item: I) => boolean): boolean {\n    return treeEvery(this._children as I[], filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  some<I extends Item = Item>(filterFunc?: (item: I) => boolean): boolean {\n    return treeSome(this._children as I[], filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return treeFilter(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return [...this._children] as T[];\n  }\n}\n","import { EventEmitter } from 'events';\nimport type { Item } from '../Item';\nimport type { ItemBasePropertyOptions, ItemOptions } from '../interfaces';\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>,\n  I extends Item = Item,\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = new EventEmitter();\n  name: string;\n\n  item: I;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: I, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty(): V | undefined {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent(): Item<ItemOptions> | undefined {\n    return this.item.tree.getParent();\n  }\n\n  getChildren(): Item<ItemOptions>[] {\n    return this.item.tree.getChildren();\n  }\n\n  isGroup(): number {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked(): boolean {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O): void {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O): void {\n    this._callOnSet(value, options);\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this._container;\n  }\n\n  destroy(): void {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O): void {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O): void {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach((x) => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', {\n            value,\n            options,\n            item: this.item,\n          });\n        }\n      });\n    }\n  }\n}\n","import { BaseProperty } from './BaseProperty';\n\nimport type { Item } from '../Item';\nimport type { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\ntype PreparedValue = any;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>,\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle',\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O): void {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false }),\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue(): boolean | undefined {\n    return (\n      this.get() &&\n      this.getParents().every((x) => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  block(options?: O): void {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  unBlock(options?: O): void {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  blockChild(options?: O): void {\n    this.item.tree\n      .getDescendants()\n      .forEach((x) => this._blockChild(x, options));\n  }\n\n  unblockChild(options?: O): void {\n    this.item.tree.getChildren().forEach((x) => this._unBlockChild(x, options));\n  }\n\n  protected _prepareValue(value?: PreparedValue): V | undefined {\n    return value;\n  }\n\n  private _turnOff(options?: O): void {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChild(options);\n    }\n  }\n\n  private _turnOn(options?: O): void {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChild(options);\n    }\n  }\n\n  private _block(options?: O): void {\n    this._turnOff(options);\n  }\n\n  private _unBlock(options?: O): void {\n    this._turnOn(options);\n  }\n\n  private _blockChild(item: Item, options?: O): void {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  private _unBlockChild(item: Item, options?: O): void {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  private _propagation(value?: V, options?: O): void {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false,\n            },\n          });\n        }\n      }\n    }\n  }\n}\n","import { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes,\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty,\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[],\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>): void {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(\n    propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>,\n  ): void {\n    const handlers = ItemProperties.handlers;\n    let Handler = propOpt.handler;\n    if (!Handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          Handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          Handler = handlers.BaseProperty;\n          break;\n        default:\n          Handler = handlers.BaseProperty;\n      }\n    }\n    if (Handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new Handler(\n        propOpt.name,\n        this.item,\n        options,\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update(): void {\n    this.list().forEach((x) => {\n      x.update();\n    });\n  }\n\n  get(name: string): any {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>,\n  ): void {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string): BaseProperty<any, ItemBasePropertyOptions<any>> {\n    return this._properties[name];\n  }\n\n  list(): BaseProperty<any, ItemBasePropertyOptions<any>>[] {\n    return this._propertiesList.map((x) => this._properties[x]);\n  }\n\n  destroy(): void {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","import { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties(): void {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","import type { LeafletMouseEvent } from 'leaflet';\n\nimport type { MapClickEvent } from '@nextgis/webmap';\n\nexport function convertMapClickEvent(evt: LeafletMouseEvent): MapClickEvent {\n  const coord = evt.containerPoint;\n  const latLng = evt.latlng;\n  const { lat, lng } = latLng;\n  return {\n    latLng,\n    lngLat: [lng, lat],\n    pixel: { left: coord.x, top: coord.y },\n    source: evt,\n  };\n}\n","import { Control, DomEvent } from 'leaflet';\nimport type {\n  MapControl,\n  CreateControlOptions,\n  MapAdapter,\n} from '@nextgis/webmap';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {},\n  map: MapAdapter,\n): Control {\n  const C = Control.extend({\n    onAdd() {\n      const element = document.createElement('div');\n      const content = control.onAdd(map);\n      element.classList.add('leaflet-control');\n      if (options.bar) {\n        element.classList.add('leaflet-bar');\n      }\n      if (!options.margin && !options.bar) {\n        element.style.marginBottom = '0px';\n        element.style.marginTop = '0px';\n        element.style.marginLeft = '0px';\n        element.style.marginRight = '0px';\n      }\n      if (content) {\n        element.appendChild(content);\n      }\n\n      DomEvent.disableClickPropagation(element);\n\n      return element;\n    },\n    onRemove() {\n      control.onRemove();\n    },\n  });\n  return new C();\n}\n","import { Control, ControlOptions } from 'leaflet';\nimport { AttributionControlOptions } from '@nextgis/webmap';\n\nexport class AttributionControl extends Control.Attribution {\n  // options: AttributionControlOptions\n  constructor(options: AttributionControlOptions & ControlOptions) {\n    super(options);\n    const customAttribution = options && options.customAttribution;\n    if (customAttribution) {\n      let attributions: string[] = [];\n      if (Array.isArray(customAttribution)) {\n        attributions = customAttribution;\n      } else if (customAttribution) {\n        attributions = [customAttribution];\n      }\n      attributions.forEach((x) => this.addAttribution(x));\n    }\n  }\n}\n","import type { LatLngBounds } from 'leaflet';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\nexport function boundsToArray(bounds: LatLngBounds): LngLatBoundsArray {\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  return [sw.lng, sw.lat, ne.lng, ne.lat];\n}\n","import { GeoJSON } from 'leaflet';\nimport { boundsToArray } from './boundsToArray';\n\nimport type {\n  Feature,\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeoJsonGeometryTypes,\n} from 'geojson';\nimport type { LatLngBounds } from 'leaflet';\nimport type { LayerPosition, VectorAdapterLayerType } from '@nextgis/webmap';\nimport type { LngLatArray, LngLatBoundsArray } from '@nextgis/utils';\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'point',\n  LineString: 'line',\n  MultiPoint: 'point',\n  Polygon: 'polygon',\n  MultiLineString: 'line',\n  MultiPolygon: 'polygon',\n  GeometryCollection: 'polygon',\n};\n\nexport const PAINT = {\n  stroke: false,\n  opacity: 1,\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType,\n): boolean {\n  const geoJsonGeometry = backAliases[type] || [];\n  return geoJsonGeometry.indexOf(geometry) !== -1;\n}\n\nexport function filterGeometries(\n  data: GeoJsonObject,\n  type: VectorAdapterLayerType,\n): GeoJsonObject | false {\n  if (data.type === 'FeatureCollection') {\n    const _data = data as FeatureCollection;\n    _data.features = _data.features.filter((f) =>\n      geometryFilter(f.geometry.type, type),\n    );\n  } else if (data.type === 'Feature') {\n    const allow = geometryFilter((data as Feature).geometry.type, type);\n    if (!allow) {\n      return false;\n    }\n  } else if (data.type === 'GeometryCollection') {\n    const _data = data as GeometryCollection;\n    _data.geometries = _data.geometries.filter((g) =>\n      geometryFilter(g.type, type),\n    );\n  }\n  return data;\n}\n\nfunction featuresBounds(features: Feature | Feature[]): LatLngBounds {\n  const geoJsonLayer = new GeoJSON();\n  const features_ = Array.isArray(features) ? features : [features];\n  features_.forEach((f) => geoJsonLayer.addData(f));\n  return geoJsonLayer.getBounds();\n}\n\nexport function getFeaturesBounds(\n  features: Feature | Feature[],\n): LngLatBoundsArray {\n  return boundsToArray(featuresBounds(features));\n}\n\nexport function getFeaturesCenter(features: Feature | Feature[]): LngLatArray {\n  const { lat, lng } = featuresBounds(features).getCenter();\n  return [lng, lat];\n}\n\nexport function createFeaturePositionOptions(\n  features: Feature | Feature[],\n): LayerPosition {\n  return {\n    getBounds: () => getFeaturesBounds(features),\n    getCenter: () => getFeaturesCenter(features),\n  };\n}\n","import type {\n  GeoJsonObject,\n  GeoJsonGeometryTypes,\n  FeatureCollection,\n  Feature,\n  GeometryCollection,\n} from 'geojson';\n\nfunction findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[],\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type,\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type,\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n","import { MainLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { Map } from 'leaflet';\n\nexport class BaseAdapter<O extends AdapterOptions = AdapterOptions, L = any>\n  implements MainLayerAdapter<Map, L, O>\n{\n  layer?: L;\n  protected pane = 'order-0';\n\n  constructor(public map: L.Map, public options: O) {\n    if (options.order !== undefined) {\n      const pane = 'order-' + options.order;\n      let exist = map.getPane(pane);\n      if (!exist) {\n        exist = map.createPane(pane);\n      }\n      exist.style.zIndex = String(Math.round(options.order * 100));\n      this.pane = pane;\n    }\n  }\n\n  addLayer(options: O): L | Promise<L> | undefined {\n    Object.assign(this.options, options);\n    return undefined;\n  }\n}\n","import {\n  CircleMarker,\n  FeatureGroup,\n  DomEvent,\n  GeoJSON,\n  DivIcon,\n  Marker,\n  Layer,\n} from 'leaflet';\nimport { debounce, defined } from '@nextgis/utils';\n\nimport { isPaintCallback, isPaint } from '@nextgis/paint';\nimport {\n  PAINT,\n  typeAlias,\n  filterGeometries,\n  createFeaturePositionOptions,\n} from '../utils/geometries';\nimport { createMouseEvent } from '../utils/createMouseEvent';\nimport { boundsToArray } from '../utils/boundsToArray';\nimport { detectType } from '../utils/detectType';\nimport { BaseAdapter } from './BaseAdapter';\n\nimport type { GeoJsonObject, Feature, Point } from 'geojson';\nimport type {\n  PopupOptions as LPopupOptions,\n  CircleMarkerOptions,\n  LeafletMouseEvent,\n  LatLngExpression,\n  GeoJSONOptions,\n  LeafletEvent,\n  PathOptions,\n  LatLng,\n  Path,\n  Map,\n} from 'leaflet';\nimport type {\n  Paint,\n  IconPaint,\n  PathPaint,\n  VectorAdapterLayerPaint,\n} from '@nextgis/paint';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type {\n  VectorAdapterLayerType,\n  GeoJsonAdapterOptions,\n  PopupOnCloseFunction,\n  OnLayerMouseOptions,\n  VectorLayerAdapter,\n  OnLayerSelectType,\n  LayerDefinition,\n  DataLayerFilter,\n  PopupOptions,\n} from '@nextgis/webmap';\n\nexport type LayerDef = LayerDefinition<Feature, Layer>;\n\nexport class GeoJsonAdapter\n  extends BaseAdapter<GeoJsonAdapterOptions>\n  implements VectorLayerAdapter<Map>\n{\n  layer?: FeatureGroup;\n  selected = false;\n\n  private paint?: Paint;\n  private selectedPaint?: Paint;\n  private type?: VectorAdapterLayerType;\n\n  private _layers: LayerDef[] = [];\n  private _selectedLayers: LayerDef[] = [];\n  private _filteredLayers: LayerDef[] = [];\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _openedPopup: [Layer, PopupOnCloseFunction[], LayerDef][] = [];\n\n  private $updateTooltip = debounce(() => {\n    this.updateTooltip();\n  }, 300);\n\n  constructor(map: L.Map, options: GeoJsonAdapterOptions) {\n    super(map, options);\n  }\n\n  addLayer(options: GeoJsonAdapterOptions): FeatureGroup<any> | undefined {\n    Object.assign(this.options, options);\n    this.paint = options.paint;\n    this.layer = new FeatureGroup([], {\n      ...options.nativeOptions,\n      pane: this.pane,\n    });\n    this.selectedPaint = options.selectedPaint;\n    options.paint = this.paint;\n\n    if (options.data) {\n      this.addData(options.data);\n    }\n\n    this._addMapListener();\n\n    return this.layer;\n  }\n\n  beforeRemove(): void {\n    this._removeMapListener();\n  }\n\n  select(findFeatureFun?: DataLayerFilter): void {\n    if (findFeatureFun) {\n      const def = this._layers.filter(findFeatureFun);\n      def.forEach((x) => {\n        this._selectLayer(x, 'api');\n      });\n    } else if (!this.selected) {\n      this.selected = true;\n      if (this.selectedPaint) {\n        this._setPaintEachLayer(this.selectedPaint);\n      }\n    }\n  }\n\n  unselect(findFeatureFun?: DataLayerFilter): void {\n    if (findFeatureFun) {\n      const feature = this._layers.filter(findFeatureFun);\n      feature.forEach((x) => {\n        this._unSelectLayer(x);\n      });\n    } else if (this.selected) {\n      for (const p of this._openedPopup) {\n        this._removePopup(p[0]);\n      }\n      if (this.paint) {\n        this._setPaintEachLayer(this.paint);\n      }\n      this._selectedLayers.length = 0;\n      this.selected = false;\n    }\n  }\n\n  getSelected(): LayerDefinition<Feature, LayerDef>[] {\n    return this._selectedLayers.map((x) => {\n      return {\n        target: this,\n        feature: x.feature,\n        layer: x,\n        ...createFeaturePositionOptions(x.feature),\n      };\n    });\n  }\n\n  getFiltered(): LayerDef[] {\n    return this._filteredLayers;\n  }\n\n  filter(fun?: DataLayerFilter): LayerDef[] {\n    // Some optimization\n    this._filterFun = fun;\n    const layer_ = this.layer;\n    const map = layer_ && (layer_ as any)._map;\n    if (layer_ && map) {\n      layer_.remove();\n\n      const filteredLayers: LayerDef[] = [];\n      this._layers.forEach(({ feature, layer }) => {\n        if (layer) {\n          const ok = fun\n            ? fun({\n                target: this,\n                feature,\n                layer,\n                ...createFeaturePositionOptions(feature),\n              })\n            : true;\n          if (ok) {\n            layer_.addLayer(layer);\n            filteredLayers.push({\n              target: this,\n              feature,\n              layer,\n              ...createFeaturePositionOptions(feature),\n            });\n          } else {\n            layer_.removeLayer(layer);\n          }\n        }\n      });\n      this._filteredLayers = filteredLayers;\n\n      layer_.addTo(map);\n    }\n    return this._filteredLayers;\n  }\n\n  cleanFilter(): void {\n    this.filter();\n  }\n\n  getLayers(): LayerDef[] {\n    return this._layers.map(({ layer, feature }) => {\n      const visible = layer && !!(layer as any)._map;\n      return {\n        feature,\n        layer,\n        visible,\n        target: this,\n        ...createFeaturePositionOptions(feature),\n      };\n    });\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean): void {\n    this.unselect();\n    const layer_ = this.layer;\n    if (layer_) {\n      if (cb) {\n        for (let fry = this._layers.length; fry--; ) {\n          const def = this._layers[fry];\n          if (def) {\n            const { feature, layer } = def;\n            if (feature && layer) {\n              const exist = cb(feature);\n              if (exist) {\n                layer_.removeLayer(layer);\n                this._layers.splice(fry, 1);\n              }\n            }\n          }\n        }\n      } else {\n        layer_.clearLayers();\n        this._layers = [];\n      }\n    }\n  }\n\n  setData(data: GeoJsonObject): void {\n    this.clearLayer();\n    this.addData(data);\n  }\n\n  addData(data: GeoJsonObject | false): void {\n    const options = this.options;\n    let geoJsonOptions: GeoJSONOptions | undefined;\n    if (options) {\n      if (data) {\n        let type: VectorAdapterLayerType;\n\n        if (!options.type) {\n          const detectedType = detectType(data);\n          type = typeAlias[detectedType];\n        } else {\n          type = options.type;\n        }\n        if (this.type && this.type !== type) {\n          console.warn('no other data type than layer can be added');\n          return;\n        }\n        this.type = type;\n\n        data = filterGeometries(data, type);\n        if (data) {\n          geoJsonOptions = this._getGeoJsonOptions(options, type);\n        }\n      }\n      new GeoJSON(data || undefined, geoJsonOptions);\n    }\n  }\n\n  openPopup(findFeatureFun: DataLayerFilter, options?: PopupOptions): void {\n    if (findFeatureFun) {\n      const def = this._layers.filter(findFeatureFun);\n      def.forEach((x) => {\n        this._openPopup(x, options, 'api');\n      });\n    }\n  }\n\n  closePopup(findFeatureFun?: DataLayerFilter): void {\n    const popupToClose = findFeatureFun\n      ? this._openedPopup.filter((x) => findFeatureFun(x[2]))\n      : this._openedPopup;\n\n    popupToClose.forEach((x) => {\n      this._removePopup(x[0]);\n    });\n  }\n\n  updateTooltip(layerDef?: LayerDefinition): void {\n    if (layerDef) {\n      this._updateTooltip(layerDef);\n    } else {\n      this.getLayers().forEach((x) =>\n        this._updateTooltip({ feature: x.feature, layer: x.layer }),\n      );\n    }\n  }\n\n  /** @deprecated use {@link GeoJsonAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.layer) {\n      const bounds = this.layer.getBounds();\n      if (bounds.isValid()) {\n        return boundsToArray(bounds);\n      }\n    }\n  }\n\n  setOpacity(value: number): void {\n    this.options.opacity = value;\n    this.setPaint(this.paint);\n    this.setSelectedPaint(this.selectedPaint);\n  }\n\n  setPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.paint = paint;\n      for (const l of this._layers) {\n        this._setPaint(l, paint);\n      }\n    }\n  }\n  setSelectedPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.selectedPaint = paint;\n      for (const l of this._selectedLayers) {\n        this._setPaint(l, paint);\n      }\n    }\n  }\n  updatePaint(paint: Partial<Paint>): void {\n    this.paint = { ...this.paint, ...paint } as Paint;\n    for (const l of this._layers) {\n      this._setPaint(l, this.paint);\n    }\n  }\n  updateSelectedPaint(paint: Partial<Paint>): void {\n    this.selectedPaint = { ...this.selectedPaint, ...paint } as Paint;\n    for (const l of this._selectedLayers) {\n      this._setPaint(l, this.selectedPaint);\n    }\n  }\n\n  private $unselect = () => {\n    this.unselect();\n  };\n\n  private _updateTooltip(layerDef: Pick<LayerDef, 'feature' | 'layer'>) {\n    const { feature, layer } = layerDef;\n    if (feature && layer && feature.properties && this.options.labelField) {\n      layer.unbindTooltip();\n      const message = feature.properties[this.options.labelField];\n      if (message !== undefined) {\n        const permanent = !this.options.labelOnHover;\n\n        layer.bindTooltip(String(message), { permanent, sticky: false });\n      }\n    }\n  }\n\n  private async _openPopup(\n    def: LayerDef,\n    options: PopupOptions = {},\n    type: OnLayerSelectType,\n    latLng?: LatLngExpression,\n  ) {\n    const { feature, layer } = def;\n    const {\n      minWidth,\n      autoPan,\n      maxWidth,\n      closeButton: closeButton_,\n    } = { minWidth: 300, ...options };\n    const closeButton = closeButton_ ?? !this.options.selectOnHover;\n    let popup: Layer;\n    const _closeHandlers: PopupOnCloseFunction[] = [];\n    const onClose = (handler: PopupOnCloseFunction) => {\n      _closeHandlers.push(handler);\n    };\n    const close = () => {\n      if (popup) {\n        this._removePopup(popup);\n      }\n    };\n    let content;\n    if (options.createPopupContent) {\n      content = await options.createPopupContent({\n        layer,\n        feature,\n        target: this,\n        type,\n        close,\n        onClose,\n        ...createFeaturePositionOptions(feature),\n      });\n    } else {\n      content = options.popupContent;\n    }\n\n    if (content && layer) {\n      const popupOptions: LPopupOptions = {\n        minWidth,\n        autoPan,\n        // maxWidth,\n        closeButton,\n        closeOnClick: false,\n        autoClose: false,\n      };\n      if (defined(maxWidth)) {\n        popupOptions.maxWidth = maxWidth;\n      }\n      popup = layer.bindPopup(content, popupOptions);\n\n      const unselectOnClose =\n        this.options.popupOptions?.unselectOnClose ?? true;\n      if (unselectOnClose) {\n        const p = layer.getPopup();\n        p &&\n          p.once(\n            'remove',\n            () => {\n              close();\n            },\n            this,\n          );\n      }\n      this._openedPopup.push([popup, _closeHandlers, def]);\n      popup.openPopup(latLng);\n    }\n  }\n\n  private _removePopup(popup: Layer) {\n    const map = this.map;\n    if (map) {\n      popup.closePopup().unbindPopup();\n      const index = this._openedPopup.findIndex((x) => x[0] === popup);\n      if (index !== -1) {\n        const unselectOnClose =\n          this.options.popupOptions?.unselectOnClose ?? true;\n        const [, closeHandlers, def] = this._openedPopup[index];\n        for (const h of closeHandlers) {\n          h(def);\n        }\n        closeHandlers.length = 0;\n        if (unselectOnClose) {\n          this._unSelectLayer(def);\n        }\n        this._openedPopup.splice(index, 1);\n      }\n    }\n  }\n\n  private _setPaintEachLayer(paint: Paint) {\n    this._layers.forEach((l) => {\n      this._setPaint(l, paint);\n    });\n  }\n\n  private _setPaint(def: LayerDef, paint: Paint) {\n    let style: VectorAdapterLayerPaint | undefined = undefined;\n    const { layer, feature } = def;\n    if (layer && feature) {\n      if (isPaintCallback(paint)) {\n        style = paint(feature);\n      } else if (isPaint(paint)) {\n        style = paint;\n      }\n      if (style) {\n        if (this.type === 'point' && style.type === 'icon') {\n          const marker = layer as Marker;\n          const divIcon = this._createDivIcon(style);\n          marker.setIcon(divIcon);\n        } else if ('setStyle' in layer) {\n          (layer as Path).setStyle(this._preparePaint(style));\n        }\n      }\n    }\n  }\n\n  private _preparePaint(paint: VectorAdapterLayerPaint): PathOptions {\n    if (paint.type !== 'get-paint') {\n      // const path: CircleMarkerOptions | PathOptions = paint as CircleMarkerOptions | PathOptions;\n      // if (path.opacity) {\n      //   path.fillOpacity = path.opacity;\n      // }\n\n      const paintAliases: [keyof PathOptions, keyof PathPaint][] = [\n        // ['color', 'color'],\n        ['color', 'strokeColor'],\n        ['opacity', 'strokeOpacity'],\n        ['stroke', 'stroke'],\n        ['fillColor', 'fillColor'],\n        ['fillOpacity', 'fillOpacity'],\n        ['fill', 'fill'],\n        ['weight', 'weight'],\n      ];\n      const aliases: [keyof PathOptions, keyof PathPaint][] =\n        this.type === 'line'\n          ? [\n              ['color', 'strokeColor'],\n              ['opacity', 'strokeOpacity'],\n              ['weight', 'weight'],\n            ]\n          : paintAliases;\n\n      const readyPaint: PathOptions & CircleMarkerOptions = {};\n\n      if ('radius' in paint && typeof paint.radius === 'number') {\n        readyPaint.radius = paint.radius;\n      }\n      for (const [to, from] of aliases) {\n        let paintProp = (paint as PathPaint)[from];\n        if (\n          defined(this.options.opacity) &&\n          from.toLowerCase().indexOf('opacity') !== -1\n        ) {\n          paintProp = Number(paintProp) * this.options.opacity;\n        }\n\n        if (paintProp !== undefined) {\n          Object.defineProperty(readyPaint, to, {\n            enumerable: true,\n            value: paintProp,\n          });\n        }\n      }\n\n      return readyPaint;\n    }\n    return PAINT;\n  }\n\n  private _getGeoJsonOptions(\n    options: GeoJsonAdapterOptions,\n    type: VectorAdapterLayerType,\n  ): GeoJSONOptions {\n    const paint = options.paint;\n    let lopt: GeoJSONOptions = {};\n\n    if (typeof paint === 'function') {\n      if (type === 'point') {\n        // TODO: fix types (@geoman-io/leaflet-geoman-free)\n        (lopt as any).pointToLayer = (\n          feature: Feature<Point, any>,\n          latLng: LatLng,\n        ) => {\n          const iconOpt = paint(feature);\n          const pointToLayer = this._createPaintToLayer(iconOpt as IconPaint);\n          return pointToLayer(feature, latLng);\n        };\n      } else {\n        lopt = {\n          style: (feature) => {\n            if (feature) {\n              return this._preparePaint({ ...PAINT, ...paint(feature) });\n            } else {\n              return this._preparePaint({ ...PAINT, type: 'path' });\n            }\n          },\n        };\n      }\n    } else {\n      lopt = this._createPaintOptions(paint as VectorAdapterLayerPaint, type);\n    }\n\n    lopt.onEachFeature = (feature: Feature, layer) => {\n      this._onEachFeature(feature, layer);\n    };\n\n    return lopt;\n  }\n\n  private _onEachFeature(feature: Feature, layer: Layer) {\n    const layer_ = this.layer;\n    if (layer_) {\n      const def = {\n        target: this,\n        feature,\n        layer,\n        ...createFeaturePositionOptions(feature),\n      };\n\n      // @ts-ignore\n      layer.options.pane = this.pane;\n      this._layers.push(def);\n      let ok = true;\n      if (this._filterFun) {\n        ok = this._filterFun(def);\n      }\n      if (ok) {\n        const { popup, popupOptions, selectable, interactive, selectOnHover } =\n          this.options;\n        // @ts-ignore\n        layer.options.interactive = defined(interactive) ? interactive : true;\n        layer_.addLayer(layer);\n        if (selectable) {\n          if (selectOnHover) {\n            layer.on('mouseover', () => {\n              this._selectLayer(def, 'hover');\n            });\n            layer.on('mouseout', () => {\n              this._unSelectLayer(def);\n            });\n          } else {\n            layer.on(\n              'click',\n              (e) => this._selectOnLayerClick(e as LeafletMouseEvent),\n              this,\n            );\n          }\n        }\n        this._handleMouseEvents(layer);\n        // The timeout is needed to display the popup immediately when adding a layer to the map.\n        // Without a timeout, the layer may not yet have a _map object\n        setTimeout(() => {\n          if (popup) {\n            this._openPopup(\n              {\n                target: this,\n                layer,\n                feature,\n                ...createFeaturePositionOptions(feature),\n              },\n              popupOptions,\n              'api',\n            );\n          }\n          this._updateTooltip({ layer, feature });\n        });\n      }\n    }\n  }\n\n  private _handleMouseEvents(layer: Layer) {\n    const isSelected = (l: LayerDef) => this._selectedLayers.indexOf(l) !== -1;\n\n    const { onClick, onLayerClick, onMouseOut, onMouseOver } = this.options;\n    // TODO: remove backward compatibility for onLayerClick\n    const onClick_ = onClick || onLayerClick;\n    if (onClick_) {\n      layer.on(\n        'click',\n        (e) => {\n          onClick_({\n            selected: isSelected(e.target),\n            ...this._createMouseEvent(e),\n          });\n        },\n        this,\n      );\n    }\n    if (onMouseOut) {\n      layer.on(\n        'mouseout',\n        (e) => {\n          onMouseOut(this._createMouseEvent(e));\n        },\n        this,\n      );\n    }\n    if (onMouseOver) {\n      layer.on(\n        'mouseover',\n        (e) => {\n          onMouseOver(this._createMouseEvent(e));\n        },\n        this,\n      );\n    }\n  }\n\n  private _createMouseEvent(source: LeafletEvent): OnLayerMouseOptions {\n    return createMouseEvent({\n      layer: this,\n      source: source as LeafletMouseEvent,\n    });\n  }\n\n  private _selectOnLayerClick(e: LeafletMouseEvent) {\n    DomEvent.stopPropagation(e);\n    const layer = e.target as Layer;\n    const feature = (layer as any).feature;\n    const def: LayerDef = {\n      target: this,\n      layer,\n      feature,\n      ...createFeaturePositionOptions(feature),\n    };\n    const isSelected = this._selectedLayers.find((x) => x.layer === layer);\n    if (isSelected) {\n      if (this.options && this.options.unselectOnSecondClick) {\n        this._unSelectLayer(isSelected);\n      }\n    } else {\n      this._selectLayer(def, 'click', e.latlng);\n    }\n  }\n\n  private _selectLayer(\n    def: LayerDef,\n    type: OnLayerSelectType,\n    latlng?: LatLngExpression,\n  ) {\n    this.map._addUnselectCb(() => {\n      this._unSelectLayer(def);\n    });\n    if (this.options && !this.options.multiselect) {\n      this._selectedLayers.forEach((x) => this._unSelectLayer(x));\n    }\n    this._selectedLayers.push(def);\n    this.selected = true;\n    const { selectedPaint, popupOnSelect, popupOptions } = this.options;\n\n    if (selectedPaint && def.layer) {\n      this._setPaint(def, selectedPaint);\n    }\n    if (popupOnSelect) {\n      this._openPopup(def, popupOptions, type, latlng);\n    }\n    if (this.options.onSelect) {\n      const features = def.feature ? [def.feature] : [];\n      this.options.onSelect({\n        type,\n        layer: this,\n        features,\n        ...createFeaturePositionOptions(features),\n      });\n    }\n  }\n\n  private _unSelectLayer(def: LayerDef) {\n    const index = this._selectedLayers.indexOf(def);\n    if (index !== -1) {\n      this._selectedLayers.splice(index, 1);\n      if (this.options) {\n        if (this.options.paint) {\n          this._setPaint(def, this.options.paint);\n        }\n\n        if (this.options.popupOnSelect && def.layer) {\n          this._removePopup(def.layer);\n        }\n      }\n    }\n    this.selected = this._selectedLayers.length > 0;\n  }\n\n  private _createDivIcon(icon: IconPaint) {\n    const { ...toLIconOpt } = icon;\n    return new DivIcon({ className: '', ...toLIconOpt });\n  }\n\n  private _createPaintToLayer(icon: IconPaint) {\n    if (icon && icon.type) {\n      if (icon.type === 'icon') {\n        const iconClassName = icon.className;\n        const html = icon.html;\n        if (iconClassName || html) {\n          return (geoJsonPoint: any, latlng: LatLngExpression) => {\n            const divIcon = this._createDivIcon(icon);\n            return new Marker(latlng, { icon: divIcon });\n          };\n        }\n      } else if (icon.type === 'pin') {\n        return (geoJsonPoint: any, latlng: LatLngExpression) => {\n          // const divIcon = this.createDivIcon(icon);\n          return new Marker(latlng);\n        };\n      }\n    }\n    return (geoJsonPoint: any, latlng: LatLngExpression) => {\n      const p: any = PAINT;\n      return new CircleMarker(latlng, this._preparePaint({ ...p, ...icon }));\n    };\n  }\n\n  private _createPaintOptions(\n    paintOptions: VectorAdapterLayerPaint,\n    type: VectorAdapterLayerType,\n  ): GeoJSONOptions {\n    const geoJsonOptions: GeoJSONOptions = {};\n    const paint = (paintOptions && this._preparePaint(paintOptions)) || {};\n    if (paintOptions) {\n      geoJsonOptions.style = () => {\n        return paint;\n      };\n    }\n    if (type === 'point') {\n      (geoJsonOptions as any).pointToLayer = this._createPaintToLayer(\n        paintOptions as IconPaint,\n      );\n    } else if (type === 'line') {\n      paint.stroke = true;\n    }\n    return geoJsonOptions;\n  }\n\n  private _addMapListener() {\n    const map = this.map;\n    if (map) {\n      const { labelField, labelOnHover, unselectOnClick } = this.options;\n      const uoc = unselectOnClick ?? true;\n      if (uoc) {\n        map.on('click', this.$unselect);\n      }\n      if (labelField && !labelOnHover) {\n        map.on('zoomend', this.$updateTooltip);\n        map.on('moveend', this.$updateTooltip);\n      }\n    }\n  }\n\n  private _removeMapListener() {\n    this.map.off('zoomend', this.$updateTooltip);\n    this.map.off('moveend', this.$updateTooltip);\n    this.map.off('click', this.$unselect);\n  }\n}\n","import { convertMapClickEvent } from './convertMapClickEvent';\nimport { createFeaturePositionOptions } from './geometries';\n\nimport type { LeafletMouseEvent } from 'leaflet';\nimport type { LayerAdapter, OnLayerMouseOptions } from '@nextgis/webmap';\nimport type { LayerDef } from '../layer-adapters/GeoJsonAdapter';\n\nexport interface CreateMouseEventOptions {\n  layer: LayerAdapter;\n  source: LeafletMouseEvent;\n}\n\nexport function createMouseEvent({\n  layer,\n  source,\n}: CreateMouseEventOptions): OnLayerMouseOptions {\n  const layer_ = source.target as LayerDef;\n  const feature = layer_.feature;\n  const opt: OnLayerMouseOptions = {\n    layer,\n    feature,\n    event: convertMapClickEvent(source),\n    source,\n    ...createFeaturePositionOptions(feature),\n  };\n  return opt;\n}\n","export function callAjax(\n  src: string,\n  callback: (resp: any) => any,\n  headers: Record<string, any>,\n): () => void {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', src);\n  xhr.responseType = 'arraybuffer';\n  for (const h in headers) {\n    xhr.setRequestHeader(h, headers[h]);\n  }\n  xhr.onload = function () {\n    const arrayBufferView = new Uint8Array(this.response);\n    const blob = new Blob([arrayBufferView], { type: 'image/png' });\n    // @ts-ignore for typedoc\n    const urlCreator = window.URL || window.webkitURL;\n    const imageUrl = urlCreator.createObjectURL(blob);\n    callback(imageUrl);\n  };\n  xhr.send();\n  return () => {\n    xhr.abort();\n  };\n}\n","import {\n  ImageOverlay as LImageOverlay,\n  LatLngBoundsExpression,\n  ImageOverlayOptions,\n} from 'leaflet';\nimport { callAjax } from '../../utils/callAjax';\n\ntype IOptions = ImageOverlayOptions & { headers?: any };\n\nexport class ImageOverlay extends LImageOverlay {\n  private _abort: (() => void)[] = [];\n\n  constructor(\n    imageUrl: string,\n    bounds: LatLngBoundsExpression,\n    options?: IOptions,\n  ) {\n    super(imageUrl, bounds, options);\n  }\n\n  cancelLoad(): void {\n    if (this._abort) {\n      this._abort.forEach((x) => x());\n      this._abort = [];\n    }\n  }\n\n  _initImage(): void {\n    // @ts-ignore\n    super._initImage();\n    // @ts-ignore\n    const headers = this.options.headers;\n    if (headers) {\n      // @ts-ignore\n      const img: HTMLImageElement = this._image;\n      const src = img.src;\n      img.src = '';\n      this._abort.push(\n        callAjax(\n          src,\n          (response) => {\n            img.src = response;\n          },\n          headers,\n        ),\n      );\n    }\n  }\n}\n","/*!\n * leaflet.wms.js\n * A collection of Leaflet utilities for working with Web Mapping services.\n * (c) 2014-2016, Houston Engineering, Inc.\n * MIT License\n */\n\nimport { Layer, Util, CRS } from 'leaflet';\nimport { debounce } from '@nextgis/utils';\nimport { ImageOverlay } from './ImageOverlay';\n\ninterface OverlayOptions {\n  crs?: null;\n  uppercase?: boolean;\n  attribution?: string;\n  opacity?: number;\n  isBack?: boolean;\n  minZoom?: number;\n  maxZoom?: number;\n  zIndex?: number;\n  pane?: string;\n  headers?: any;\n  viewPortBuffer?: number;\n  setViewDelay?: number;\n}\n\n/*\n * Overlay:\n * \"Single Tile\" WMS image overlay that updates with map changes.\n * Portions of wms.Overlay are directly extracted from L.TileLayer.WMS.\n * See Leaflet license.\n */\nexport class ImageLayer extends Layer {\n  defaultWmsParams = {\n    service: 'WMS',\n    request: 'GetMap',\n    version: '1.1.1',\n    layers: '',\n    styles: '',\n    format: 'image/jpeg',\n    transparent: false,\n  };\n\n  options: OverlayOptions = {\n    crs: null,\n    uppercase: false,\n    attribution: '',\n    opacity: 1,\n    isBack: false,\n    minZoom: 0,\n    maxZoom: 18,\n    pane: 'tilePane',\n    headers: null,\n    viewPortBuffer: 0,\n    setViewDelay: 100,\n  };\n\n  private wmsParams: any;\n  private _url?: string;\n  private _currentUrl?: string;\n  private _currentOverlay?: ImageOverlay;\n\n  constructor(url: string, options: OverlayOptions) {\n    super(options);\n    this._url = url;\n\n    // Move WMS parameters to params object\n    const params: any = {};\n    const opts: any = {};\n    let opt: keyof OverlayOptions;\n    for (opt in options) {\n      if (opt in this.options) {\n        opts[opt] = options[opt];\n      } else {\n        params[opt] = options[opt];\n      }\n    }\n    Util.setOptions(this, opts);\n    this.wmsParams = Util.extend({}, this.defaultWmsParams, params);\n  }\n\n  setParams(params: Record<string, any>): void {\n    Util.extend(this.wmsParams, params);\n    this.update();\n  }\n\n  getAttribution(): string {\n    return this.options.attribution || '';\n  }\n\n  onAdd(): this {\n    this.update();\n    return this;\n  }\n\n  onRemove(map: L.Map): this {\n    if (this._currentOverlay) {\n      this._currentOverlay.cancelLoad();\n      map.removeLayer(this._currentOverlay);\n      delete this._currentOverlay;\n    }\n    if (this._currentUrl) {\n      delete this._currentUrl;\n    }\n    return this;\n  }\n\n  getEvents(): {\n    moveend: () => void;\n  } {\n    return {\n      moveend: debounce(this.update, this.options.setViewDelay),\n    };\n  }\n\n  update(): void {\n    if (!this._map) {\n      return;\n    }\n    // Determine image URL and whether it has changed since last update\n    this.updateWmsParams();\n    const url = this.getImageUrl();\n    if (this._currentUrl === url) {\n      return;\n    }\n    this._currentUrl = url;\n\n    // Keep current image overlay in place until new one loads\n    // (inspired by esri.leaflet)\n    const viewPortBuffer = this.options.viewPortBuffer || 0;\n    const bounds = this._map.getBounds().pad(viewPortBuffer);\n\n    const overlay = new ImageOverlay(url, bounds, {\n      opacity: 0,\n      pane: this.options.pane,\n      headers: this.options.headers,\n    });\n    overlay.addTo(this._map);\n    if (this._currentOverlay) {\n      this._currentOverlay.cancelLoad();\n    }\n    overlay.once(\n      'load',\n      () => {\n        if (!this._map) {\n          return;\n        }\n        // @ts-ignore\n        if (overlay._url !== this._currentUrl) {\n          this._map.removeLayer(overlay);\n          return;\n        } else if (this._currentOverlay) {\n          this._map.removeLayer(this._currentOverlay);\n        }\n        this._currentOverlay = overlay;\n        overlay.setOpacity(\n          this.options.opacity !== undefined ? this.options.opacity : 1,\n        );\n        if (this.options.isBack === true) {\n          overlay.bringToBack();\n        }\n        if (this.options.isBack === false) {\n          overlay.bringToFront();\n        }\n        if (this.options.zIndex !== undefined) {\n          overlay.setZIndex(this.options.zIndex);\n        }\n      },\n      this,\n    );\n    const { minZoom, maxZoom } = this.options;\n    if (\n      (minZoom && this._map.getZoom() < minZoom) ||\n      (maxZoom && this._map.getZoom() > maxZoom)\n    ) {\n      this._map.removeLayer(overlay);\n    }\n  }\n\n  setOpacity(opacity: number): void {\n    this.options.opacity = opacity;\n    if (this._currentOverlay) {\n      this._currentOverlay.setOpacity(opacity);\n    }\n  }\n\n  bringToBack(): void {\n    this.options.isBack = true;\n    if (this._currentOverlay) {\n      this._currentOverlay.bringToBack();\n    }\n  }\n\n  bringToFront(): void {\n    this.options.isBack = false;\n    if (this._currentOverlay) {\n      this._currentOverlay.bringToFront();\n    }\n  }\n\n  setZIndex(zIndex: number): void {\n    this.options.zIndex = zIndex;\n    if (this._currentOverlay) {\n      this._currentOverlay.setZIndex(zIndex);\n    }\n  }\n\n  // See L.TileLayer.WMS: onAdd() & getTileUrl()\n  updateWmsParams(map?: L.Map): void {\n    if (!map) {\n      map = this._map;\n    }\n    // Compute WMS options\n    const viewPortBuffer = this.options.viewPortBuffer || 0;\n    const bounds = map.getBounds().pad(viewPortBuffer);\n    const size = map.getSize();\n    if (this.options.viewPortBuffer !== 0) {\n      const factor = viewPortBuffer + 1;\n      size.x = Math.ceil(size.x * factor);\n      size.y = Math.ceil(size.y * factor);\n    }\n    const wmsVersion = parseFloat(this.wmsParams.version);\n    const crs = this.options.crs || map.options.crs;\n    const projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';\n    if (crs) {\n      const nw = crs.project(bounds.getNorthWest());\n      const se = crs.project(bounds.getSouthEast());\n\n      // Assemble WMS parameter string\n      const params: any = {\n        width: size.x,\n        height: size.y,\n      };\n      params[projectionKey] = crs.code;\n      params.bbox = (\n        wmsVersion >= 1.3 && crs === CRS.EPSG4326\n          ? [se.y, nw.x, nw.y, se.x]\n          : [nw.x, se.y, se.x, nw.y]\n      ).join(',');\n\n      Util.extend(this.wmsParams, params);\n    }\n  }\n\n  getImageUrl(): string {\n    const uppercase = this.options.uppercase || false;\n    const pstr = Util.getParamString(this.wmsParams, this._url, uppercase);\n    return this._url + pstr;\n  }\n}\n","import { MainLayerAdapter } from '@nextgis/webmap';\nimport { ImageLayer } from './ImageLayer';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport type { Map } from 'leaflet';\nimport type { ImageAdapterOptions } from '@nextgis/webmap';\n\nexport class ImageAdapter\n  extends BaseAdapter<ImageAdapterOptions>\n  implements MainLayerAdapter<Map>\n{\n  layer: any;\n\n  addLayer(options: ImageAdapterOptions): any {\n    const url = options && options.url;\n    if (url) {\n      options = { transparent: true, ...options };\n      const updateWmsParamsFromOpt = options.updateWmsParams;\n      this.layer = new ImageLayer(url, {\n        pane: this.pane,\n        headers: options.headers,\n        setViewDelay: options.setViewDelay,\n        /**\n         * TODO: safe remove, use only options.nativeOptions\n         */\n        ...options,\n        ...options.params,\n        ...options.nativeOptions,\n      });\n      if (updateWmsParamsFromOpt) {\n        const updateWmsParams = this.layer.updateWmsParams;\n        this.layer.updateWmsParams = function (map: Map) {\n          updateWmsParams.call(this, map);\n          this.wmsParams = updateWmsParamsFromOpt(this.wmsParams);\n        };\n      }\n      return this.layer;\n    }\n  }\n}\n","import { DomUtil, GridLayer, Util } from 'leaflet';\nimport { debounce } from '../../../utils/src';\nimport { callAjax } from './callAjax';\n\n// import type { TileLayerOptionsExtended } from './TileAdapter/TileLayer';\n\ntype Constructor = new (...args: any[]) => any;\n\nexport function makeRemote<\n  TBase extends Constructor,\n  // O extends TileLayerOptionsExtended = TileLayerOptionsExtended\n>(Base: TBase): TBase {\n  return class RemoteTileLayer extends Base {\n    constructor(...args: any[]) {\n      super(...args);\n      if (this.options.setViewDelay) {\n        // @ts-ignore\n        this._update = debounce((...a: any[]) => {\n          // @ts-ignore\n          GridLayer.prototype._update.call(this, ...a);\n        }, this.options.setViewDelay);\n      }\n    }\n\n    createTile(\n      coords: Record<string, unknown>,\n      done: (error: any, tile: HTMLImageElement) => void,\n    ): HTMLImageElement {\n      // @ts-ignore\n      const url = this.getTileUrl(coords);\n\n      const tile = document.createElement('img');\n      (tile as any).abort = callAjax(\n        url,\n        (response) => {\n          tile.src = response;\n          done(null, tile);\n        },\n        // @ts-ignore\n        this.options.headers,\n      );\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin =\n          this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      tile.alt = '';\n      tile.setAttribute('role', 'presentation');\n\n      return tile;\n    }\n\n    _abortLoading() {\n      // @ts-ignore\n      const tiles = this._tiles;\n      // @ts-ignore\n      const tileZoom = this._tileZoom;\n      for (const i in tiles) {\n        if (tiles[i].coords.z !== tileZoom) {\n          const tile = tiles[i].el;\n\n          tile.onload = Util.falseFn;\n          tile.onerror = Util.falseFn;\n          if (!tile.complete) {\n            if (tile.abort) {\n              tile.abort();\n            }\n            tile.src = Util.emptyImageUrl;\n            DomUtil.remove(tile);\n            delete tiles[i];\n          }\n        }\n      }\n    }\n  };\n}\n","import { TileLayer as TL } from 'leaflet';\nimport { makeRemote } from '../../utils/makeRemoteTileLayer';\n\nimport type { TileLayerOptions } from 'leaflet';\n\nexport type TileLayerOptionsExtended = TileLayerOptions & {\n  headers: Record<string, any>;\n  setViewDelay?: number;\n};\n\nclass TileLayerBase extends TL {\n  constructor(urlTemplate: string, options?: TileLayerOptionsExtended) {\n    super(urlTemplate, options);\n    Object.assign(this.options, options);\n  }\n}\n\nexport const TileLayer = makeRemote(TileLayerBase);\n","import { TileLayer } from 'leaflet';\nimport { TileLayer as TL } from './TileLayer';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { TileLayerOptions } from 'leaflet';\n\nexport class TileAdapter\n  extends BaseAdapter<TileAdapterOptions, TileLayer>\n  implements MainLayerAdapter\n{\n  addLayer(options: TileAdapterOptions): TileLayer | undefined {\n    this.options = Object.assign(this.options, options);\n    if (options) {\n      const { url, ...opt } = options;\n      if (url) {\n        const tileLayerOptions: TileLayerOptions = {\n          pane: this.pane,\n          attribution: opt.attribution,\n          minZoom: opt.minZoom,\n          maxZoom: opt.maxZoom,\n\n          ...opt.nativeOptions,\n        };\n        if (opt.subdomains) {\n          tileLayerOptions.subdomains = opt.subdomains;\n        }\n        let layer;\n        if (opt.headers) {\n          layer = new TL(url, {\n            ...tileLayerOptions,\n            headers: opt.headers,\n            setViewDelay: opt.setViewDelay,\n          });\n        } else {\n          layer = new TileLayer(url, tileLayerOptions);\n        }\n        return layer;\n      }\n    }\n  }\n}\n","import { TileLayer } from 'leaflet';\nimport { makeRemote } from '../../utils/makeRemoteTileLayer';\nimport type { WMSOptions } from 'leaflet';\n\ntype LayerOptions = WMSOptions & { headers: any };\n\nclass WmsLayerBase extends TileLayer.WMS {\n  constructor(urlTemplate: string, options: LayerOptions) {\n    super(urlTemplate, options);\n  }\n}\n\nexport const WmsLayer = makeRemote(WmsLayerBase);\n\n// applyMixins(WmsLayer, [RemoteTileLayer]);\n","import { TileLayer } from 'leaflet';\nimport { WmsLayer as WMS } from './WmsLayer';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport type { MainLayerAdapter, WmsAdapterOptions } from '@nextgis/webmap';\nimport type { WMSOptions } from 'leaflet';\n\nexport class WmsAdapter\n  extends BaseAdapter<WmsAdapterOptions, TileLayer.WMS>\n  implements MainLayerAdapter\n{\n  addLayer(options: WmsAdapterOptions): TileLayer.WMS | undefined {\n    Object.assign(this.options, options);\n    const { url, ...opt } = options;\n    if (url) {\n      const layerOptions: WMSOptions = {\n        pane: this.pane,\n        attribution: opt.attribution,\n        minZoom: opt.minZoom,\n        maxZoom: opt.maxZoom,\n        layers: options.layers,\n        format: options.format,\n        ...options.nativeOptions,\n      };\n      let layer;\n      if (opt.headers) {\n        layer = new WMS(url, { ...layerOptions, headers: opt.headers });\n      } else {\n        layer = new TileLayer.WMS(url, layerOptions);\n      }\n      return layer;\n    }\n  }\n}\n","import { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileLayer } from 'leaflet';\n\nimport { TileAdapter } from './TileAdapter/TileAdapter';\n\nexport class OsmAdapter extends TileAdapter implements MainLayerAdapter {\n  addLayer(options: Omit<TileAdapterOptions, 'url'>): TileLayer | undefined {\n    const url = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    return super.addLayer({\n      name: 'OpenStreetMap',\n      attribution:\n        '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n      ...options,\n      url,\n    });\n  }\n}\n","import { EventEmitter } from 'events';\nimport { Map, Control, FitBoundsOptions } from 'leaflet';\nimport { convertMapClickEvent } from './utils/convertMapClickEvent';\nimport { createButtonControl } from './controls/createButtonControl';\nimport { AttributionControl } from './controls/Attribution';\nimport { createControl } from './controls/createControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { ImageAdapter } from './layer-adapters/ImageAdapter/ImageAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter/TileAdapter';\nimport { WmsAdapter } from './layer-adapters/WmsAdapter/WmsAdapter';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\n\nimport type {\n  Layer,\n  GridLayer,\n  ControlPosition,\n  LeafletMouseEvent,\n} from 'leaflet';\nimport type { LngLatBoundsArray, LngLatArray } from '@nextgis/utils';\nimport type {\n  CreateControlOptions,\n  ButtonControlOptions,\n  LocationEvents,\n  LocateOptions,\n  MainMapEvents,\n  LayerAdapter,\n  MapAdapter,\n  MapOptions,\n  FitOptions,\n  MapControl,\n  Locate,\n} from '@nextgis/webmap';\n\nexport type Type<T> = new (...args: any[]) => T;\nexport type UnselectCb = () => void;\nexport type UnselectDef = UnselectCb;\nexport class LeafletMapAdapter implements MapAdapter<Map, any, Control> {\n  static layerAdapters: {\n    [name: string]: Type<LayerAdapter<Map, any, any>>;\n  } = {\n    GEOJSON: GeoJsonAdapter,\n    IMAGE: ImageAdapter,\n    TILE: TileAdapter,\n    WMS: WmsAdapter,\n    // // MVT: MvtAdapter,\n    OSM: OsmAdapter,\n  };\n\n  static controlAdapters = {\n    ZOOM: Control.Zoom,\n    ATTRIBUTION: AttributionControl,\n  };\n\n  static Map = Map;\n\n  options: MapOptions = { target: 'map' };\n\n  layerAdapters = LeafletMapAdapter.layerAdapters;\n  controlAdapters = LeafletMapAdapter.controlAdapters;\n  emitter = new EventEmitter();\n  map?: Map;\n\n  private _unselectCb: UnselectDef[] = [];\n  private _universalEvents: (keyof MainMapEvents)[] = [\n    'move',\n    'zoom',\n    'moveend',\n    'zoomend',\n    'zoomstart',\n    'movestart',\n  ];\n\n  create(options: MapOptions): void {\n    this.options = { ...options };\n    if (this.options.target) {\n      const {\n        zoom,\n        center,\n        maxZoom,\n        minZoom,\n        maxBounds: mb,\n        mapAdapterOptions,\n      } = this.options;\n      this.map = new Map(this.options.target, {\n        attributionControl: false,\n        zoomControl: false,\n        maxBounds: mb && [\n          [mb[1], mb[0]],\n          [mb[3], mb[2]],\n        ],\n        maxZoom,\n        minZoom,\n        center: center && [center[1], center[0]],\n        zoom,\n        ...mapAdapterOptions,\n      });\n      // create default pane\n      const defPane = this.map.createPane('order-0');\n      this.map._addUnselectCb = (def) => {\n        this._addUnselectCb(def);\n      };\n      defPane.style.zIndex = String(0);\n      this.emitter.emit('create', this);\n      this._addMapListeners();\n    }\n  }\n\n  destroy(): void {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this.map && this.map.getContainer();\n  }\n\n  getControlContainer(): HTMLElement {\n    const controlContainer = this.map && (this.map as any)._controlContainer;\n    if (controlContainer) {\n      return controlContainer;\n    }\n    throw new Error('Leaflet Map is not initialized yet');\n  }\n\n  setCursor(cursor: string): void {\n    if (this.map) {\n      this.map.getContainer().style.cursor = cursor;\n    }\n  }\n\n  setView(lngLat: LngLatArray, zoom?: number): void {\n    const [lng, lat] = lngLat;\n    if (this.map) {\n      if (typeof zoom === 'number') {\n        this.map.setView([lat, lng], zoom, { animate: false });\n      } else {\n        this.setCenter([lng, lat]);\n      }\n    }\n  }\n\n  setCenter(lngLat: LngLatArray): void {\n    const [lng, lat] = lngLat;\n    if (this.map) {\n      this.map.panTo([lat, lng]);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    const map = this.map;\n    if (map) {\n      const bounds = map.getBounds();\n      const center = bounds.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom);\n    }\n  }\n\n  getZoom(): number | undefined {\n    return (this.map && this.map.getZoom()) || undefined;\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (!this.map) return undefined;\n    const b = this.map.getBounds();\n    const sw = b.getSouthWest();\n    const ne = b.getNorthEast();\n    return [sw.lng, sw.lat, ne.lng, ne.lat];\n  }\n\n  // [west, south, east, north]\n  fitBounds(e: LngLatBoundsArray, options: FitOptions = {}): void {\n    if (this.map) {\n      const { maxZoom, offset, padding } = options;\n      const opt: FitBoundsOptions = {};\n      if (maxZoom) {\n        opt.maxZoom = maxZoom;\n      }\n      if (padding) {\n        opt.padding = [padding, padding];\n      }\n      if (offset) {\n        opt.padding = offset;\n      }\n      // top, left, bottom, right\n      this.map.fitBounds(\n        [\n          [e[3], e[0]],\n          [e[1], e[2]],\n        ],\n        opt,\n      );\n    }\n  }\n\n  getLayerAdapter(name: string): Type<LayerAdapter<L.Map, any, any>> {\n    return LeafletMapAdapter.layerAdapters[name];\n  }\n\n  createControl(control: MapControl, options: CreateControlOptions): L.Control {\n    return createControl(control, options, this);\n  }\n\n  createButtonControl(options: ButtonControlOptions): L.Control {\n    return createButtonControl(options, this);\n  }\n\n  addControl(control: Control, position: string): Control | undefined {\n    control.options.position = position.replace('-', '') as ControlPosition;\n    if (this.map) {\n      this.map.addControl(control);\n      return control;\n    }\n  }\n\n  removeControl(control: Control): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  removeLayer(layer: Layer): void {\n    layer && layer.remove && layer.remove();\n  }\n\n  showLayer(layer: Layer): void {\n    if (this.map) {\n      layer.addTo(this.map);\n    }\n  }\n\n  hideLayer(layer: Layer): void {\n    layer.remove();\n  }\n\n  setLayerOpacity(layer: GridLayer | Layer, value: number): void {\n    if ('setOpacity' in layer) {\n      layer.setOpacity(value);\n    }\n  }\n\n  setLayerOrder(\n    layer: Layer,\n    order: number,\n    layers: { [x: string]: LayerAdapter },\n  ): void {\n    //\n  }\n\n  onMapClick(evt: LeafletMouseEvent): void {\n    const converted = convertMapClickEvent(evt);\n    this.emitter.emit('preclick', converted);\n    this.emitter.emit('click', converted);\n  }\n\n  locate(opt: LocateOptions, events?: LocationEvents): Locate {\n    const map = this.map;\n    if (map) {\n      map.locate(opt);\n      if (events) {\n        const { locationfound, locationerror } = events;\n        const locationFound = (e: L.LeafletEvent) => {\n          const event = e as L.LocationEvent;\n          const lngLat: [number, number] = [event.latlng.lng, event.latlng.lat];\n          locationfound({ lngLat });\n        };\n        if (locationfound !== undefined) {\n          map.on('locationfound', locationFound, this);\n        }\n        if (locationerror) {\n          map.on('locationerror', locationerror, this);\n        }\n        const stop = () => {\n          if (locationfound !== undefined) {\n            map.off('locationfound', locationFound);\n          }\n          if (locationerror) {\n            map.off('locationerror', locationerror);\n          }\n        };\n        return { stop };\n      }\n    }\n    const stop = () => void 'fake function';\n    return { stop };\n  }\n\n  private _addUnselectCb(cb: UnselectDef) {\n    for (const p of this._unselectCb) {\n      p();\n    }\n    this._unselectCb.length = 0;\n    this._unselectCb.push(cb);\n  }\n\n  private _addMapListeners() {\n    const map = this.map;\n    if (map) {\n      map.on('click', (evt) => {\n        this.onMapClick(evt as LeafletMouseEvent);\n      });\n      this._universalEvents.forEach((e) => {\n        map.on(e, () => this.emitter.emit(e, this), map);\n      });\n    }\n  }\n}\n","import { ButtonControlOptions, MapAdapter } from '@nextgis/webmap';\nimport { createControl } from './createControl';\nimport { DomEvent, Control } from 'leaflet';\n\nexport function createButtonControl(\n  options: ButtonControlOptions,\n  map: MapAdapter,\n): Control {\n  const link = document.createElement('a');\n\n  const title = options.title || '';\n  link.href = '#';\n  link.title = title;\n\n  link.setAttribute('role', 'button');\n  link.setAttribute('aria-label', title);\n\n  DomEvent.disableClickPropagation(link);\n  DomEvent.on(link, 'click', DomEvent.stop);\n\n  if (options.html instanceof HTMLElement) {\n    link.appendChild(options.html);\n  } else if (typeof options.html === 'string') {\n    link.innerHTML = options.html;\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n\n  return createControl(\n    {\n      onAdd() {\n        if (options.onClick !== undefined) {\n          link.addEventListener('click', onClick);\n        }\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      },\n    },\n    { bar: true },\n    map,\n  );\n}\n","/**\n * @module leaflet-map-adapter\n */\n\nimport { LeafletMapAdapter } from './LeafletMapAdapter';\n\nexport default LeafletMapAdapter;\n"],"names":["svgPath","brill","circle","rect","marker","cross","star","triangle","plus","minus","asterisk","insertSvg","width","height","stroke","content","s","svg","oParser","DOMParser","oDOM","parseFromString","documentElement","getIcon","opt","shape","color","strokeColor","size","anchor","defSize","scale","pathAlias","path","fistChild","firstChild","transform","setAttribute","String","XMLSerializer","type","iconSize","iconAnchor","html","serializeToString","TreeHelper","item","this","parent","_parent","child","_children","push","filterFunc","getParent","treeFilter","x","tree","toReturn","treeFind","getChildren","treeEvery","treeSome","getDescendants","BaseProperty","name","options","EventEmitter","Object","assign","_value","getProperty","call","value","getParents","length","undefined","_blocked","parents","isBlocked","find","parentProp","properties","property","get","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_container","parentNode","removeChild","_removeEventsListener","onSet","emitter","emit","forEach","prop","CheckProperty","set","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","every","_block","_unBlock","_blockChild","_unBlockChild","turnOff","hierarchy","isGroup","blockChild","turnOn","unblockChild","block","children","fry","label","ItemProperties","propertiesList","_propertiesList","_setPropertyHandler","bind","propOpt","handlers","Handler","handler","_properties","list","map","p","destroy","ID","Item","convertMapClickEvent","evt","coord","containerPoint","latLng","latlng","lat","lngLat","lng","pixel","left","top","y","source","createControl","control","C","Control","onAdd","element","document","createElement","classList","add","bar","margin","style","marginBottom","marginTop","marginLeft","marginRight","appendChild","DomEvent","onRemove","AttributionControl","customAttribution","attributions","Array","isArray","addAttribution","boundsToArray","bounds","ne","getNorthEast","sw","getSouthWest","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","PAINT","opacity","backAliases","a","layerType","backAlias","geometryFilter","geometry","indexOf","featuresBounds","features","geoJsonLayer","GeoJSON","f","addData","getBounds","createFeaturePositionOptions","getFeaturesBounds","getCenter","getFeaturesCenter","findMostFrequentGeomType","arr","counts","maxName","c","maxCount","BaseAdapter","order","pane","exist","getPane","createPane","zIndex","Math","round","GeoJsonAdapter","debounce","updateTooltip","unselect","paint","layer","FeatureGroup","nativeOptions","selectedPaint","data","_addMapListener","_removeMapListener","findFeatureFun","_layers","filter","_selectLayer","selected","_setPaintEachLayer","_unSelectLayer","_openedPopup","_removePopup","_selectedLayers","target","feature","_filteredLayers","fun","_filterFun","layer_","_map","remove","filteredLayers","addLayer","removeLayer","addTo","visible","cb","def","splice","clearLayers","clearLayer","geoJsonOptions","geojson","detectedType","geometries","g","console","warn","_data","filterGeometries","_getGeoJsonOptions","_openPopup","layerDef","_updateTooltip","getLayers","isValid","setPaint","setSelectedPaint","l","_setPaint","labelField","unbindTooltip","message","permanent","labelOnHover","bindTooltip","sticky","minWidth","autoPan","maxWidth","closeButton_","closeButton","selectOnHover","_closeHandlers","onClose","close","popup","createPopupContent","popupContent","popupOptions","closeOnClick","autoClose","defined","bindPopup","unselectOnClose","getPopup","once","openPopup","closePopup","unbindPopup","index","findIndex","closeHandlers","h","isPaintCallback","isPaint","divIcon","_createDivIcon","setIcon","setStyle","_preparePaint","aliases","readyPaint","radius","to","from","paintProp","toLowerCase","Number","defineProperty","enumerable","lopt","pointToLayer","iconOpt","_createPaintToLayer","_createPaintOptions","onEachFeature","_onEachFeature","ok","selectable","interactive","on","e","_selectOnLayerClick","_handleMouseEvents","setTimeout","onClick","onLayerClick","onMouseOut","onMouseOver","onClick_","_createMouseEvent","event","createMouseEvent","isSelected","unselectOnSecondClick","_addUnselectCb","multiselect","popupOnSelect","onSelect","icon","toLIconOpt","DivIcon","className","iconClassName","geoJsonPoint","Marker","CircleMarker","paintOptions","unselectOnClick","$unselect","$updateTooltip","off","callAjax","src","callback","headers","xhr","XMLHttpRequest","open","responseType","setRequestHeader","onload","arrayBufferView","Uint8Array","response","blob","Blob","imageUrl","window","URL","webkitURL","createObjectURL","send","abort","ImageOverlay","_abort","img","_image","LImageOverlay","ImageLayer","url","service","request","version","layers","styles","format","transparent","crs","uppercase","attribution","isBack","minZoom","maxZoom","viewPortBuffer","setViewDelay","_url","params","opts","Util","wmsParams","defaultWmsParams","_currentOverlay","cancelLoad","_currentUrl","moveend","updateWmsParams","getImageUrl","pad","overlay","setOpacity","bringToBack","bringToFront","setZIndex","getZoom","getSize","factor","ceil","wmsVersion","parseFloat","projectionKey","nw","project","getNorthWest","se","getSouthEast","code","bbox","CRS","join","pstr","Layer","ImageAdapter","updateWmsParamsFromOpt","makeRemote","Base","args","_update","GridLayer","coords","done","getTileUrl","tile","crossOrigin","alt","tiles","_tiles","tileZoom","_tileZoom","i","z","el","onerror","complete","DomUtil","TileLayer","TileLayerBase","urlTemplate","TL","TileAdapter","tileLayerOptions","subdomains","WmsLayer","WmsLayerBase","WmsAdapter","layerOptions","WMS","OsmAdapter","LeafletMapAdapter","layerAdapters","controlAdapters","zoom","center","mb","maxBounds","mapAdapterOptions","Map","attributionControl","zoomControl","defPane","_addMapListeners","getContainer","controlContainer","_controlContainer","Error","cursor","setView","animate","setCenter","panTo","setZoom","b","offset","padding","fitBounds","link","title","href","HTMLElement","innerHTML","stopPropagation","addEventListener","removeEventListener","createButtonControl","position","replace","addControl","removeControl","converted","events","locate","locationfound","locationerror","locationFound","stop","_unselectCb","onMapClick","_universalEvents","GEOJSON","IMAGE","TILE","OSM","ZOOM","ATTRIBUTION"],"sourceRoot":""}