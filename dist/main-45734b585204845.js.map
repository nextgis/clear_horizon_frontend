{"version":3,"file":"main-45734b585204845.js","mappings":"onEAKO,IAAMA,EAAb,a,kOAAA,U,IAAA,G,EAAA,E,mJAWE,WAAYC,GAAe,a,4FAAA,aACzB,gBADyB,OAVpB,YAUoB,uLAEzBC,OAAOC,OAAP,KAAoBF,GACpBC,OAAOE,eAAP,KAA4BJ,EAASK,WAHZ,EAX7B,YAA8BC,Q,+pDCFvB,IC4BHC,ED5BSC,EAAb,a,kOAAA,U,IAAA,G,EAAA,E,mJAGE,WAAYC,GAAa,M,MAAA,O,4FAAA,S,EAFlB,gB,EAEkB,U,EAAA,EACvB,iB,wFACAP,OAAOE,eAAP,KAA4BI,EAAaH,WACzC,EAAKK,QAAL,4BAAoCD,EAApC,8FAC8EE,SAASC,QAJhE,EAH3B,YAAkCN,QC+BhCC,EAAW,SACTE,EACAI,GAIS,IAHTC,EAGS,uDAHoB,GAC7BC,EAES,uCADTC,EACS,uCACTF,EAAQG,OAASH,EAAQG,QAAU,MAEnC,IAAMC,EAAM,IAAIC,eAChBD,EAAIE,KAAKN,EAAQG,QAAU,MAAOR,GAAK,GAEV,SAAzBK,EAAQO,eACVH,EAAIG,aAAeP,EAAQO,cAE7B,IAAMC,EAAkB,WACtB,IACE,OAAOC,KAAKC,MAAMN,EAAIO,cACtB,MAAOxB,GACP,OAAOiB,EAAIO,eAGTC,EAAqB,WAAsB,IAArBC,EAAqB,wDACzCC,EAAKD,EAAWZ,EAAQF,EACD,SAAzBC,EAAQO,aACVO,EAAGV,EAAIW,UAEHX,EAAIO,aACNG,EAAGN,KAEHP,EAAM,CAAEL,QAAS,MAIvBQ,EAAIY,OAAS,YACuC,IAA9C,CAAC,IAAK,IAAK,IAAK,KAAKC,QAAQb,EAAIc,SACnCjB,EAAM,IAAIf,EAASsB,MAErBI,KAoBFR,EAAIe,QAAU,SAAChC,GACM,IAAfiB,EAAIc,OACNjB,EAAM,IAAIP,EAAaC,IAEvBM,EAAMd,IAIViB,EAAIgB,OAAOC,WAAa,SAAUC,GAChC,GAAIA,EAAEC,iBAAkB,CACtB,IAAMC,EAAmBF,EAAEG,OAASH,EAAEI,MAAS,IAC3C1B,EAAQ2B,YACV3B,EAAQ2B,WAAWH,EAAiBF,KAM1C,IAaIM,EAbEC,EAAU7B,EAAQ6B,QACxB,GAAIA,EACF,IAAK,IAAMC,KAAKD,EAAS,CACvB,IAAME,EAASF,EAAQC,GACD,iBAAXC,GACT3B,EAAI4B,iBAAiBF,EAAGC,GAS9B,QALgCE,IAA5BjC,EAAQkC,kBACV9B,EAAI8B,gBAAkBlC,EAAQkC,iBAI5BlC,EAAQmC,MAGV,IAFAP,EAAO,IAAIQ,UACNC,OAAO,OAAQrC,EAAQmC,MACxBnC,EAAQ4B,KACV,IAAK,IAAMU,KAAKV,EACdA,EAAKS,OAAOC,EAAGV,EAAKU,SAIxBV,EAAO5B,EAAQ4B,KACa,iBAAjB5B,EAAQ4B,KACb5B,EAAQ4B,KACRnB,KAAK8B,UAAUvC,EAAQ4B,MACzB,KAEF1B,GACFA,GAAS,WACPE,EAAIoC,WAGRpC,EAAIqC,KAAKb,I,oBC/IPc,EAAa,qBAEZ,SAASC,EAASC,EAAahB,GACpC,OAAOgB,EAAIC,QAAQH,GAAY,SAACI,EAAGC,GACjC,IAAIC,EAAQpB,EAAKmB,GAEjB,QAAcd,IAAVe,EACF,MAAM,IAAIxD,MAAM,kCAAoCsD,GAItD,MAH4B,mBAAVE,IAChBA,EAAQA,EAAMpB,IAEToB,K,y2BCNJ,IAAMC,EAAb,a,kOAAA,U,IAAA,G,EAAA,E,+YAIE,WAAYC,GAA6B,a,4FAAA,aACvC,cAAMA,IADiC,OAHlC,yBAGkC,mBAFd,kDAIzB9D,OAAOE,eAAP,KAA4B2D,EAAsB1D,WAFX,EAJ3C,UAA2CL,G,y2BCApC,IAAMiE,EAAb,a,kOAAA,U,IAAA,G,EAAA,E,+YAKE,WAAYD,GAAmC,a,4FAAA,aAC7C,cAAMA,IADuC,OAJxC,gCAIwC,mBAF7C,qDAIA9D,OAAOE,eAAP,KAA4B6D,EAA6B5D,WAFZ,EALjD,UAAkDL,G,2BCFrCkE,EAA6B,GAEnC,SAASC,EAAaC,GAC3BF,EAAWG,KAAKD,G,8CCPX,SAASE,EAASC,GACvB,MAA+C,oBAAxCrE,OAAOG,UAAUmE,SAASC,KAAKF,G,87BCSjC,SAASG,EACdC,GAEyB,IADzBC,EACyB,uDADhB,GAETA,EAASA,EAASA,EAAS,KAAO,GAClC,IAAMC,EAA6B,GASnC,OARA3E,OAAO4E,QAAQH,GAAUI,SAAQ,YAAkB,aAAhBlB,EAAgB,KAAXC,EAAW,KACjD,GAAIQ,EAASR,GAAQ,CACnB,IAAMkB,EAAWN,EAAgBZ,EAAgCD,GACjE3D,OAAOC,OAAO0E,EAAOG,QACZC,EAAAA,EAAAA,GAAQnB,KACjBe,EAAMD,EAASf,GAAOC,MAGnBe,E,gnBCTF,IAAMK,GAAb,WAME,WAAoBd,I,4FAAyB,cAAzBA,UAAAA,EAAyB,gBALrC,IAAIe,EAAAA,G,QADd,O,EAAA,E,EAAA,qBAmBE,SACER,EACAS,GAC6C,WAY7C,OAXc,IAAID,EAAAA,GAWLE,IAAI,YAVG,WAClB,MAAwB,iBAAbV,EACF,EAAKW,iBAAiB,CAAEC,QAASZ,GAAYS,GACvB,iBAAbT,EACT,EAAKa,mBAAmBb,EAAUS,GAChCd,EAASK,GACX,EAAKW,iBAAiBX,EAAUS,GAElCK,EAAAA,EAAAA,aAA0B1C,KAEO,CAAE4B,SAAAA,MAlChD,0BAqCE,SAAaA,GACX,OAAOe,KAAKC,OAAOhB,GAAUiB,MAAK,SAACC,GACjC,GAAIA,EACF,OAAOA,EAET,MAAM,IAAI9B,OA1ChB,mBAwDE,SAAMY,GACJ,MAAwB,iBAAbA,EACFc,EAAAA,EAAAA,QAA0Bd,GACJ,iBAAbA,GAAyBL,EAASK,GAC3Ce,KAAKC,OAAOhB,GAAUiB,MAAK,SAACC,GACjC,GAAIA,EACF,OAAOA,EAAIlB,SAASmB,MAInBL,EAAAA,EAAAA,aAA0B1C,KAlErC,yBA6EE,SAAY4B,GACV,OAAOe,KAAKK,MAAMpB,GAAUiB,MAAK,SAACI,GAChC,QAAajD,IAATiD,EACF,MAAM,IAAI1F,MAEZ,OAAO0F,OAlFb,qBAsFE,SACErB,EACAS,GACmC,WACnC,OAAOM,KAAKO,qBAAqBtB,GAAUiB,MAAK,SAACM,GAC/C,IAAKA,EAAMC,OAAQ,CACjB,IAAMtB,EAAiC,GAMvC,OALIF,EAASY,QACXV,EAAMU,QAAUZ,EAASY,QAEzBrF,OAAOC,OAAO0E,EAAOH,EAAgBC,IAEhC,EAAKP,UACTgC,IAAI,kBAAmBhB,E,gWADnB,EAEHiB,cAAe,QACZxB,IAEJe,MAAK,SAACU,GAQL,OAPIA,GACFA,EAAUvB,SAAQ,SAACwB,GACjB,EAAKC,MAAMnB,IAAI,gBAAiBI,EAAAA,EAAAA,QAA0Bc,GAAI,CAC5DT,GAAIS,EAAE5B,SAASmB,QAIdQ,KAGb,OAAOJ,OAlHb,uBAsHE,SACEvB,GAC6C,WAC7C,OAAOe,KAAKtB,UAAUqC,YAAY9B,GAAUiB,MAAK,SAACc,GAChD,OAAIA,EACK,EAAKtC,UAAUqC,YAAYC,EAAM/B,SAASgC,OAAOb,IAEnDL,EAAAA,EAAAA,aAA0B1C,QA7HvC,2BAiIE,SACE4B,GACmC,WACnC,OAAOe,KAAKK,MAAMpB,GAAUiB,MAAK,SAACe,GAChC,OAAO,EAAKvC,UACTgC,IACC,sBACA,CAAEI,OAAO,GACT,CACEG,OAAAA,IAGHf,MAAK,SAACM,GAAU,Q,25BAAA,CACCA,GADD,IACf,2BAAuB,KAAZU,EAAY,QACrB,EAAKJ,MAAMnB,IAAI,gBAAiBI,EAAAA,EAAAA,QAA0BmB,GAAI,CAC5Dd,GAAIc,EAAEjC,SAASmB,MAHJ,8BAMf,OAAOI,UAnJjB,oBAwJE,SACEvB,EACAjC,GAC6C,WAC7C,OAAOgD,KAAKK,MAAMpB,GAAUiB,MAAK,SAACE,GAChC,QAAW/C,IAAP+C,EACF,OAAO,EAAK1B,UAAUyC,IAAI,gBAAiB,CAAEnE,KAAAA,GAAQ,CAAEoD,GAAAA,SA9J/D,oBAuKE,SAAOnB,GAAuD,WAC5D,OAAOe,KAAKK,MAAMpB,GAAUiB,MAAK,SAACE,GAChC,QAAW/C,IAAP+C,EACF,OAAO,EAAK1B,UAAU0C,OAAO,gBAAiB,KAAM,CAAEhB,GAAAA,IAAMF,MAAK,WAC/D,EAAKY,MAAMM,OAAO,gBAAiB,CAAEhB,GAAAA,YA3K/C,gCAkLE,SACEA,EACAV,GAC6C,WAI7C,OAAOM,KAAKc,MACTnB,IAAI,iBAJS,kBACd,EAAKjB,UAAUgC,IAAI,gBAAiBhB,EAAgB,CAAEU,GAAAA,MAGvB,CAC7BA,GAAAA,IAEDiB,OAAM,SAAC9G,GACN,KAAMA,aAAc8D,GAClB,MAAM9D,OA/LhB,8BAqME,SACE0E,EACAS,GAEA,OAAOM,KAAKsB,QAAQrC,EAAUS,GAAgBQ,MAAK,SAACU,GAClD,OAAOA,EAAU,QA1MvB,kCA8ME,SACE3B,GAEA,OAAOc,EAAAA,EAAAA,IAAsBC,KAAKc,MAAMS,SAAS,kBAAkBrB,MACjE,SAACU,GAcC,OAZAA,EAAUY,QAAO,SAACX,GAChB,GAAIA,EAEF,OAAI5B,EAASY,SAAWgB,EAAE5B,SAASY,QAC1BZ,EAASY,UAAYgB,EAAE5B,SAASY,SAErCN,EAAAA,EAAAA,GAAQN,EAASmB,MAAOb,EAAAA,EAAAA,GAAQsB,EAAE5B,SAASmB,IACtCnB,EAASmB,KAAOS,EAAE5B,SAASmB,ICrO9CqB,EDuOiCxC,ECtOjCyC,EDsO2Cb,EAAE5B,UCpOtC0C,EAAAA,EAAAA,GAAgBF,EAAMC,IAJxB,IACLD,EACAC,KD4NoC,S,qBAnNtC,K,2GEEO,SAASE,GAGdC,GACA,IAAMC,EAASD,EAAIC,OACnB,OAAO,IAAI/B,EAAAA,GAAkB,SAACgC,EAASC,GACrCH,EAAInD,UACDuD,UACA/B,MAAK,SAACgC,GACL,I,EAAIC,EAAUD,GAAYA,EAASL,EAAIO,MACvC,GAAID,EAAS,CAEX,IAAIpH,G,EADUoH,EAAdA,E,qnBACkBE,QAClB,GAAIF,EAAQ1B,OAAQ,CAIlB,IAHA,IAAM6B,EAEF,GACKC,EAAM,EAAGA,EAAMJ,EAAQ1B,OAAQ8B,IAAO,CAC7C,IAAMC,EAAML,EAAQI,GAEpB,GADAD,EAAcC,GAAO,IAAMC,EAAM,SACbnF,IAAhByE,EAAOU,GACT,MAAM,IAAI5H,MACR,IAAM4H,EAAN,uCAIFzH,IACFA,EAAMgD,EAAShD,EAAKuH,IAIxB,GAAIR,EAAQ,CACV,IAAMW,EAAa,GACbC,EAAYZ,EAAOY,UAOzB,IAAK,IAAMC,KANPC,MAAMC,QAAQH,YACTZ,EAAOY,UACdA,EAAUrD,SAAQ,SAACwB,GACjB4B,EAAW9D,KAAX,UAAmBkC,EAAE,GAArB,YAA2BA,EAAE,SAGjBiB,GACc,IAAxBK,EAAQ9F,QAAQsG,IAClBF,EAAW9D,KAAX,UAAmBgE,EAAnB,YAAwBb,EAAOa,KAG/BF,EAAWhC,SACb1F,EAAMA,EAAM,IAAM0H,EAAWK,KAAK,MAGlC/H,EACFgH,EAAQF,EAAInD,UAAUqE,UAAUhI,EAAK+G,EAAQD,EAAInC,iBAEjDsC,EAAO,IAAIpH,MAAM,gCAGnBmH,OAAQ1E,MAGXgE,OAAM,SAAC9G,GACNyH,EAAOzH,S,42BCnCf,IAAIyI,GAAK,EAEIC,GAAb,WAcE,WAAmB7H,I,4FAA8B,cAA9BA,QAAAA,EAA8B,aAT5C4H,MAS4C,kBAPvC,IAAIE,EAAAA,cAOmC,sEAF9B,gCAGjB,IAAMC,ENhDH,SACL/H,GAEA,OAAOoD,EAAW4E,MAAK,SAACvC,GACtB,GAAIA,EAAEzF,QAAQiI,UAAYjI,EAAQiI,QAAS,CACzC,IAAIjI,EAAQkI,KAMV,OAAO,EALP,GAAIzC,EAAEzF,QAAQkI,KACZ,OAAO3B,EAAAA,EAAAA,GAAgBd,EAAEzF,QAAQkI,KAAMlI,EAAQkI,UMyCvCC,CAAcnI,GAC5B,GAAI+H,EACF,OAAOA,EAEHnD,KAAK5E,QAAQoI,QACfxD,KAAKyD,SAAWzD,KAAK5E,QAAQoI,OAE/BxD,KAAKY,UAAY,IAAIpB,GAAiBQ,MACtCvB,EAAauB,M,UAvBnB,O,EAAA,E,EAAA,qBAoCE,SAAOqD,GACLrD,KAAK0D,SACL1D,KAAK5E,QAAQiI,QAAUA,EACvB5E,EAAauB,QAvCjB,qBAuDE,WAA2C,WACnCc,EAAQ,IAAIrB,EAAAA,EACZ6D,EAAOtD,KAAK5E,QAAQkI,KAwB1B,OAAOxC,EAAMnB,IAAI,SAvBG,kBAClB,IAAII,EAAAA,GAAkB,SAACgC,EAASC,GAC9B,IAAMe,EAAY,WAChB,OAAO,EAAKA,UAAU,EAAKU,SAAU,GAAI,IACtCvD,MAAK,SAACsD,GACLzB,EAAQyB,MAETnC,OAAM,SAAC9G,GACNyH,EAAOzH,OAGb,GAAI+I,EAAM,CACR,IAAQK,EAAoBL,EAApBK,MAAOC,EAAaN,EAAbM,SACf,GAAID,GAASC,EACX,OAAO,EAAKC,YAAY,CAAEF,MAAAA,EAAOC,SAAAA,IAC9B1D,MAAK,WACJ6C,OAED1B,OAAM,SAAC9G,GAAD,OAAQyH,EAAOzH,MAG5B,OAAOwI,SAE4B,CACrC3C,GAAIJ,KAAKI,GACTkD,KAAAA,EACAD,QAASrD,KAAK5E,QAAQiI,YApF5B,mBA4FE,SAAMS,GAGJ,OAFA9D,KAAK0D,SACLjF,EAAauB,MACNA,KAAK6D,YAAYC,KA/F5B,oBAqGE,WNrHK,IAAyBpF,EACxBqF,EADwBrF,EMsHZsB,MNpHH,KADT+D,EAAQvF,EAAWnC,QAAQqC,KAE/BF,EAAWwF,OAAOD,EAAO,GMoHzB/D,KAAK5E,QAAQkI,UAAOjG,EACpB2C,KAAKiE,UAAO5G,EACZ2C,KAAKkE,QAAQC,KAAK,UAClBnE,KAAKY,UAAUE,MAAMsD,UA1GzB,yBA6GE,SAAYN,GAAwD,WAClE,GAAI9D,KAAKiE,MAAQjE,KAAKiE,KAAK7D,GACzB,OAAOL,EAAAA,EAAAA,QAA0BC,KAAKiE,MAEpCH,IACF9D,KAAK5E,QAAQkI,KAAOQ,GAEtB,IAAM1I,EAA0B,CAC9B6B,QAAS+C,KAAKqE,wBAAwBP,IAKxC,OAAO9D,KAAK+C,UAAU,mCAAoC,GAAI3H,GAC3D8E,MAAK,SAAClD,GAGL,OAFA,EAAKiH,KAAOjH,EACZ,EAAKkH,QAAQC,KAAK,QAASnH,GACpBA,KAERqE,OAAM,SAAC9G,GAEN,MADA,EAAK2J,QAAQC,KAAK,cAAe5J,GAC3BA,OAlId,qCAyIE,SACEuJ,GAEA,IAAMQ,EAAStE,KAAKuE,aAAaT,GACjC,GAAIQ,EACF,MAAO,CACLE,cAAe,SAAWF,KA/IlC,0BAoJE,SAAaR,GAEX,GADAA,EAAcA,GAAe9D,KAAK5E,QAAQkI,KACzB,CACf,MAA4BQ,EAApBH,EAAR,EAAQA,MAAOC,EAAf,EAAeA,SACT5F,EAAMyG,SAASC,mBAAmB,GAAD,OAAIf,EAAJ,YAAaC,KAGlD,OAAOe,OAAOC,KAAK5G,MA3J3B,wBA+LE,SAIEoE,GAGyB,WAFzByC,EAEyB,uDAFQ,GACjCnF,EACyB,uDADQ,GAEzBnE,EAAmDmE,EAAnDnE,OAAQ0B,EAA2CyC,EAA3CzC,QAASK,EAAkCoC,EAAlCpC,gBAAiB3B,EAAiB+D,EAAjB/D,aACpCmG,GAASgD,EAAAA,EAAAA,GAAkBD,GAC3BE,EAAiB,kBACrBnD,GAAW,CAAEQ,KAAAA,EAAMN,OAAAA,EAAQpC,eAAAA,EAAgBhB,UAAW,KACxD,GAAIgB,EAAeoB,OAAoB,QAAXvF,EAAkB,CAC5C,IAAMuF,EAAQ,IAAIrB,EAAAA,EAClB,OAAOqB,EAAMnB,IAAIyC,EAAM2C,EAAhB,IACLjD,OAAAA,IACGgD,EAAAA,EAAAA,GAAkB,CACnB7H,QAAAA,EACAK,gBAAAA,EACA3B,aAAAA,EACA0H,QAASrD,KAAK5E,QAAQiI,QACtBC,KAAMtD,KAAK5E,QAAQkI,SAIzB,OAAOyB,MAxNX,kBAwOE,SACE3C,EACAhH,EACA0G,GAIA,OAFA1G,EAAUA,GAAW,IACbG,OAAS,OACVyE,KAAK4B,WACVQ,EACAN,EACA1G,KAlPN,iBA4PE,SACEgH,EACAhH,EACA0G,GAIA,OAFA1G,EAAUA,GAAW,IACbG,OAAS,MACVyE,KAAK4B,WACVQ,EACAN,EACA1G,KAtQN,mBAgRE,SACEgH,EACAhH,EACA0G,GAIA,OAFA1G,EAAUA,GAAW,IACbG,OAAS,QACVyE,KAAK4B,WACVQ,EACAN,EACA1G,KA1RN,iBAoSE,SACEgH,EACAhH,EACA0G,GAIA,OAFA1G,EAAUA,GAAW,IACbG,OAAS,MACVyE,KAAK4B,WACVQ,EACAN,EACA1G,KA9SN,oBAwTE,SACEgH,EACAhH,EACA0G,GAIA,OAFA1G,EAAUA,GAAW,IACbG,OAAS,SACVyE,KAAK4B,WACVQ,EACAN,EACA1G,KAlUN,uBA4UE,SACEL,EACA+G,GAEwB,IADxB1G,EACwB,uDADE,GAG1B,GADAL,GAAOiF,KAAK5E,QAAQiI,QAAUrD,KAAK5E,QAAQiI,QAAU,IAAMtI,EAOzD,OALI+G,IACF/G,EAAMgD,EAAShD,EAAK+G,IAGtB/G,GAAMiK,EAAAA,EAAAA,GAAUjK,GACTiF,KAAKiF,UAAUlK,EAAKK,GAE3B,MAAM,IAAIR,MAAM,6BA1VtB,yBAqWE,SACEqE,GAEA,OAAOe,KAAKY,UAAUX,OAAOhB,KAxWjC,+BA8WE,SACEA,GAEA,OAAOe,KAAKY,UAAUsE,aAAajG,KAjXvC,2BAuXE,SACEA,GAEA,OAAOe,KAAKY,UAAUX,OAAOhB,KA1XjC,kCAgYE,SACEY,GAEA,OAAOG,KAAKY,UAAUX,OAAOJ,KAnYjC,6BAyYE,SAAgBO,GACd,OAAOJ,KAAKY,UAAUX,OAAOG,KA1YjC,2BAgZE,SACEnB,GAEA,OAAOe,KAAKY,UAAUP,MAAMpB,KAnZhC,iCAyZE,SAAoBA,GAClB,OAAOe,KAAKY,UAAUuE,YAAYlG,KA1ZtC,4BAgaE,SACEA,GAEA,OAAOe,KAAKY,UAAUU,QAAQrC,KAnalC,+BAyaE,SACEA,GAEA,OAAOe,KAAKY,UAAUwE,UAAUnG,KA5apC,iCAkbE,SACEA,GAEA,OAAOe,KAAKY,UAAUyE,cAAcpG,KArbxC,4BA2bE,SACEA,EACAjC,GAEA,OAAOgD,KAAKY,UAAU0E,OAAOrG,EAAUjC,KA/b3C,4BAqcE,SAAeiC,GACb,OAAOe,KAAKY,UAAUQ,OAAOnC,KAtcjC,uBA4cE,SACElE,EACAK,GACwB,WAExB,OADAA,EAAQO,aAAeP,EAAQO,cAAgB,OACxC,IAAIoE,EAAAA,GAAkB,SAACgC,EAASC,EAAQ1G,GACzC,EAAK2I,QACP7I,EAAUA,GAAW,IAEb6B,QAAR,SACK,EAAKoH,2BACLjJ,EAAQ6B,UAGfpC,EAASE,EAAKgH,EAAS3G,EAAS4G,EAAQ1G,MACvC+F,OAAM,SAACkE,GACR,GAAIA,aAAqBxF,EAAAA,EAAAA,iBAElB,CAKL,IAAMxF,EAAK,EAAKiL,iBAAiBD,GACjC,GAAIhL,EACF,MAAMA,QArehB,8BA2eE,SAAyBA,GACvB,GAAIA,GACEA,aAAcD,EAAU,CAC1B,GAAqB,mDAAjBC,EAAGkL,UACL,MAAM,IAAIpH,EAAsB9D,GAC3B,GACY,sDAAjBA,EAAGkL,UAEH,MAAM,IAAIlH,EAA6BhE,GAI7C,OAAOA,K,EAvfX,qBA2BE,SAAca,GACZ,OAAO,IAAI4E,KAAK5E,M,gCA5BpB,K,GAAa6H,GAAAA,SACK,CACd3I,SAAAA,EACA+D,sBAAAA,IC5BJ","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/NgwError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/NetworkError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/loadData.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/template.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/ResourceNotFoundError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/InsufficientPermissionsError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/activeConnectors.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/isObject.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/resourceToQuery.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/ResourcesControl.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/resourceCompare.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/apiRequest.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/NgwConnector.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/index.ts"],"sourcesContent":["import { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when...\n */\nexport class NgwError extends Error {\n  name = 'NgwError';\n\n  title!: string;\n  message!: string;\n  detail!: string;\n  exception!: NgwExceptions;\n  status_code!: number | 404 | 500;\n  data?: Record<string, any>;\n  guru_meditation!: string;\n\n  constructor(er?: NgwError) {\n    super();\n    Object.assign(this, er);\n    Object.setPrototypeOf(this, NgwError.prototype);\n  }\n}\n","/**\n * Thrown when...\n */\nexport class NetworkError extends Error {\n  name = 'NetworkError';\n\n  constructor(url: string) {\n    super();\n    Object.setPrototypeOf(this, NetworkError.prototype);\n    this.message = `Unable to request ${url}.\n    Possibly invalid NGW URL entered or CORS not configured to get request from ${location.origin}`; // /control-panel/cors\n  }\n}\n","import {\n  RequestOptions as NgwRequestOptions,\n  RequestMethods,\n} from '../interfaces';\nimport { NgwError } from '../errors/NgwError';\nimport { NetworkError } from '../errors/NetworkError';\n\n// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\ntype LoadData = (\n  url: string,\n  callback: (...args: any[]) => any,\n  options: NgwRequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (cancelHandler: () => void) => void,\n) => void;\n\nlet loadData: LoadData;\n// @ts-ignore\nif (__BROWSER__) {\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): void => {\n    options.method = options.method || 'GET';\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n    if (options.responseType === 'blob') {\n      xhr.responseType = options.responseType;\n    }\n    const getResponseText = () => {\n      try {\n        return JSON.parse(xhr.responseText);\n      } catch (er) {\n        return xhr.responseText;\n      }\n    };\n    const processingResponse = (forError = false) => {\n      const cb = forError ? error : callback;\n      if (options.responseType === 'blob') {\n        cb(xhr.response);\n      } else {\n        if (xhr.responseText) {\n          cb(getResponseText());\n        } else {\n          error({ message: '' });\n        }\n      }\n    };\n    xhr.onload = () => {\n      if ([401, 403, 404, 500].indexOf(xhr.status) !== -1) {\n        error(new NgwError(getResponseText()));\n      }\n      processingResponse();\n    };\n\n    // xhr.onreadystatechange = () => {\n    //   if (\n    //     (xhr.readyState === 4 && xhr.status === 200) ||\n    //     (xhr.readyState === 3 && xhr.status === 201)\n    //   ) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 3 && xhr.status === 400) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 500) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 401) {\n    //     error(xhr.statusText);\n    //   } else if (xhr.readyState === 4) {\n    //     error('request error');\n    //   }\n    // };\n\n    xhr.onerror = (er) => {\n      if (xhr.status === 0) {\n        error(new NetworkError(url));\n      } else {\n        error(er);\n      }\n    };\n\n    xhr.upload.onprogress = function (e) {\n      if (e.lengthComputable) {\n        const percentComplete = (e.loaded / e.total) * 100;\n        if (options.onProgress) {\n          options.onProgress(percentComplete, e);\n        }\n        // console.log(percentComplete + '% uploaded');\n      }\n    };\n\n    const headers = options.headers;\n    if (headers) {\n      for (const h in headers) {\n        const header = headers[h];\n        if (typeof header === 'string') {\n          xhr.setRequestHeader(h, header);\n        }\n      }\n    }\n    if (options.withCredentials !== undefined) {\n      xhr.withCredentials = options.withCredentials;\n    }\n\n    let data: FormData | any;\n    if (options.file) {\n      data = new FormData();\n      data.append('file', options.file);\n      if (options.data) {\n        for (const d in data) {\n          data.append(d, data[d]);\n        }\n      }\n    } else {\n      data = options.data\n        ? typeof options.data === 'string'\n          ? options.data\n          : JSON.stringify(options.data)\n        : null;\n    }\n    if (onCancel) {\n      onCancel(() => {\n        xhr.abort();\n      });\n    }\n    xhr.send(data);\n  };\n} else {\n  const url = require('url');\n  const http = require('http');\n  const https = require('https');\n\n  const adapterFor = (inputUrl: string) => {\n    const adapters: Record<string, any> = {\n      'http:': http,\n      'https:': https,\n    };\n    const protocol = url.parse(inputUrl).protocol || 'https:';\n    return adapters[protocol];\n  };\n\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions<RequestMethods> = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): Promise<unknown> => {\n    const request = new Promise((resolve, reject) => {\n      const adapter = adapterFor(url);\n      if (adapter) {\n        const requestOpt = {\n          headers: options.headers || {},\n          method: options.method,\n        };\n        const body =\n          typeof options.data === 'string'\n            ? options.data\n            : JSON.stringify(options.data);\n        // https://stackoverflow.com/questions/35589109/node-http-delete-request-no-longer-works-after-upgrading-from-0-10-40\n        if (body !== undefined && options.method !== 'POST') {\n          Object.assign(requestOpt.headers, {\n            'Content-Type': 'application/json',\n            'Content-Length': Buffer.byteLength(body),\n          });\n        }\n        const req = adapter.request(url, requestOpt, (resp: any) => {\n          let data = '';\n          resp.on('data', (chunk: any) => {\n            data += chunk;\n          });\n          resp.on('end', () => {\n            if (data) {\n              let json: Record<string, any> | undefined;\n              try {\n                json = JSON.parse(data);\n                if (json && json.status_code && json.status_code) {\n                  reject(json.message);\n                }\n              } catch (er) {\n                reject(er);\n                // throw new Error(er);\n              }\n              if (json !== undefined) {\n                resolve(json);\n              }\n            }\n            reject('no data');\n          });\n        });\n        req.on('error', (err: any) => {\n          reject(err);\n        });\n        if (body) {\n          req.write(body);\n        }\n        onCancel(() => {\n          req.abort();\n        });\n        req.end();\n      } else {\n        throw new Error(`Given URL '${url}' is not correct`);\n      }\n    });\n    return request\n      .then((data) => {\n        if (callback) {\n          callback(data);\n        }\n        return data;\n      })\n      .catch((er) => {\n        if (error) {\n          error(er);\n        } else {\n          throw new Error(er);\n        }\n      });\n  };\n}\n\nexport { loadData };\n","// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }): string {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","import { NgwError } from './NgwError';\nimport { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class ResourceNotFoundError extends NgwError {\n  name = 'ResourceNotFoundError';\n  exception: NgwExceptions = 'nextgisweb.resource.exception.ResourceNotFound';\n\n  constructor(obj?: ResourceNotFoundError) {\n    super(obj);\n    Object.setPrototypeOf(this, ResourceNotFoundError.prototype);\n  }\n}\n","import { NgwError } from './NgwError';\nimport { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class InsufficientPermissionsError extends NgwError {\n  name = 'InsufficientPermissionsError';\n  exception: NgwExceptions =\n    'nextgisweb.core.exception.InsufficientPermissions';\n\n  constructor(obj: InsufficientPermissionsError) {\n    super(obj);\n    Object.setPrototypeOf(this, InsufficientPermissionsError.prototype);\n  }\n}\n","import { NgwConnectorOptions } from './interfaces';\nimport { NgwConnector } from './NgwConnector';\nimport { objectDeepEqual } from '@nextgis/utils';\n\nexport const CONNECTORS: NgwConnector[] = [];\n\nexport function addConnector(connector: NgwConnector): void {\n  CONNECTORS.push(connector);\n}\n\nexport function findConnector(\n  options: NgwConnectorOptions,\n): NgwConnector | undefined {\n  return CONNECTORS.find((x) => {\n    if (x.options.baseUrl === options.baseUrl) {\n      if (options.auth) {\n        if (x.options.auth) {\n          return objectDeepEqual(x.options.auth, options.auth);\n        }\n      } else {\n        // if auth not in find options; use first connector with same url\n        return true;\n      }\n    }\n  });\n}\n\nexport function removeConnector(connector: NgwConnector): void {\n  const index = CONNECTORS.indexOf(connector);\n  if (index !== -1) {\n    CONNECTORS.splice(index, 1);\n  }\n}\n\nexport function findAndRemoveConnector(options: NgwConnectorOptions): void {\n  const exist = findConnector(options);\n  if (exist) {\n    removeConnector(exist);\n  }\n}\n","export function isObject(val: unknown): val is Record<string | number, any> {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n","import { DeepPartial, defined } from '@nextgis/utils';\nimport { Resource } from '../types/ResourceItem';\nimport { isObject } from './isObject';\n\n/**\n * ```\n * { keyname, parent: { id }} > { keyname, parent__id }\n * ```\n * @param resource - Any property from NGW resource item\n */\nexport function resourceToQuery(\n  resource: DeepPartial<Resource>,\n  prefix = '',\n): Record<string, unknown> {\n  prefix = prefix ? prefix + '__' : '';\n  const query: Record<string, any> = {};\n  Object.entries(resource).forEach(([key, value]) => {\n    if (isObject(value)) {\n      const children = resourceToQuery(value as DeepPartial<Resource>, key);\n      Object.assign(query, children);\n    } else if (defined(value)) {\n      query[prefix + key] = value;\n    }\n  });\n  return query;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined } from '@nextgis/utils';\nimport Cache from '@nextgis/cache';\n\nimport { resourceToQuery } from './utils/resourceToQuery';\nimport { resourceCompare } from './utils/resourceCompare';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\n\nimport { isObject } from './utils/isObject';\n\nimport type { DeepPartial } from '@nextgis/utils';\nimport type { NgwConnector } from './NgwConnector';\nimport type { ResourceItem, Resource } from './types/ResourceItem';\nimport type { RequestOptions, ResourceDefinition } from './interfaces';\n\nexport class ResourcesControl {\n  cache = new Cache<\n    CancelablePromise<ResourceItem | undefined>,\n    { id?: number }\n  >();\n\n  constructor(private connector: NgwConnector) {}\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Receive resource from NGW by id, keyname or search-object parameter.\n   * @param resource - Resource id, keyname or search-object\n   *\n   * @remarks\n   * Fetching resource would be cached to speed up next call\n   */\n  getOne(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const cache = new Cache();\n    const makeRequest = () => {\n      if (typeof resource === 'string') {\n        return this._fetchResourceBy({ keyname: resource }, requestOptions);\n      } else if (typeof resource === 'number') {\n        return this._fetchResourceById(resource, requestOptions);\n      } else if (isObject(resource)) {\n        return this._fetchResourceBy(resource, requestOptions);\n      }\n      return CancelablePromise.resolve(undefined);\n    };\n    return cache.add('resource', makeRequest, { resource });\n  }\n\n  getOneOrFail(resource: ResourceDefinition): CancelablePromise<ResourceItem> {\n    return this.getOne(resource).then((res) => {\n      if (res) {\n        return res;\n      }\n      throw new ResourceNotFoundError();\n    });\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * There are situations when exactly the resource id is needed\n   * (for example, to compose the correct request to the api)\n   * then this method will come in handy to facilitate the extraction of the identifier\n   * if the resource is specified through a keyname or other parameters.\n   */\n  getId(resource: ResourceDefinition): CancelablePromise<number | undefined> {\n    if (typeof resource === 'number') {\n      return CancelablePromise.resolve(resource);\n    } else if (typeof resource === 'string' || isObject(resource)) {\n      return this.getOne(resource).then((res) => {\n        if (res) {\n          return res.resource.id;\n        }\n      });\n    }\n    return CancelablePromise.resolve(undefined);\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * Similar with {@link NgwConnector.getResourceId | getResourceId} but rise error if resource is not exist.\n   * To not make one more checks if the resource is definitely exists\n   */\n  getIdOrFail(resource: ResourceDefinition): CancelablePromise<number> {\n    return this.getId(resource).then((resp) => {\n      if (resp === undefined) {\n        throw new Error();\n      }\n      return resp;\n    });\n  }\n\n  getMany(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this._resourceCacheFilter(resource).then((items) => {\n      if (!items.length) {\n        const query: Record<string, unknown> = {};\n        if (resource.keyname) {\n          query.keyname = resource.keyname;\n        } else {\n          Object.assign(query, resourceToQuery(resource));\n        }\n        return this.connector\n          .get('resource.search', requestOptions, {\n            serialization: 'full',\n            ...query,\n          })\n          .then((resources) => {\n            if (resources) {\n              resources.forEach((x) => {\n                this.cache.add('resource.item', CancelablePromise.resolve(x), {\n                  id: x.resource.id,\n                });\n              });\n            }\n            return resources;\n          });\n      }\n      return items;\n    });\n  }\n\n  getParent(\n    resource: ResourceDefinition,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.connector.getResource(resource).then((child) => {\n      if (child) {\n        return this.connector.getResource(child.resource.parent.id);\n      }\n      return CancelablePromise.resolve(undefined);\n    });\n  }\n\n  getChildrenOf(\n    resource: ResourceDefinition,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.getId(resource).then((parent) => {\n      return this.connector\n        .get(\n          'resource.collection',\n          { cache: true },\n          {\n            parent,\n          },\n        )\n        .then((items) => {\n          for (const i of items) {\n            this.cache.add('resource.item', CancelablePromise.resolve(i), {\n              id: i.resource.id,\n            });\n          }\n          return items;\n        });\n    });\n  }\n\n  update(\n    resource: ResourceDefinition,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.put('resource.item', { data }, { id });\n      }\n    });\n  }\n\n  /**\n   * Fast way to delete resource from NGW and clean cache.\n   * @param resource - Resource definition\n   */\n  delete(resource: ResourceDefinition): CancelablePromise<void> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.delete('resource.item', null, { id }).then(() => {\n          this.cache.delete('resource.item', { id });\n          return undefined;\n        });\n      }\n    });\n  }\n\n  private _fetchResourceById(\n    id: number,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const promise = () =>\n      this.connector.get('resource.item', requestOptions, { id });\n\n    return this.cache\n      .add('resource.item', promise, {\n        id,\n      })\n      .catch((er) => {\n        if (!(er instanceof ResourceNotFoundError)) {\n          throw er;\n        }\n        return undefined;\n      });\n  }\n\n  private _fetchResourceBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getMany(resource, requestOptions).then((resources) => {\n      return resources[0];\n    });\n  }\n\n  private _resourceCacheFilter(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem[]> {\n    return CancelablePromise.all(this.cache.matchAll('resource.item')).then(\n      (resources) => {\n        const items: ResourceItem[] = [];\n        resources.filter((x) => {\n          if (x) {\n            // identical by uniq props\n            if (resource.keyname && x.resource.keyname) {\n              return resource.keyname === x.resource.keyname;\n            }\n            if (defined(resource.id) && defined(x.resource.id)) {\n              return resource.id === x.resource.id;\n            }\n            return resourceCompare(resource, x.resource);\n          }\n        });\n        return items;\n      },\n    );\n  }\n}\n","import { objectDeepEqual } from '@nextgis/utils';\nimport type { DeepPartial } from '@nextgis/utils';\nimport type { Resource } from '../types/ResourceItem';\n\nexport function resourceCompare(\n  res1: DeepPartial<Resource>,\n  res2: DeepPartial<Resource>,\n): boolean {\n  return objectDeepEqual(res1, res2);\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { template } from './template';\nimport type { NgwConnector } from '../NgwConnector';\nimport type {\n  RequestItemKeys,\n  RequestItemsParams,\n  RequestOptions,\n} from '../interfaces';\nimport type { RequestItemsParamsMap } from '../types/RequestItemsParamsMap';\n\ninterface ApiRequestOptions<K extends keyof RequestItemsParamsMap> {\n  name: string;\n  connector: NgwConnector;\n  params: RequestItemsParams<K>;\n  requestOptions: RequestOptions;\n}\n\nexport function apiRequest<\n  K extends keyof RequestItemsParamsMap,\n  P extends RequestItemKeys = RequestItemKeys,\n>(opt: ApiRequestOptions<K>): CancelablePromise<P[K]> {\n  const params = opt.params;\n  return new CancelablePromise((resolve, reject) => {\n    opt.connector\n      .connect()\n      .then((apiItems) => {\n        let apiItem = apiItems && apiItems[opt.name];\n        if (apiItem) {\n          apiItem = [...apiItem];\n          let url = apiItem.shift();\n          if (apiItem.length) {\n            const replaceParams: {\n              [num: number]: string;\n            } = {};\n            for (let fry = 0; fry < apiItem.length; fry++) {\n              const arg = apiItem[fry];\n              replaceParams[fry] = '{' + arg + '}';\n              if (params[arg] === undefined) {\n                throw new Error(\n                  '`' + arg + '`' + ' url api argument is not specified',\n                );\n              }\n            }\n            if (url) {\n              url = template(url, replaceParams);\n            }\n          }\n          // Transfer part of the parameters from `params` to the URL string\n          if (params) {\n            const paramArray = [];\n            const paramList = params.paramList;\n            if (Array.isArray(paramList)) {\n              delete params.paramList;\n              paramList.forEach((x) => {\n                paramArray.push(`${x[0]}=${x[1]}`);\n              });\n            }\n            for (const p in params) {\n              if (apiItem.indexOf(p) === -1) {\n                paramArray.push(`${p}=${params[p]}`);\n              }\n            }\n            if (paramArray.length) {\n              url = url + '?' + paramArray.join('&');\n            }\n          }\n          if (url) {\n            resolve(opt.connector.makeQuery(url, params, opt.requestOptions));\n          } else {\n            reject(new Error('request url is not set'));\n          }\n        } else {\n          resolve(undefined);\n        }\n      })\n      .catch((er) => {\n        reject(er);\n      });\n  });\n}\n","import { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { objectRemoveEmpty } from '@nextgis/utils';\nimport { fixUrlStr } from '@nextgis/utils';\nimport Cache from '@nextgis/cache';\n\nimport { loadData } from './utils/loadData';\nimport { template } from './utils/template';\nimport { NgwError } from './errors/NgwError';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\nimport { InsufficientPermissionsError } from './errors/InsufficientPermissionsError';\nimport {\n  addConnector,\n  findConnector,\n  removeConnector,\n} from './activeConnectors';\nimport { ResourcesControl } from './ResourcesControl';\n\nimport type { DeepPartial } from '@nextgis/utils';\nimport type {\n  DeleteRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  PostRequestItemsResponseMap,\n  GetRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  ResourceIdKeynameDef,\n  NgwConnectorOptions,\n  ResourceDefinition,\n  RequestItemsParams,\n  RequestItemKeys,\n  RequestHeaders,\n  RequestOptions,\n  PyramidRoute,\n  Credentials,\n  UserInfo,\n  Params,\n} from './interfaces';\nimport type { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport type { ResourceItem, Resource } from './types/ResourceItem';\nimport { apiRequest } from './utils/apiRequest';\n\nlet ID = 0;\n\nexport class NgwConnector {\n  static errors = {\n    NgwError,\n    ResourceNotFoundError,\n  };\n  id = ID++;\n\n  emitter = new EventEmitter();\n  user?: UserInfo;\n\n  resources!: ResourcesControl;\n\n  private routeStr = '/api/component/pyramid/route';\n\n  constructor(public options: NgwConnectorOptions) {\n    const exist = findConnector(options);\n    if (exist) {\n      return exist;\n    } else {\n      if (this.options.route) {\n        this.routeStr = this.options.route;\n      }\n      this.resources = new ResourcesControl(this);\n      addConnector(this);\n    }\n  }\n\n  static create(options: NgwConnectorOptions): NgwConnector {\n    return new this(options);\n  }\n\n  /**\n   * Fast way to specify the connection address to NextGIS Web.\n   * The current connection will be severed.\n   * @param baseUrl - NGW url\n   */\n  setNgw(baseUrl: string): void {\n    this.logout();\n    this.options.baseUrl = baseUrl;\n    addConnector(this);\n  }\n\n  /**\n   * Establishing a connection with NextGIS Web to fulfill all other requests.\n   * @remarks\n   * This method need not be called manually as it is used when forming a request in {@link NgwConnector.apiRequest | apiRequest}.\n   * Can be used to check connection.\n   * @example\n   * ```javascript\n   * const connector = new NgwConnector({baseUrl: 'https://demo.nextgis.com'});\n   * connector.connect()\n   *   .then(() => console.log('Ok'))\n   *   .catch((er) => console.log('Connection problem', er));\n   * ```\n   */\n  connect(): CancelablePromise<PyramidRoute> {\n    const cache = new Cache();\n    const auth = this.options.auth;\n    const makeConnect = () =>\n      new CancelablePromise((resolve, reject) => {\n        const makeQuery = () => {\n          return this.makeQuery(this.routeStr, {}, {})\n            .then((route: PyramidRoute) => {\n              resolve(route);\n            })\n            .catch((er) => {\n              reject(er);\n            });\n        };\n        if (auth) {\n          const { login, password } = auth;\n          if (login && password) {\n            return this.getUserInfo({ login, password })\n              .then(() => {\n                makeQuery();\n              })\n              .catch((er) => reject(er));\n          }\n        }\n        return makeQuery();\n      });\n    return cache.add('route', makeConnect, {\n      id: this.id,\n      auth,\n      baseUrl: this.options.baseUrl,\n    });\n  }\n\n  /**\n   * Quick way to change NextGIS Web user.\n   * @param credentials - New user credentials\n   */\n  login(credentials: Credentials): CancelablePromise<UserInfo> {\n    this.logout();\n    addConnector(this);\n    return this.getUserInfo(credentials);\n  }\n\n  /**\n   * Disconnecting a user. Aborting all current requests\n   */\n  logout(): void {\n    removeConnector(this);\n    this.options.auth = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n    this.resources.cache.clean();\n  }\n\n  getUserInfo(credentials?: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials),\n      // withCredentials: true\n    };\n\n    // Do not use request('auth.current_user') to avoid circular-references\n    return this.makeQuery('/api/component/auth/current_user', {}, options)\n      .then((data: UserInfo) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch((er) => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  /**\n   * Obtaining the required Headers for authentication of requests in the NGW.\n   */\n  getAuthorizationHeaders(\n    credentials?: Credentials,\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client,\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials): string | undefined {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      const str = unescape(encodeURIComponent(`${login}:${password}`));\n      // @ts-ignore\n      if (__BROWSER__) {\n        return window.btoa(str);\n      } else {\n        return Buffer.from(str).toString('base64');\n      }\n    }\n  }\n\n  /**\n   * Send request to NGW api router.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param params - Request item params or query params\n   * @param requestOptions - Request options\n   *\n   * @example\n   * ```javascript\n   *\n   * // there is such an NGW route item\n   * // \"feature_layer.feature.item\": [\n   * //   \"/api/resource/{0}/feature/{1}\",\n   * //   \"id\",\n   * //   \"fid\"\n   * // ],\n   *\n   * const connector = new NgwConnector({ baseUrl: 'https://example.nextgis.com' });\n   * connector.apiRequest('feature_layer.feature.item', {\n   *   // request params for {0} and {1}\n   *   'id': 2011,\n   *   'fid': 101,\n   *   // query params\n   *   'srs': 4326,\n   *   'geom_format': 'geojson',\n   * }, { method: 'GET' });\n   * // send get-request to 'https://example.nextgis.com/api/resource/2011/feature/101?srs=4326&geom_format=geojson'\n   *\n   * ```\n   */\n  apiRequest<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys,\n  >(\n    name: K,\n    params_: RequestItemsParams<K> = {},\n    requestOptions: RequestOptions = {},\n  ): CancelablePromise<P[K]> {\n    const { method, headers, withCredentials, responseType } = requestOptions;\n    const params = objectRemoveEmpty(params_);\n    const makeApiRequest = () =>\n      apiRequest({ name, params, requestOptions, connector: this });\n    if (requestOptions.cache && method === 'GET') {\n      const cache = new Cache<CancelablePromise<P[K]>>();\n      return cache.add(name, makeApiRequest, {\n        params,\n        ...objectRemoveEmpty({\n          headers,\n          withCredentials,\n          responseType,\n          baseUrl: this.options.baseUrl,\n          auth: this.options.auth,\n        }),\n      });\n    }\n    return makeApiRequest();\n  }\n\n  /**\n   * Shortcut method for send POST request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   *\n   * @example\n   * ```javascript\n   * connector.post('resource.collection', { data: POST_PAYLOAD })\n   *   .then((newResource) => console.log(newResource))\n   *   .catch((error) => console.warn(error));\n   * ```\n   */\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    return this.apiRequest<K, PostRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send GET request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    return this.apiRequest<K, GetRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PATCH request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    return this.apiRequest<K, PatchRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PUT request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    return this.apiRequest<K, PutRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send DELETE request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    return this.apiRequest<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Send request to NGW.\n   * @param url - URL address to NGW\n   * @param params - Query params\n   * @param options - Request options\n   */\n  makeQuery(\n    url: string,\n    params?: Params,\n    options: RequestOptions = {},\n  ): CancelablePromise<any> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = fixUrlStr(url);\n      return this._loadData(url, options);\n    } else {\n      throw new Error('Empty `url` not allowed');\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * {@inheritDoc ResourcesControl.getOne}\n   */\n  getResource(\n    resource: ResourceDefinition,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getOneOrFail}\n   */\n  getResourceOrFail(\n    resource: ResourceDefinition,\n  ): CancelablePromise<ResourceItem> {\n    return this.resources.getOneOrFail(resource);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceBy(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceByKeyname(\n    keyname: string,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(keyname);\n  }\n\n  /**\n   * @deprecated - use {@link NgwConnector.getResource}\n   */\n  getResourceById(id: number): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(id);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getId}\n   */\n  getResourceId(\n    resource: ResourceDefinition,\n  ): CancelablePromise<number | undefined> {\n    return this.resources.getId(resource);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getIdOrFail}\n   */\n  getResourceIdOrFail(resource: ResourceDefinition): CancelablePromise<number> {\n    return this.resources.getIdOrFail(resource);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getMany}\n   */\n  getResourcesBy(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getMany(resource);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getParent}\n   */\n  getResourceParent(\n    resource: ResourceDefinition,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getParent(resource);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.getChildrenOf}\n   */\n  getResourceChildren(\n    resource: ResourceDefinition,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getChildrenOf(resource);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.update}\n   */\n  updateResource(\n    resource: ResourceIdKeynameDef,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.update(resource, data);\n  }\n\n  /**\n   * {@inheritDoc ResourcesControl.delete}\n   */\n  deleteResource(resource: ResourceIdKeynameDef): CancelablePromise<void> {\n    return this.resources.delete(resource);\n  }\n\n  /**\n   * @internal\n   */\n  protected _loadData(\n    url: string,\n    options: RequestOptions,\n  ): CancelablePromise<any> {\n    options.responseType = options.responseType || 'json';\n    return new CancelablePromise((resolve, reject, onCancel) => {\n      if (this.user) {\n        options = options || {};\n        // options.withCredentials = true;\n        options.headers = {\n          ...this.getAuthorizationHeaders(),\n          ...options.headers,\n        };\n      }\n      loadData(url, resolve, options, reject, onCancel);\n    }).catch((httpError) => {\n      if (httpError instanceof CancelablePromise.CancelError) {\n        // not need to handle cancel error because onCancel method is used\n      } else {\n        // @ts-ignore\n        if (__DEV__) {\n          console.warn(httpError);\n        }\n        const er = this._handleHttpError(httpError);\n        if (er) {\n          throw er;\n        }\n      }\n    });\n  }\n\n  private _handleHttpError(er: Error) {\n    if (er) {\n      if (er instanceof NgwError) {\n        if (er.exception === 'nextgisweb.resource.exception.ResourceNotFound') {\n          throw new ResourceNotFoundError(er);\n        } else if (\n          er.exception === 'nextgisweb.core.exception.InsufficientPermissions'\n        ) {\n          throw new InsufficientPermissionsError(er);\n        }\n      }\n    }\n    return er;\n  }\n}\n","/**\n * A lightweight HTTP client optimized for use with {@link http://docs.nextgis.ru/docs_ngweb_dev/doc/developer/toc.html | NextGIS Web} API\n *\n * @remarks\n * Make sure CORS is registered in the {@link https://docs.nextgis.com/docs_ngcom/source/CORS.html | NextGIS Web settings } to be able to send requests.\n *\n * @packageDocumentation\n * @module ngw-connector\n */\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\n// export { NgwConnector };\nexport default NgwConnector;\n"],"names":["NgwError","er","Object","assign","setPrototypeOf","prototype","Error","loadData","NetworkError","url","message","location","origin","callback","options","error","onCancel","method","xhr","XMLHttpRequest","open","responseType","getResponseText","JSON","parse","responseText","processingResponse","forError","cb","response","onload","indexOf","status","onerror","upload","onprogress","e","lengthComputable","percentComplete","loaded","total","onProgress","data","headers","h","header","setRequestHeader","undefined","withCredentials","file","FormData","append","d","stringify","abort","send","templateRe","template","str","replace","s","key","value","ResourceNotFoundError","obj","InsufficientPermissionsError","CONNECTORS","addConnector","connector","push","isObject","val","toString","call","resourceToQuery","resource","prefix","query","entries","forEach","children","defined","ResourcesControl","Cache","requestOptions","add","_fetchResourceBy","keyname","_fetchResourceById","CancelablePromise","this","getOne","then","res","id","getId","resp","_resourceCacheFilter","items","length","get","serialization","resources","x","cache","getResource","child","parent","i","put","delete","catch","getMany","matchAll","filter","res1","res2","objectDeepEqual","apiRequest","opt","params","resolve","reject","connect","apiItems","apiItem","name","shift","replaceParams","fry","arg","paramArray","paramList","p","Array","isArray","join","makeQuery","ID","NgwConnector","EventEmitter","exist","find","baseUrl","auth","findConnector","route","routeStr","logout","login","password","getUserInfo","credentials","index","splice","user","emitter","emit","clean","getAuthorizationHeaders","client","makeClientId","Authorization","unescape","encodeURIComponent","window","btoa","params_","objectRemoveEmpty","makeApiRequest","fixUrlStr","_loadData","getOneOrFail","getIdOrFail","getParent","getChildrenOf","update","httpError","_handleHttpError","exception"],"sourceRoot":""}