{"version":3,"file":"main-f6f28301e44906e.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/WebmapLayerOpacityPropertyHandler.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowNgwAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/BookmarkItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/constants.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/createPopupContent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createGeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createRasterAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createNgwWebmapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwResource.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createBasemapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createAsyncAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwExtent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeature.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatureCollection.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatures.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItems.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getCompanyLogo.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/IdentifyItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/identifyUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/ngwApiToAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/prepareNgwFieldsToPropertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/utils.ts"],"sourcesContent":["import NgwConnector from '@nextgis/ngw-connector';\n\nimport { extendNgwWebmapLayerAdapter } from './utils/utils';\nimport { NgwWebmapLayerAdapter } from './NgwWebmapLayerAdapter';\nimport { classAdapters } from './adapters/createAsyncAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, StarterKit, LayerAdapterCreators } from '@nextgis/webmap';\nimport type {\n  NgwKitOptions,\n  GetClassAdapter,\n  NgwWebmapAdapterOptions,\n} from './interfaces';\n\nexport class NgwKit implements StarterKit {\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl || '';\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth,\n      });\n    }\n  }\n\n  static addClassAdapters(cls: string, adapter: GetClassAdapter): void {\n    classAdapters[cls] = adapter;\n  }\n\n  async onLoadSync(webMap: WebMap): Promise<NgwWebmapLayerAdapter | undefined> {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: Partial<NgwWebmapAdapterOptions> = {\n            resourceId: r,\n            connector: this.connector,\n            webMap,\n          };\n          const layer = (await webMap.addLayer(NgwWebmapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            pixelRadius: this.options.pixelRadius,\n            ...options,\n          })) as NgwWebmapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap)),\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<NgwWebmapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendNgwWebmapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl,\n    });\n  }\n}\n","import { BaseProperty } from '@nextgis/item';\nimport type { ItemBasePropertyOptions } from '../../../item/src/interfaces';\nimport type { NgwWebmapItem } from '../NgwWebmapItem';\n\ntype VAL = number;\n\nexport class WebmapLayerOpacityPropertyHandler<\n  V extends VAL = VAL,\n> extends BaseProperty<VAL, ItemBasePropertyOptions<VAL>, NgwWebmapItem> {\n  getProperty(): number {\n    const layer = this.item.layer;\n    if (layer) {\n      return layer && layer.options && layer.options.opacity !== undefined\n        ? layer.options.opacity\n        : 1;\n    }\n    return 1;\n  }\n\n  update(value: V, options?: ItemBasePropertyOptions<VAL>): void {\n    options = options || {};\n\n    if (this.isGroup()) {\n      this._value = this._prepareValue(value, options);\n      const children = this.getChildren();\n      for (const child of children) {\n        const property = child.properties.property(this.name);\n        if (property) {\n          if (options.propagation) {\n            property.set(value, options);\n          } else {\n            property.update(property.get(), options);\n          }\n        }\n      }\n    }\n    const layer = this.item.layer;\n    if (layer) {\n      const parents = this.getParents();\n      const coef = parents.reduce((s, x) => {\n        const prop = x.properties.property(this.name);\n        const multiplier = prop ? prop.getValue() : 1;\n        return s * multiplier;\n      }, 1);\n      const val = value * coef;\n      this.item.webMap.setLayerOpacity(layer, this._prepareValue(val));\n    }\n  }\n\n  protected _prepareValue(\n    value: number,\n    options?: ItemBasePropertyOptions<VAL>,\n  ): number {\n    if (options && options.propagation && this.isGroup()) {\n      return 1;\n    }\n    // value = Number(value);\n    // return value < 0.1 ? 0.1 : value;\n    return Number(value);\n  }\n}\n","import { EventEmitter } from 'events';\nimport { Item } from '@nextgis/item';\nimport { treeSome } from '@nextgis/tree';\nimport {\n  WebMap,\n  LayerAdapter,\n  ImageAdapterOptions,\n  LayerAdapterDefinition,\n} from '@nextgis/webmap';\nimport { objectAssign } from '@nextgis/utils';\n\nimport { setScaleRatio } from './utils/utils';\nimport { WebmapLayerOpacityPropertyHandler } from './utils/WebmapLayerOpacityPropertyHandler';\n\nimport type { ItemOptions } from '@nextgis/item';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { TreeGroup, TreeLayer, TreeItem } from './interfaces';\n\nexport class NgwWebmapItem extends Item<ItemOptions> {\n  static GetAdapterFromLayerType: {\n    [layerType: string]: (\n      item: TreeItem,\n      options: any,\n      webMap: WebMap,\n      connector?: NgwConnector,\n    ) => LayerAdapterDefinition;\n  } = {};\n\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: NgwWebmapItem): boolean {\n          if (item) {\n            if (\n              item.item.item_type === 'group' ||\n              item.item.item_type === 'root'\n            ) {\n              return treeSome<TreeGroup | TreeLayer>(\n                item.item,\n                (i) => ('layer_enabled' in i ? i.layer_enabled : false),\n                (i) => (i as TreeGroup).children,\n              );\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            }\n            // else if (item.item.item_type === 'root') {\n            //   return true;\n            // }\n          }\n          return false;\n        },\n        onSet(\n          value: boolean,\n          options?: Record<string, any>,\n          item?: NgwWebmapItem,\n        ): void {\n          if (item && item.item.item_type === 'layer') {\n            if (item.layer) {\n              if (value) {\n                item.webMap.showLayer(item.layer);\n              } else {\n                item.webMap.hideLayer(item.layer);\n              }\n            }\n            item.item['layer_enabled'] = value;\n          }\n        },\n      },\n      {\n        name: 'opacity',\n        handler: WebmapLayerOpacityPropertyHandler,\n      },\n    ],\n  };\n\n  item: TreeGroup | TreeLayer;\n  connector?: NgwConnector;\n  layer?: LayerAdapter;\n  readonly emitter = new EventEmitter();\n\n  protected _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n    noInit?: boolean,\n  ) {\n    super({ ...NgwWebmapItem.options, ...options });\n    if (connector) {\n      this.connector = connector;\n    }\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n    this.initProperties();\n    if (!noInit) {\n      this._init(item);\n    }\n  }\n\n  static async create(\n    webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n  ): Promise<NgwWebmapItem> {\n    const ngwWebmapItem = new NgwWebmapItem(\n      webMap,\n      item,\n      options,\n      connector,\n      parent,\n      true,\n    );\n    await ngwWebmapItem._init(item);\n    return ngwWebmapItem;\n  }\n\n  initItem(item: TreeGroup | TreeLayer): Promise<void> {\n    const i = item;\n    const options: Partial<ImageAdapterOptions> = this.getItemOptions(item);\n    const setNewLayer = (l: LayerAdapter) => {\n      i._layer = l;\n      this.layer = l;\n      const enabled = this.properties.get('visibility');\n      if (enabled) {\n        this.properties.set('visibility', true);\n      }\n\n      if (options.opacity !== undefined) {\n        this.webMap.setLayerOpacity(l, options.opacity);\n      }\n    };\n\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        this.getChildren(item).forEach((x) => {\n          const children = new NgwWebmapItem(\n            this.webMap,\n            x,\n            this.options,\n            this.connector,\n            this,\n          );\n          this.tree.addChild(children);\n        });\n      }\n      return Promise.resolve();\n    } else {\n      let adapter: LayerAdapterDefinition | undefined;\n      if (item.item_type === 'layer') {\n        adapter = item.adapter || item.layer_adapter.toUpperCase();\n      } else if (NgwWebmapItem.GetAdapterFromLayerType[item.item_type]) {\n        const getAdapter =\n          NgwWebmapItem.GetAdapterFromLayerType[item.item_type];\n        adapter = getAdapter(item, options, this.webMap, this.connector);\n      }\n\n      if (adapter) {\n        return this.webMap.addLayer(adapter, options).then((newLayer) => {\n          setNewLayer(newLayer);\n        });\n      }\n    }\n    if (item._layer) {\n      return Promise.resolve(setNewLayer(item._layer));\n    }\n    return Promise.reject('No layer added');\n  }\n\n  bringToFront(): void {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      // console.log(this.item);\n    }\n  }\n\n  getLayer() {\n    return this.layer;\n  }\n\n  protected getItemOptions(item: TreeGroup | TreeLayer): Record<string, any> {\n    const transparency = item.item_type === 'layer' && item.layer_transparency;\n    const opacity =\n      typeof transparency === 'number' ? (100 - transparency) / 100 : undefined;\n    const options: Partial<ImageAdapterOptions> = {\n      visibility: false,\n      headers: this.options.headers,\n      crossOrigin: this.options.crossOrigin,\n      setViewDelay: this.options.setViewDelay,\n      params: { resource: this.item.resourceId },\n    };\n    if (this.options.order) {\n      const subOrder =\n        this.options.drawOrderEnabled && 'draw_order_position' in item\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n\n      // 9 > 0009, 11 > 0011\n      // TODO: find better way to set order in sub level, not limit by 1000 layer in group\n      const subLevel = String(subOrder).padStart(4, '0');\n      options.order = Number((this.options.order | 0) + '.' + subLevel);\n    }\n    if (item.item_type === 'layer') {\n      const { maxZoom, minZoom } = this._getZoomRange(item);\n\n      objectAssign(options, {\n        updateWmsParams: item.updateWmsParams,\n        url: item.url,\n        headers: this.options.headers,\n        ratio: this.options.ratio,\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n      });\n    }\n    if (opacity !== undefined) {\n      options.opacity = opacity;\n    }\n    return options;\n  }\n\n  protected getChildren(item: TreeGroup): (TreeGroup | TreeLayer)[] {\n    return [...item.children].reverse();\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private _getZoomRange(item: TreeLayer) {\n    const minZoomMap = this.webMap.options.minZoom;\n    const maxZoomMap = this.webMap.options.maxZoom;\n\n    const minZoomWebmap = this.options.minZoom;\n    const maxZoomWebmap = this.options.maxZoom;\n\n    const minZoomLayer = item.layer_min_scale_denom\n      ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n      : undefined;\n    const maxZoomLayer = item.layer_max_scale_denom\n      ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n      : undefined;\n\n    const minZooms = [minZoomMap, minZoomWebmap, minZoomLayer].filter(\n      Boolean,\n    ) as number[];\n    const maxZooms = [maxZoomMap, maxZoomWebmap, maxZoomLayer].filter(\n      Boolean,\n    ) as number[];\n    const minZoom = Math.max(...minZooms);\n    const maxZoom = Math.min(...maxZooms);\n    return { minZoom, maxZoom };\n  }\n\n  private _init(item: TreeGroup | TreeLayer) {\n    this.initItem(item).then(() => {\n      this.emitter.emit('init');\n    });\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import type { WebMap, MainLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport type { Type } from '@nextgis/utils';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  adapterOptions?: Record<string, any>;\n  onLayerAdded?: <L extends MainLayerAdapter = MainLayerAdapter>(\n    layer: L,\n  ) => void;\n  createAdapter: (\n    firstShowAdapter: FirstShowAdapter,\n  ) => Promise<Type<MainLayerAdapter> | undefined>;\n}\n\ninterface FirstShowAdapter extends MainLayerAdapter {\n  loadLayer: () => Promise<MainLayerAdapter[]>;\n  destroyed: () => boolean;\n}\n\nexport async function createOnFirstShowAdapter({\n  webMap,\n  adapterOptions = {},\n  onLayerAdded,\n  createAdapter,\n}: CreateOnFirstShowAdapterOptions): Promise<Type<FirstShowAdapter>> {\n  class OnFirstShowAdapter implements MainLayerAdapter {\n    options: AdapterOptions = {};\n    layer: MainLayerAdapter[] = [];\n    _removed = false;\n    _creatingInProgress = false;\n\n    addLayer() {\n      return this.layer;\n    }\n\n    removeLayer() {\n      this._removed = true;\n      this.layer.forEach((x) => webMap.removeLayer(x));\n    }\n\n    destroyed() {\n      return this._removed;\n    }\n\n    async showLayer() {\n      this.options.visibility = true;\n      if (this.layer.length) {\n        for (const x of this.layer) {\n          await webMap.showLayer(x);\n        }\n      } else {\n        await this.loadLayer();\n      }\n    }\n\n    async hideLayer() {\n      this.options.visibility = false;\n      if (this.layer) {\n        for (const x of this.layer) {\n          await webMap.hideLayer(x);\n        }\n      }\n    }\n\n    async loadLayer() {\n      if (!this.layer.length && !this._creatingInProgress) {\n        this._creatingInProgress = true;\n        const Adapter = await createAdapter(this);\n        if (Adapter) {\n          const adapter = new Adapter(webMap.mapAdapter.map, {\n            ...adapterOptions,\n          });\n          const realLayer: MainLayerAdapter = await adapter.addLayer({\n            order: this.options.order,\n            headers: this.options.headers,\n            baselayer: this.options.baselayer,\n          });\n          if (onLayerAdded) {\n            onLayerAdded(adapter);\n          }\n          Object.assign(adapter.options, adapterOptions);\n          adapter.layer = realLayer;\n          if (this._removed) {\n            webMap.removeLayer(adapter);\n          }\n          this.layer.push(adapter);\n          if (this.options.visibility) {\n            await webMap.showLayer(adapter);\n          }\n          this._creatingInProgress = false;\n        }\n      }\n      return this.layer;\n    }\n  }\n  return OnFirstShowAdapter;\n}\n","import { Type } from '@nextgis/utils';\nimport { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport NgwConnector, { BasemapWebmapItem } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from './createAsyncAdapter';\nimport { createOnFirstShowAdapter } from './createOnFirstShowAdapter';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  item: BasemapWebmapItem;\n  adapterOptions?: Record<string, any>;\n  idPrefix?: string;\n}\n\nexport async function createOnFirstShowNgwAdapter({\n  webMap,\n  connector,\n  item,\n  adapterOptions = {},\n  idPrefix = 'first-show-adapter',\n}: CreateOnFirstShowAdapterOptions): Promise<Type<MainLayerAdapter>> {\n  const createAdapter = () => {\n    return createAsyncAdapter(\n      {\n        resource: item.resource_id,\n        adapterOptions: {\n          name: item.display_name,\n          opacity: item.opacity,\n        },\n      },\n      webMap,\n      connector,\n    );\n  };\n  const onLayerAdded = (adapter: MainLayerAdapter) => {\n    adapter.options.baselayer = false;\n    adapter.id = idPrefix + '-' + item.resource_id;\n  };\n\n  const OnFirstNgwShowAdapter = createOnFirstShowAdapter({\n    webMap,\n    adapterOptions,\n    onLayerAdded,\n    createAdapter,\n  });\n\n  return OnFirstNgwShowAdapter;\n}\n","import { Feature, Point } from 'geojson';\nimport { createGeoJsonFeature, fetchNgwLayerItem } from '@nextgis/ngw-kit';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\ninterface BookmarkItemOptions {\n  connector: NgwConnector;\n  resourceId: number;\n  item: FeatureItem;\n  labelField?: string;\n}\n\nexport class BookmarkItem {\n  readonly name: string;\n  readonly resourceId: number;\n  readonly item: FeatureItem;\n\n  private _extent?: LngLatBoundsArray;\n\n  constructor(private options: BookmarkItemOptions) {\n    this.resourceId = options.resourceId;\n    const item = options.item;\n    this.item = item;\n    if (options.labelField && item.fields) {\n      this.name = item.fields[options.labelField];\n    } else {\n      this.name = String(item.id);\n    }\n  }\n\n  extent(): CancelablePromise<LngLatBoundsArray> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return this.options.connector\n      .get('feature_layer.feature.item_extent', null, {\n        id: this.resourceId,\n        fid: this.item.id,\n      })\n      .then((resp) => {\n        const { minLat, minLon, maxLat, maxLon } = resp.extent;\n        const lonLat = [minLon, minLat, maxLon, maxLat];\n        this._extent = lonLat;\n        return lonLat;\n      });\n  }\n\n  geoJson(): CancelablePromise<Feature<Point, any>> {\n    if (this.item.geom) {\n      return CancelablePromise.resolve(createGeoJsonFeature(this.item));\n    } else {\n      return fetchNgwLayerItem({\n        resourceId: this.resourceId,\n        featureId: this.item.id,\n        connector: this.options.connector,\n        geom: true,\n        fields: null,\n        extensions: null,\n      }).then((onlyGeomItem) => {\n        const geom = onlyGeomItem.geom;\n        this.item.geom = geom;\n        return createGeoJsonFeature(this.item);\n      });\n    }\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  fetchNgwLayerItems,\n  WEBMAP_BASELAYER_ID_PREFIX,\n} from '@nextgis/ngw-kit';\n\nimport { NgwWebmapItem } from './NgwWebmapItem';\nimport { createOnFirstShowNgwAdapter } from './adapters/createOnFirstShowNgwAdapter';\nimport { ngwApiToAdapterOptions } from './utils/ngwApiToAdapterOptions';\nimport { getNgwWebmapExtent } from './utils/fetchNgwExtent';\nimport { updateImageParams } from './utils/utils';\nimport { BookmarkItem } from './BookmarkItem';\n\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type { Type, LngLatBoundsArray } from '@nextgis/utils';\nimport type { ItemOptions } from '@nextgis/item';\nimport type {\n  WebmapResource,\n  BasemapWebmap,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport type { WebMap, RasterAdapterOptions } from '@nextgis/webmap';\nimport type {\n  TreeGroup,\n  TreeLayer,\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  NgwWebmapAdapterOptions,\n  NgwWebmapLayerAdapterEvents,\n} from './interfaces';\n\nexport class NgwWebmapLayerAdapter<M = any> implements ResourceAdapter<M> {\n  layer?: NgwWebmapItem;\n\n  NgwWebmapItem: Type<NgwWebmapItem> = NgwWebmapItem;\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  webmapClassName = 'webmap';\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwWebmapLayerAdapterEvents\n  > = new EventEmitter();\n  protected _extent?: LngLatBoundsArray;\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  constructor(public map: M, public options: NgwWebmapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: NgwWebmapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n    this.layer = await this._getWebMapLayerItem();\n    return this.layer;\n  }\n\n  removeLayer(): void {\n    const mapAdapter = this.options.webMap.mapAdapter;\n\n    this.getDependLayers().forEach((x) => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    // delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  async showLayer(): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  async hideLayer(): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  async setOpacity(val: number): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('opacity').set(val);\n    }\n  }\n\n  /** @deprecated use {@link NgwWebmapLayerAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getNgwWebmapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<NgwWebmapItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  getBookmarksResourceId(): number | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return webmap.bookmark_resource.id;\n    }\n  }\n\n  fetchBookmarks(): CancelablePromise<BookmarkItem[]> {\n    const bookmarkResId = this.getBookmarksResourceId();\n    const connector = this.options.connector;\n    if (bookmarkResId) {\n      return connector.getResourceOrFail(bookmarkResId).then((item) => {\n        const labelField = item.feature_layer?.fields.find(\n          (x) => x.label_field,\n        );\n        const keyname = labelField && labelField.keyname;\n        return fetchNgwLayerItems({\n          connector,\n          resourceId: bookmarkResId,\n          geom: false,\n          fields: keyname ? [keyname] : undefined,\n        }).then((items) => {\n          const bookmarks: BookmarkItem[] = [];\n          for (const i of items) {\n            const bookmark = new BookmarkItem({\n              item: i,\n              resourceId: bookmarkResId,\n              labelField: keyname,\n              connector,\n            });\n            bookmarks.push(bookmark);\n          }\n          return bookmarks;\n        });\n      });\n    }\n    throw new Error(\n      'Webmap was not loaded correctly, it is impossible to extract bookmarks',\n    );\n  }\n\n  async getIdentificationIds(): Promise<number[]> {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => b.id - a.id);\n      deps.forEach((x) => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  protected async _getWebMapLayerItem(): Promise<NgwWebmapItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<NgwWebmapItem>((resolve) => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.setViewDelay = this.options.setViewDelay;\n          options.order = this.options.order;\n          options.ratio = this.options.ratio;\n          options.crossOrigin = this.options.crossOrigin;\n          options.minZoom = this.options.minZoom;\n          options.maxZoom = this.options.maxZoom;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new this.NgwWebmapItem(\n            this.options.webMap,\n            webmap.root_item,\n            options,\n            this.options.connector,\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    const data = await this.options.connector.getResource(id);\n    if (data) {\n      this.response = data;\n      const webmap = data[\n        this.webmapClassName as keyof ResourceItem\n      ] as WebmapResource;\n      if (data.basemap_webmap && data.basemap_webmap.basemaps.length) {\n        this._setBasemaps(data.basemap_webmap);\n      } else if (this.options.defaultBasemap) {\n        const webMap = this.options.webMap;\n        webMap.addBaseLayer('OSM', {\n          id: 'webmap-default-baselayer',\n          name: 'OpenStreetMap',\n        });\n      }\n      if (webmap) {\n        this._extent = [\n          webmap.extent_left,\n          webmap.extent_bottom,\n          webmap.extent_right,\n          webmap.extent_top,\n        ];\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    }\n  }\n\n  private _setBasemaps(baseWebmap: BasemapWebmap) {\n    const webMap = this.options.webMap;\n    let enabledAlreadySet = false;\n    baseWebmap.basemaps.forEach((x) => {\n      createOnFirstShowNgwAdapter({\n        webMap,\n        connector: this.options.connector,\n        item: x,\n        adapterOptions: { crossOrigin: this.options.crossOrigin },\n      }).then((adapter) => {\n        // to avoid set many basemaps on init\n        const visibility = enabledAlreadySet ? false : x.enabled;\n        webMap.addBaseLayer(adapter, {\n          id: WEBMAP_BASELAYER_ID_PREFIX + x.resource_id,\n          name: x.display_name,\n          opacity: x.opacity,\n          visibility,\n        });\n        if (x.enabled) {\n          enabledAlreadySet = true;\n        }\n      });\n    });\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem,\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map((x) =>\n            this._updateItemsParams(x, webMap, data),\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.connector.options.baseUrl +\n            '/api/component/render/image',\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = (params) =>\n          updateImageParams(params, resourceId);\n        const adapter = item.layer_adapter.toUpperCase() as NgwLayerAdapterType;\n        const layerAdapterOptions = ngwApiToAdapterOptions({\n          options: {\n            adapter,\n            resource: resourceId,\n          },\n          webMap,\n          baseUrl: this.options.connector.options.baseUrl || '',\n        }) as RasterAdapterOptions;\n        item = {\n          ...item,\n          ...layerAdapterOptions,\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: NgwWebmapItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector.getResource(id).then((y) => {\n            if (y) {\n              const parentId = Number(y.resource.parent.id);\n              item.parentId = parentId;\n              return parentId;\n            }\n          });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter((x) => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n}\n","export const WEBMAP_BASELAYER_ID_PREFIX = 'webmap-baselayer';\n","import { Feature } from 'geojson';\nimport { ResourceItem } from '@nextgis/ngw-connector';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem,\n): HTMLElement | string {\n  if (__BROWSER__) {\n    const element = document.createElement('div');\n    if (item && item.feature_layer) {\n      item.feature_layer.fields.forEach((x) => {\n        if (x.grid_visibility) {\n          const value = feature.properties && feature.properties[x.keyname];\n          if (value) {\n            const propElem = document.createElement('div');\n            element.appendChild(propElem);\n            propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n          }\n        }\n      });\n    } else if (feature.properties) {\n      for (const p in feature.properties) {\n        const propElem = document.createElement('div');\n        element.appendChild(propElem);\n        propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n      }\n    }\n    return element;\n  } else {\n    return '';\n  }\n}\n","import { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy',\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions,\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach((x) => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport type { NgwLayerOptions } from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector,\n): Promise<number> {\n  const resource = options.resource;\n  const item = resource as ResourceItem;\n\n  // @ts-ignore @deprecated\n  let { keyname, resourceId } = options;\n\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else if (\n      item.resource &&\n      item.resource !== undefined &&\n      'resource' in item\n    ) {\n      resourceId = (resource as ResourceItem).resource.id;\n    } else {\n      // TODO: safe remove this case\n      resourceId = await resourceIdFromLayerOptions(\n        resource as NgwLayerOptions,\n        connector,\n      );\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResource(keyname);\n    if (resourceItem) {\n      resourceId = resourceItem.resource.id;\n    }\n  }\n  return resourceId;\n}\n","import { EventEmitter } from 'events';\nimport { debounce, LngLatBoundsArray } from '@nextgis/utils';\nimport { propertiesFilter } from '@nextgis/properties-filter';\n\nimport { createPopupContent } from '../utils/createPopupContent';\nimport { getLayerFilterOptions } from '../utils/getLayerFilterOptions';\nimport { fetchNgwResourceExtent } from '../utils/fetchNgwExtent';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\nimport { fetchNgwLayerFeatureCollection } from '../utils/fetchNgwLayerFeatureCollection';\nimport { prepareNgwFieldsToPropertiesFilter } from '../utils/prepareNgwFieldsToPropertiesFilter';\n\nimport type { FeatureCollection } from 'geojson';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { Type } from '@nextgis/utils';\nimport type {\n  GeoJsonAdapterOptions,\n  VectorLayerAdapter,\n  FilterOptions,\n  LayerAdapter,\n} from '@nextgis/webmap';\nimport type {\n  NgwLayerOptions,\n  GetClassAdapterOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  props: GetClassAdapterOptions,\n): Promise<Type<VectorLayerAdapter>> {\n  const {\n    item,\n    webMap,\n    Adapter,\n    connector,\n    layerOptions,\n    addLayerOptionsPriority: alop,\n  } = props;\n  const addLayerOptionsPriority = alop ?? true;\n  const options = layerOptions as NgwLayerOptions<'GEOJSON'>;\n  const GeoJsonAdapter: Type<VectorLayerAdapter> =\n    Adapter || webMap.mapAdapter.layerAdapters.GEOJSON;\n\n  let _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n  let _dataPromise: CancelablePromise<FeatureCollection> | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (options.adapterOptions?.popupOptions?.fromProperties) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const getData = async (\n    filters?: PropertiesFilter,\n    filterOpt?: NgwFeatureRequestOptions,\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: filterOpt };\n    _dataPromise = fetchNgwLayerFeatureCollection({\n      resourceId,\n      filters,\n      connector,\n      cache: true,\n      ...filterOpt,\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  class NgwGeoJsonAdapter extends GeoJsonAdapter {\n    emitter = new EventEmitter();\n    _count?: number;\n    __onMapMove?: () => void;\n    __onMapMoveStart?: () => void;\n    __enableMapMoveListener?: (e: LayerAdapter) => void;\n    __disableMapMoveListener?: (e: LayerAdapter) => void;\n\n    async addLayer(opt: GeoJsonAdapterOptions) {\n      let needUpdate = !opt.data;\n      const waitFullLoad =\n        opt.waitFullLoad !== undefined ? opt.waitFullLoad : true;\n      if (options.id !== undefined) {\n        opt.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (options.adapterOptions) {\n        // TODO: remove addLayerOptionsPriority options/\n        // in some cases, addLayer options must be used,\n        // but in others factory method options needs first\n        if (addLayerOptionsPriority) {\n          opt = {\n            ...options.adapterOptions,\n            ...opt,\n          };\n        } else {\n          opt = {\n            ...opt,\n            ...options.adapterOptions,\n          };\n        }\n      }\n      if (opt.data && Object.keys(opt.data).length === 0) {\n        opt.data = undefined;\n        needUpdate = false;\n      }\n      const layer = super.addLayer(opt);\n      this.options.strategy = opt.strategy || undefined;\n\n      _lastFilterArgs = {\n        filters: opt.propertiesFilter,\n        options: getLayerFilterOptions(opt),\n      };\n      let updatePromise: Promise<any> | undefined;\n      if (needUpdate) {\n        updatePromise = this.updateLayer();\n      }\n      if (waitFullLoad && updatePromise) {\n        await updatePromise;\n      }\n      if (this.options.strategy === 'BBOX' && !_fullDataLoad) {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    /** @deprecated use {@link NgwGeoJsonAdapter.getBounds} instead */\n    getExtent(): Promise<LngLatBoundsArray | undefined> {\n      return this.getBounds();\n    }\n\n    async getBounds(): Promise<LngLatBoundsArray | undefined> {\n      const hasData = this.getLayers && this.getLayers().length;\n      if (this.options.strategy === 'BBOX' || hasData) {\n        return fetchNgwResourceExtent(item, connector);\n      } else {\n        if (super.getBounds) {\n          return super.getBounds();\n        }\n      }\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      this.__onMapMoveStart = undefined;\n      abort();\n    }\n\n    getCount() {\n      if (this._count !== undefined) {\n        return this._count;\n      }\n      return connector\n        .get(\n          'feature_layer.feature.count',\n          { cache: true },\n          {\n            id: resourceId,\n          },\n        )\n        .then((resp) => {\n          if (resp) {\n            this._count = resp.total_count;\n            return this._count;\n          }\n        });\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy === 'BBOX') {\n        await webMap.onLoad('create');\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = webMap.getBounds();\n      }\n      if (removed) {\n        return;\n      }\n      try {\n        const data = await getData(filterArgs.filters, {\n          ...filterArgs.options,\n          srs: this.options.srs,\n        });\n        const count = await this.getCount();\n        _fullDataLoad = count === data.features.length;\n        await webMap.setLayerData(this, data);\n        this.emitter.emit('updated');\n      } catch (er) {\n        if (er instanceof Error && er.name !== 'CancelError') {\n          throw er;\n        }\n      }\n      if (super.updateLayer) {\n        super.updateLayer();\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter((e) => {\n          const props_ =\n            e.feature &&\n            e.feature.properties &&\n            prepareNgwFieldsToPropertiesFilter({ ...e.feature.properties });\n          if (props_) {\n            return propertiesFilter(props_, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await getData(filters, {\n          ...opt,\n          srs: this.options.srs,\n        });\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    _addBboxEventListener() {\n      this.__enableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener(this);\n    }\n\n    _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      this.__onMapMoveStart = abort;\n      webMap.emitter.on('movestart', this.__onMapMoveStart);\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.removeListener('moveend', this.__onMapMove);\n      }\n      if (this.__onMapMoveStart) {\n        webMap.emitter.removeListener('movestart', this.__onMapMoveStart);\n      }\n    }\n  }\n\n  return NgwGeoJsonAdapter;\n}\n","import { defined } from '@nextgis/utils';\n\nimport { ngwApiToAdapterOptions } from '../utils/ngwApiToAdapterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { Type } from '@nextgis/utils';\nimport type { ResourceItem, ResourceCls } from '@nextgis/ngw-connector';\nimport type { MainLayerAdapter, ImageAdapterOptions } from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  GetClassAdapterOptions,\n} from '../interfaces';\n\nexport async function createRasterAdapter({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  const resourceCls = item.resource.cls;\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    tmsclient_layer: 'IMAGE',\n  };\n  let adapter =\n    layerOptions.adapter ||\n    (resourceCls && clsAdapterAlias[resourceCls]) ||\n    'IMAGE';\n  if (adapter !== undefined) {\n    layerOptions.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const AdapterClass = webMap.mapAdapter.layerAdapters[\n    adapter\n  ] as Type<MainLayerAdapter>;\n  if (AdapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(\n      layerOptions,\n      connector,\n    );\n    return class RasterAdapter extends AdapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem = item;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = ngwApiToAdapterOptions({\n          options: layerOptions,\n          webMap,\n          baseUrl: connector.options.baseUrl || '',\n        });\n        if (opt) {\n          const layerAdapterOptions: ImageAdapterOptions = {\n            ...opt,\n            setViewDelay: layerOptions.adapterOptions?.setViewDelay,\n            params: { resource: resourceId },\n            // @deprecated\n            layers: String(resourceId),\n            resourceId: resourceId,\n          };\n          if (\n            layerOptions.adapterOptions &&\n            defined(layerOptions.adapterOptions.setViewDelay)\n          ) {\n            layerAdapterOptions.setViewDelay =\n              layerOptions.adapterOptions.setViewDelay;\n          }\n          this.options = { ...this.options, ...layerAdapterOptions };\n          // if (__DEV__) {\n          //   Object.defineProperty(this.options, 'layers', {\n          //     get: () => {\n          //       console.warn('Do not use `layers` in ImageAdapterOptions');\n          //       return String(resourceId);\n          //     },\n          //   });\n          //   Object.defineProperty(this.options, 'resourceId', {\n          //     get: () => {\n          //       console.warn('Do not use `resourceId` in ImageAdapterOptions');\n          //       return resourceId;\n          //     },\n          //   });\n          // }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (defined(id)) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","import { NgwWebmapLayerAdapter as NWLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { Type } from '@nextgis/utils';\nimport type { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createWebMapAdapter({\n  layerOptions: options,\n  webMap,\n  connector,\n}: GetClassAdapterOptions): Promise<Type<NWLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class NgwWebmapLayerAdapter extends NWLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        url: '',\n        webMap,\n        resourceId,\n        connector,\n      });\n    }\n  };\n}\n","import { fetchNgwResourceExtent } from './utils/fetchNgwExtent';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { ResourceItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  protected _extent?: LngLatBoundsArray;\n\n  /** @deprecated use {@link NgwResource.getBounds} instead */\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    return this.getBounds();\n  }\n\n  async getBounds(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await fetchNgwResourceExtent(this.item, this.connector);\n      return this._extent;\n    }\n  }\n}\n","import { QmsKit } from '@nextgis/qms-kit';\n\nimport type { Type } from '@nextgis/utils';\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createBasemapLayerAdapter({\n  webMap,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  if (item.basemap_layer) {\n    const qms = item.basemap_layer.qms;\n    const url = item.basemap_layer.url;\n    if (qms) {\n      const qms_ = JSON.parse(qms);\n      const adapter = Promise.resolve(\n        QmsKit.utils.createQmsAdapter(webMap, undefined, {\n          qms: qms_,\n          baselayer: true,\n        }),\n      );\n      return adapter;\n    } else if (url) {\n      const TileAdapter = webMap.mapAdapter.layerAdapters.TILE as Type<\n        MainLayerAdapter<any, any, TileAdapterOptions>\n      >;\n      if (TileAdapter) {\n        class BasemapTileAdapter extends TileAdapter {\n          async addLayer(opt: TileAdapterOptions) {\n            return super.addLayer({ ...opt, url });\n          }\n        }\n        return BasemapTileAdapter;\n      }\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport { WebMap } from '@nextgis/webmap';\nimport { Type, applyMixins } from '@nextgis/utils';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createNgwWebmapAdapter';\nimport { NgwResource } from '../NgwResource';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { createBasemapLayerAdapter } from './createBasemapLayerAdapter';\n\nimport type {\n  GetClassAdapterCallback,\n  GetClassAdapterOptions,\n  GetClassAdapterByType,\n  ResourceAdapter,\n  NgwLayerOptions,\n  GetClassAdapter,\n  ClassAdapter,\n} from '../interfaces';\n\nexport const classAdapters: Record<string, GetClassAdapter> = {};\n\nconst supportCls: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'basemap_layer',\n  'vector_layer',\n  'raster_layer',\n  'webmap',\n  // in tms branch\n  'tmsclient_layer',\n];\n\nasync function createAdapterFromFirstStyle({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions) {\n  const parent = item.resource.id;\n  const childrenStyles = await connector.getResourceChildren(parent);\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...layerOptions, resource: firstStyle.resource.id },\n      webMap,\n      connector,\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: ClassAdapter | undefined;\n  let item: ResourceItem | undefined;\n  const adapterType = options.adapter;\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  if (resourceId) {\n    const resourceOptions = options as NgwLayerOptions;\n    const itemFromResOpt = resourceOptions.resource as ResourceItem;\n    if (\n      itemFromResOpt &&\n      itemFromResOpt.resource &&\n      itemFromResOpt.resource.id !== undefined\n    ) {\n      item = itemFromResOpt;\n    } else {\n      item = await connector.getResource(resourceId);\n    }\n    if (item) {\n      const cls = item.resource.cls;\n      const layerOptions: NgwLayerOptions = {\n        ...options,\n        resource: resourceId,\n      };\n\n      const adapterOptions: GetClassAdapterOptions = {\n        layerOptions,\n        webMap,\n        connector,\n        item,\n      };\n\n      if (supportCls.indexOf(cls) !== -1) {\n        if (cls === 'webmap') {\n          adapter = createWebMapAdapter(adapterOptions);\n        } else if (cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(adapterOptions);\n            } else {\n              return createAdapterFromFirstStyle(adapterOptions);\n            }\n          } else {\n            adapter = createGeoJsonAdapter(adapterOptions);\n          }\n        } else if (cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(adapterOptions);\n        } else if (cls === 'basemap_layer') {\n          adapter = createBasemapLayerAdapter(adapterOptions);\n        } else {\n          if (adapterType === 'GEOJSON') {\n            const parentItem = await connector.getResource(\n              item.resource.parent.id,\n            );\n            if (parentItem) {\n              const parentOptions: NgwLayerOptions = {\n                ...options,\n                resource: item.resource.parent.id,\n              };\n              adapter = createGeoJsonAdapter({\n                ...adapterOptions,\n                item: parentItem,\n                layerOptions: parentOptions,\n              });\n            }\n          } else {\n            adapter = createRasterAdapter(adapterOptions);\n          }\n        }\n      } else if (classAdapters[cls]) {\n        const getClassAdapter = classAdapters[cls];\n        let classAdapter: GetClassAdapterCallback | undefined;\n        if (adapterType && typeof classAdapter !== 'function') {\n          classAdapter = (getClassAdapter as GetClassAdapterByType)[\n            adapterType\n          ];\n        } else {\n          classAdapter = getClassAdapter as GetClassAdapterCallback;\n        }\n        if (classAdapter) {\n          adapter = classAdapter(adapterOptions);\n        }\n      } else {\n        throw `Resource class '${cls}' not yet supported.`;\n      }\n    } else {\n      throw 'Resource item is not found';\n    }\n  }\n\n  if (adapter) {\n    return adapter.then((x) => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        if (item) {\n          resourceAdapter.prototype.item = item;\n          resourceAdapter.prototype.resourceId = item.resource.id;\n          resourceAdapter.prototype.connector = connector;\n        }\n\n        applyMixins(resourceAdapter, [NgwResource], { replace: false });\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  checkIfPropertyFilter,\n  PropertiesFilter,\n  PropertyFilter,\n} from '@nextgis/properties-filter';\nimport {\n  defined,\n  degrees2meters,\n  getBoundsCoordinates,\n  isLngLatBoundsArray,\n} from '@nextgis/utils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type {\n  FeatureItem,\n  RequestItemAdditionalParams,\n} from '@nextgis/ngw-connector';\nimport type { LngLatArray, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureRequestParams,\n  FetchNgwItemsOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\n\nexport const FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson',\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry,\n  };\n  return feature;\n}\n\nexport function updateItemRequestParam<\n  P extends FeatureProperties = FeatureProperties,\n>(params: FeatureRequestParams, options: NgwFeatureRequestOptions<P>): void {\n  const { extensions, geom, fields, srs } = options;\n  params.extensions = extensions ? extensions.join(',') : '';\n  if (fields !== undefined) {\n    params.fields = Array.isArray(fields) ? fields.join(',') : '';\n  }\n  if (geom !== undefined) {\n    params.geom = geom ? 'yes' : 'no';\n    if (!geom) {\n      delete params.srs;\n      delete params.geom_format;\n    }\n  }\n  if (defined(srs)) {\n    params.srs = srs;\n  }\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nexport function createFeatureFieldFilterQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n  _queries: CancelablePromise<FeatureItem<P, G>[]>[] = [],\n  _parentAllParams: [string, any][] = [],\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const { filters } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter((x) => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    const isFldStr = field !== 'id' ? 'fld_' : '';\n    return [`${isFldStr}${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach((f) => {\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)],\n          }),\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f,\n          },\n          _queries,\n          [..._parentAllParams],\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filters: [string, any][] = [];\n    const propertiesFilterList: PropertiesFilter[] = [];\n    for (const f of filters_) {\n      if (checkIfPropertyFilter(f)) {\n        filters.push(createParam(f));\n      } else {\n        propertiesFilterList.push(f);\n      }\n    }\n\n    if (propertiesFilterList.length) {\n      for (const x of propertiesFilterList) {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: x,\n          },\n          _queries,\n          [..._parentAllParams, ...filters],\n        );\n      }\n    } else {\n      _queries.push(\n        fetchNgwLayerItemsRequest<G, P>({\n          ...opt,\n          paramList: [..._parentAllParams, ...filters],\n        }),\n      );\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    const offset = opt.offset !== undefined ? opt.offset : 0;\n    const limit = opt.limit !== undefined ? opt.limit : items.length;\n    if (opt.offset || opt.limit) {\n      return items.splice(offset, limit);\n    }\n    return items;\n  });\n}\n\nfunction createWktFromCoordArray(coord: LngLatArray[]): string {\n  const polygon = coord.map(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    return x + ' ' + y;\n  });\n  return `POLYGON((${polygon.join(', ')}))`;\n}\n\nexport function fetchNgwLayerItemsRequest<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  const {\n    connector,\n    limit,\n    offset,\n    intersects,\n    orderBy,\n    resourceId,\n    paramList,\n  } = options;\n  if (limit) {\n    if (limit !== Number.POSITIVE_INFINITY) {\n      params.limit = limit;\n    }\n  } else {\n    // Strict restriction on loading data from large layers\n    params.limit = 7000;\n  }\n  if (offset) {\n    params.offset = offset;\n  }\n  // TODO: fix type for options\n  updateItemRequestParam(params, options as { [field: string]: any });\n\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  if (Array.isArray(intersects)) {\n    const coordinates = isLngLatBoundsArray(intersects)\n      ? getBoundsCoordinates(intersects)\n      : intersects;\n\n    params.intersects = createWktFromCoordArray(coordinates);\n  } else if (typeof intersects === 'string') {\n    params.intersects = intersects;\n  }\n\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  const reqParams = {\n    id: resourceId,\n    ...params,\n  };\n\n  return connector.get(\n    'feature_layer.feature.collection',\n    { cache: options.cache },\n    reqParams,\n  ) as CancelablePromise<FeatureItem<P, G>[]>;\n}\n\nexport function prepareFieldsToNgw<\n  T extends FeatureProperties = FeatureProperties,\n>(\n  item: T,\n  resourceFields: Pick<FeatureProperties, 'keyname' | 'datatype'>[],\n): Record<keyof T, any> {\n  const fields = {} as Record<keyof T, any>;\n  if (item) {\n    resourceFields.forEach((x) => {\n      if (x.keyname in item) {\n        const keyname = x.keyname;\n        const prop = item[keyname];\n        let value: any;\n        if (prop !== undefined) {\n          if (x.datatype === 'STRING') {\n            value = prop ? String(prop) : null;\n            // TODO: remove after v 3.0.0. For backward compatibility\n            if (value === 'null') {\n              value = null;\n            }\n          } else if (x.datatype === 'BIGINT' || x.datatype === 'INTEGER') {\n            value = typeof prop === 'string' ? parseInt(prop, 10) : prop;\n          } else if (x.datatype === 'REAL') {\n            value = typeof prop === 'string' ? parseFloat(prop) : prop;\n          } else if (x.datatype === 'BOOLEAN') {\n            value =\n              typeof prop === 'boolean' || typeof prop === 'number'\n                ? Number(!!prop)\n                : null;\n          } else if (x.datatype === 'DATE' || x.datatype === 'DATETIME') {\n            let dt: Date | undefined;\n            if (typeof prop === 'object' && !((prop as any) instanceof Date)) {\n              value = prop;\n            } else {\n              if ((prop as any) instanceof Date) {\n                dt = prop as any;\n              } else {\n                const parse = Date.parse(String(prop));\n                if (parse) {\n                  dt = new Date(parse);\n                }\n              }\n              if (dt) {\n                value = {\n                  year: dt.getFullYear(),\n                  month: dt.getMonth(),\n                  day: dt.getDay(),\n                };\n                if (x.datatype === 'DATETIME') {\n                  value.hour = dt.getHours();\n                  value.minute = dt.getMinutes();\n                  value.second = dt.getSeconds();\n                }\n              }\n            }\n          }\n        }\n        fields[keyname as keyof T] = value ?? null;\n      }\n    });\n  }\n  return fields;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { WebmapResource, ResourceItem } from '@nextgis/ngw-connector';\nimport type {\n  FetchNgwLayerExtentOptions,\n  FetchNgwLayerItemExtentOptions,\n} from '../interfaces';\n\nexport function getNgwWebmapExtent(\n  webmap: WebmapResource,\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function fetchNgwLayerExtent({\n  resourceId,\n  connector,\n  cache = true,\n}: FetchNgwLayerExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get('layer.extent', { cache }, { id: resourceId })\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwLayerItemExtent({\n  resourceId,\n  featureId,\n  connector,\n  cache = true,\n}: FetchNgwLayerItemExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get(\n      'feature_layer.feature.item_extent',\n      { cache },\n      { id: resourceId, fid: featureId },\n    )\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return CancelablePromise.resolve(getNgwWebmapExtent(item.webmap));\n  } else {\n    const resource = item.resource;\n    if (resource.cls && resource.cls.indexOf('style') !== -1) {\n      return connector.getResource(resource.parent.id).then((res) => {\n        if (res) {\n          return fetchNgwLayerExtent({\n            resourceId: res.resource.id,\n            connector,\n          });\n        }\n      });\n    } else {\n      return fetchNgwLayerExtent({ resourceId: resource.id, connector });\n    }\n  }\n}\n","import { fetchNgwLayerItem } from './fetchNgwLayerItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FetchNgwItemOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>,\n>(options: FetchNgwItemOptions<P>): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerItem<G, P>(options).then((item) => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n","import { fetchNgwLayerFeatures } from './fetchNgwLayerFeatures';\n\nimport type { Geometry, FeatureCollection } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { FetchNgwItemsOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeatureCollection<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemsOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatures<G, P>(options).then((features) => {\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features,\n    };\n    return featureCollection;\n  });\n}\n","import { fetchNgwLayerItems } from './fetchNgwLayerItems';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<Feature<G, P>[]> {\n  return fetchNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach((y) => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    return features;\n  });\n}\n","import { Geometry } from 'geojson';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createGeoJsonFeature,\n  FEATURE_REQUEST_PARAMS,\n  updateItemRequestParam,\n} from './featureLayerUtils';\n\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  NgwFeatureItemResponse,\n  FeatureRequestParams,\n  FetchNgwItemOptions,\n} from '../interfaces';\n\nexport function fetchNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G>> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  updateItemRequestParam(params, options);\n  const queryParams = {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params,\n  };\n  const cache = options.cache || true;\n  return options.connector\n    .get('feature_layer.feature.item', { cache }, queryParams)\n    .then((resp) => {\n      return {\n        ...resp,\n        toGeojson: () => {\n          if (resp.geom) {\n            return CancelablePromise.resolve(createGeoJsonFeature<G, P>(resp));\n          } else {\n            return fetchNgwLayerItem({\n              ...options,\n              geom: true,\n              fields: null,\n              extensions: null,\n            }).then((onlyGeomItem) => {\n              const geom = onlyGeomItem.geom;\n              return createGeoJsonFeature<G, P>({ ...resp, geom });\n            });\n          }\n        },\n      } as NgwFeatureItemResponse<P, G>;\n    });\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createFeatureFieldFilterQueries,\n  fetchNgwLayerItemsRequest,\n} from './featureLayerUtils';\nimport { prepareNgwFieldsToPropertiesFilter } from './prepareNgwFieldsToPropertiesFilter';\n\nimport type { Geometry } from 'geojson';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({\n      ...options,\n      filters,\n    }).then((data) => {\n      // Additional client-side filter check\n      data.filter((y) => {\n        const fields = prepareNgwFieldsToPropertiesFilter({ ...y.fields });\n        const result = propertiesFilter(fields, filters);\n        return result;\n      });\n      return data;\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  } else {\n    return fetchNgwLayerItemsRequest<G, P>(options);\n  }\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport { CompanyLogoOptions } from '../interfaces';\n\nexport async function getCompanyLogo(\n  connector: NgwConnector,\n  options?: CompanyLogoOptions,\n): Promise<HTMLElement | undefined> {\n  const settings = await connector.get('pyramid.settings', null, {\n    component: 'pyramid',\n  });\n  if (settings && settings.company_logo && settings.company_logo.enabled) {\n    const anchor = document.createElement('a');\n    anchor.style.position = 'absolute';\n    anchor.style.bottom = '0';\n    anchor.style.right = '0';\n    anchor.style.padding = options?.padding ?? '10px';\n    anchor.className = 'ngw-map-logo';\n    if (options && options.cssClass) {\n      anchor.className += ' ' + options.cssClass;\n    }\n    const img = new Image();\n    img.style.maxHeight = '100px';\n    img.style.maxWidth = '100px';\n    img.src = '';\n    try {\n      const src = await connector.get('pyramid.company_logo', {\n        responseType: 'blob',\n      });\n      const urlCreator = window.URL || window.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(src);\n      img.src = imageUrl;\n    } catch (er) {\n      console.log(er);\n    }\n\n    if (\n      settings.company_logo.link !== null &&\n      settings.company_logo.link.trim() !== ''\n    ) {\n      anchor.href = settings.company_logo.link;\n      anchor.target = '_blank';\n      if (settings.company_logo.link.search(/:\\/\\/nextgis/) !== -1) {\n        img.alt = 'Get your own Web GIS at nextgis.com';\n      }\n    }\n    anchor.appendChild(img);\n    return anchor;\n  }\n}\n","import {\n  fetchNgwLayerItem,\n  IdentifyItemOptions,\n  fetchNgwLayerItemExtent,\n} from '.';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { NgwFeatureItemResponse } from '.';\nimport type { GeoJsonObject, Geometry, Feature } from 'geojson';\nimport type {\n  VectorLayerResourceItem,\n  FeatureItemExtensions,\n  FeatureResource,\n  LayerFeature,\n} from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureProperties, LngLatBoundsArray } from '@nextgis/utils';\nimport type { FetchNgwItemOptions } from './interfaces';\n\nexport class IdentifyItem<F = FeatureProperties, G extends Geometry = Geometry>\n  implements LayerFeature\n{\n  readonly id: number;\n  readonly label: string;\n  readonly layerId: number;\n  readonly parent: string;\n  readonly fields: FeatureProperties;\n  geom?: GeoJsonObject;\n  extensions?: FeatureItemExtensions;\n\n  private connector: NgwConnector;\n  private _item?: NgwFeatureItemResponse<F, G>;\n  private _geojson?: Feature<G, F>;\n  private _resource?: VectorLayerResourceItem;\n  private _extent?: LngLatBoundsArray;\n\n  constructor(options: IdentifyItemOptions) {\n    const f = options.feature;\n    this.id = f.id;\n    this.geom = f.geom;\n    this.label = f.label;\n    this.parent = f.parent;\n    this.fields = f.fields;\n    this.layerId = f.layerId;\n    this.connector = options.connector;\n  }\n\n  identify(\n    options: Partial<FetchNgwItemOptions<F>> = {},\n  ): CancelablePromise<NgwFeatureItemResponse<F, G>> {\n    if (this._item) {\n      return CancelablePromise.resolve(this._item);\n    }\n    return fetchNgwLayerItem<G, F>({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n      fields: null,\n      extensions: ['attachment', 'description'],\n      ...options,\n    }).then((resp) => {\n      this._item = resp;\n      this.geom = resp.geom;\n      this.extensions = resp.extensions;\n      return resp;\n    });\n  }\n\n  resource(): CancelablePromise<FeatureResource> {\n    if (this._resource) {\n      return CancelablePromise.resolve(this._resource.feature_layer);\n    }\n    return this.connector.getResource(this.layerId).then((resp) => {\n      this._resource = resp as VectorLayerResourceItem;\n      return this._resource.feature_layer;\n    });\n  }\n\n  getBounds(): CancelablePromise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return fetchNgwLayerItemExtent({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n    });\n  }\n\n  geojson(): CancelablePromise<Feature<G, F>> {\n    if (this._geojson) {\n      return CancelablePromise.resolve(this._geojson);\n    }\n    return this.identify().then((resp) => {\n      return resp.toGeojson().then((geojson) => {\n        this._geojson = geojson;\n        return geojson;\n      });\n    });\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  JsonMap,\n  degrees2meters,\n  getCirclePolygonCoordinates,\n  deprecatedMapClick,\n} from '@nextgis/utils';\nimport { IdentifyItem } from '../IdentifyItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type { MapClickEvent } from '@nextgis/webmap';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  LayerFeature,\n  FeatureLayersIdentify,\n} from '@nextgis/ngw-connector';\nimport type {\n  FeatureIdentifyRequestOptions,\n  GetIdentifyGeoJsonOptions,\n  IdentifyRequestOptions,\n  NgwFeatureItemResponse,\n  IdentifyItemOptions,\n  NgwIdentifyItem,\n  NgwIdentify,\n} from '../interfaces';\n\nexport function getIdentifyItems(\n  identify: NgwIdentify,\n  multiple = false,\n): NgwIdentifyItem[] {\n  let params:\n    | { resourceId: number; featureId: number; feature: LayerFeature }\n    | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort((a, b) => {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const identifyItem = identify[l];\n    if ('features' in identifyItem) {\n      const layerFeatures = identifyItem.features;\n      const resourceId = Number(l);\n      const feature: LayerFeature | undefined = layerFeatures[0];\n      if (feature) {\n        params = {\n          featureId: feature.id,\n          resourceId,\n          feature,\n        };\n        paramsList.push(params);\n        if (!multiple) {\n          break;\n        }\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function fetchIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      if ('features' in item) {\n        const withGeom = item.features.find((x) => x.geom);\n\n        if (withGeom && withGeom.geom) {\n          const geom = withGeom.geom as Geometry;\n          return CancelablePromise.resolve(\n            createGeoJsonFeature({\n              ...withGeom,\n              geom,\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerFeature({ connector, ...params[0] });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\nexport function fetchIdentifyItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: GetIdentifyGeoJsonOptions<G, P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n  const { connector, identify } = options;\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerItem<G, P>({\n      connector,\n      ...options.requestOptions,\n      ...params[0],\n    });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\n/**\n * @deprecated use {@link fetchIdentifyGeoJson} instead\n */\nexport function getIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  return fetchIdentifyGeoJson(options);\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  deprecatedMapClick(ev);\n  const [lng, lat] = ev.lngLat;\n\n  let geom: number[][] = [];\n\n  if (options.geom) {\n    const polygon =\n      options.geom.type === 'Feature'\n        ? options.geom.geometry\n        : options.geom.type === 'Polygon'\n        ? options.geom\n        : false;\n    if (polygon) {\n      geom = polygon.coordinates[0];\n    }\n  }\n  if (!geom.length) {\n    geom = getCirclePolygonCoordinates(lng, lat, options.radius);\n  }\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers,\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\nexport function createIdentifyItem<\n  F = FeatureProperties,\n  G extends Geometry = Geometry,\n>(opt: IdentifyItemOptions): IdentifyItem<F, G> {\n  return new IdentifyItem<F, G>(opt);\n}\n","import {\n  WebMap,\n  RasterAdapterOptions,\n  ImageAdapterOptions,\n  WmsAdapterOptions,\n} from '@nextgis/webmap';\n\nimport { NgwLayerOptions, TileNoData } from '../interfaces';\nimport { updateImageParams } from './utils';\n\nexport interface GetLayerAdapterOptions {\n  options: NgwLayerOptions;\n  webMap?: WebMap;\n  baseUrl?: string;\n}\n\nexport function ngwApiToAdapterOptions({\n  options,\n  webMap,\n  baseUrl,\n}: GetLayerAdapterOptions):\n  | RasterAdapterOptions\n  | ImageAdapterOptions\n  | undefined {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap && webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = options.resource;\n  const nd: TileNoData = options.tileNoData ? options.tileNoData : 200;\n\n  if (typeof resourceId === 'number') {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          params: { resource: resourceId, nd: nd },\n          updateWmsParams: (params: Record<string, any>) =>\n            updateImageParams({ nd: nd, ...params }, resourceId),\n        } as ImageAdapterOptions;\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      const adapterOptions = options.adapterOptions as WmsAdapterOptions;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: adapterOptions && adapterOptions.layers,\n        headers: options.headers,\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url,\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'MODEL_3D') {\n      url = baseUrl + `/api/component/model_3d/${resourceId}/data.glb`;\n      return { url };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId +\n        '&nd=' +\n        nd;\n      return { url, adapter };\n    }\n  } else if (resourceId !== undefined) {\n    throw new Error(\n      'Option `resource` must be number, not ' + typeof resourceId,\n    );\n  } else {\n    console.log('Option `resource` not set');\n  }\n}\n\n/** @deprecated use {@link ngwApiToAdapterOptions} instead */\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n): RasterAdapterOptions | ImageAdapterOptions | undefined {\n  return ngwApiToAdapterOptions({ options, webMap, baseUrl });\n}\n","import { isObject, defined } from '@nextgis/utils';\nimport type { NgwDateFormat, NgwDateTimeFormat } from '@nextgis/ngw-connector';\n\nexport function prepareNgwFieldsToPropertiesFilter(\n  fields: Record<string, any>,\n): Record<string, any> {\n  let f: keyof typeof fields;\n  for (f in fields) {\n    const field = fields[f];\n    if (isObject(field)) {\n      const date = field as NgwDateFormat | NgwDateTimeFormat;\n      if (defined(date.year) && defined(date.month) && defined(date.day)) {\n        const dt: [number, number, number, number?, number?, number?] = [\n          date.year,\n          date.month - 1,\n          date.day,\n        ];\n        if ('hour' in date) {\n          [date.hour, date.minute, date.second].forEach((x) => {\n            dt.push(x);\n          });\n        }\n        fields[f] = new Date(...dt).toISOString();\n      }\n    }\n  }\n  return fields;\n}\n","import NgwConnector, { GeometryType } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../adapters/createAsyncAdapter';\nimport { NgwWebmapLayerAdapter } from '../NgwWebmapLayerAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, VectorAdapterLayerType } from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwLayerOptions,\n  NgwWebmapAdapterOptions,\n} from '../interfaces';\n\nexport function updateImageParams(\n  params: Record<string, any>,\n  resourceId: number,\n): Record<string, any> {\n  const { bbox, width, height, nd } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now(),\n    nd,\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'point',\n  LINESTRING: 'line',\n  POLYGON: 'polygon',\n  MULTIPOINT: 'point',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'polygon',\n  POINTZ: 'point',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'polygon',\n  MULTIPOINTZ: 'point',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'polygon',\n};\n\nexport function createNgwLayerAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, connector);\n}\n\n/** @deprecated use {@link createNgwLayerAdapter} instead */\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  return createNgwLayerAdapter(options, webMap, connector);\n}\n\nexport interface ExtendNgwWebmapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendNgwWebmapLayerAdapter(\n  opt: ExtendNgwWebmapLayerAdapterOptions,\n): Type<NgwWebmapLayerAdapter> {\n  class A extends NgwWebmapLayerAdapter {\n    constructor(map: any, options: NgwWebmapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth(): number {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number): number {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 0): number {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n\n  const centerLat = lat;\n  const crsScale =\n    (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n  const zoom = getZoomFromScale(crsScale);\n  return zoom;\n\n  // return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n"],"names":["NgwKit","options","this","connector","url","baseUrl","Error","NgwConnector","auth","webMap","resourceId","resourceIds","length","r","addLayer","NgwWebmapLayerAdapter","visibility","fit","pixelRadius","layer","Promise","resolve","_getLayerAdapter","name","createAdapter","webmap","_createAdapter","extendNgwWebmapLayerAdapter","cls","adapter","classAdapters","WebmapLayerOpacityPropertyHandler","item","undefined","opacity","value","isGroup","_value","_prepareValue","getChildren","property","properties","propagation","set","update","get","val","getParents","reduce","s","x","prop","getValue","setLayerOpacity","Number","BaseProperty","NgwWebmapItem","parent","noInit","EventEmitter","tree","setParent","item_type","_rootDescendantsCount","_sumUp","children","root","getRoot","initProperties","_init","i","getItemOptions","setNewLayer","l","_layer","forEach","addChild","layer_adapter","toUpperCase","GetAdapterFromLayerType","getAdapter","then","newLayer","reject","transparency","layer_transparency","headers","crossOrigin","setViewDelay","params","resource","order","subOrder","drawOrderEnabled","draw_order_position","id","subLevel","String","padStart","_getZoomRange","maxZoom","minZoom","objectAssign","updateWmsParams","ratio","minScale","layer_min_scale_denom","maxScale","layer_max_scale_denom","reverse","scale","setScaleRatio","minZoomMap","maxZoomMap","minZoomWebmap","maxZoomWebmap","minZoomLayer","_mapScaleToZoomLevel","maxZoomLayer","minZooms","filter","Boolean","maxZooms","Math","max","min","initItem","emitter","emit","totalValue","child","ngwWebmapItem","Item","type","getProperty","treeSome","layer_enabled","onSet","showLayer","hideLayer","handler","createOnFirstShowAdapter","adapterOptions","onLayerAdded","OnFirstShowAdapter","_removed","removeLayer","loadLayer","_creatingInProgress","Adapter","mapAdapter","map","baselayer","realLayer","Object","assign","push","idPrefix","OnFirstNgwShowAdapter","resource_id","createAsyncAdapter","display_name","BookmarkItem","labelField","fields","_extent","CancelablePromise","fid","resp","extent","minLat","minLon","maxLat","lonLat","maxLon","geom","createGeoJsonFeature","fetchNgwLayerItem","featureId","extensions","onlyGeomItem","Array","isArray","_getWebMapLayerItem","getDependLayers","response","_webmapLayersIds","getBounds","getNgwWebmapExtent","getDescendants","bookmark_resource","bookmarkResId","getBookmarksResourceId","getResourceOrFail","feature_layer","find","label_field","keyname","fetchNgwLayerItems","items","bookmarks","bookmark","visibleLayers","ids","_getWebMapIds","sort","a","b","parentId","visible","isBlocked","getWebMapConfig","root_item","getAuthorizationHeaders","draw_order_enabled","on","getResource","data","webmapClassName","basemap_webmap","basemaps","_setBasemaps","defaultBasemap","addBaseLayer","extent_left","extent_bottom","extent_right","extent_top","_updateItemsParams","baseWebmap","enabledAlreadySet","createOnFirstShowNgwAdapter","enabled","fixUrlStr","layer_style_id","updateImageParams","layerAdapterOptions","ngwApiToAdapterOptions","webMapItem","layers","promises","promise","y","all","createPopupContent","feature","element","document","createElement","grid_visibility","propElem","appendChild","innerHTML","p","filterOptionsKeys","getLayerFilterOptions","filterOptions","opt","resourceIdFromLayerOptions","resourceItem","createGeoJsonAdapter","props","layerOptions","alop","addLayerOptionsPriority","GeoJsonAdapter","layerAdapters","GEOJSON","_fullDataLoad","popupOptions","fromProperties","getData","filters","filterOpt","abort","_lastFilterArgs","_dataPromise","fetchNgwLayerFeatureCollection","cache","removed","cancel","NgwGeoJsonAdapter","needUpdate","waitFullLoad","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","keys","strategy","propertiesFilter","updatePromise","updateLayer","_addBboxEventListener","hasData","getLayers","fetchNgwResourceExtent","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","__onMapMoveStart","_count","total_count","filterArgs","onLoad","intersects","srs","getCount","count","features","setLayerData","e","props_","prepareNgwFieldsToPropertiesFilter","setData","clearLayer","_addMoveEventListener","debounce","removeListener","createRasterAdapter","resourceCls","clsAdapterAlias","wmsserver_service","tmsclient_layer","getLayerAdapters","IMAGE","AdapterClass","_options","defined","addOptions","createWebMapAdapter","NWLayerAdapter","NgwResource","createBasemapLayerAdapter","basemap_layer","qms","qms_","JSON","parse","QmsKit","TileAdapter","TILE","BasemapTileAdapter","supportCls","createAdapterFromFirstStyle","getResourceChildren","childrenStyles","firstStyle","adapterType","itemFromResOpt","indexOf","parentItem","parentOptions","getClassAdapter","classAdapter","resourceAdapter","prototype","applyMixins","replace","FEATURE_REQUEST_PARAMS","geom_format","geometry","updateItemRequestParam","join","createFeatureFieldFilterQueries","_queries","_parentAllParams","logic","filters_","createParam","pf","field","operation","f","checkIfPropertyFilter","fetchNgwLayerItemsRequest","paramList","propertiesFilterList","itemsParts","concat","offset","limit","splice","polygon","orderBy","POSITIVE_INFINITY","order_by","coordinates","isLngLatBoundsArray","getBoundsCoordinates","lng","lat","degrees2meters","reqParams","bottom","left","top","right","fetchNgwLayerExtent","fetchNgwLayerItemExtent","res","fetchNgwLayerFeature","fetchNgwLayerFeatures","queryParams","toGeojson","getCompanyLogo","component","settings","company_logo","anchor","style","position","padding","className","cssClass","img","Image","maxHeight","maxWidth","src","responseType","urlCreator","window","URL","webkitURL","imageUrl","createObjectURL","console","log","link","trim","href","target","search","alt","IdentifyItem","label","layerId","_item","_resource","_geojson","identify","geojson","getIdentifyItems","multiple","resources","paramsList","isNaN","sortingArr","fry","identifyItem","layerFeatures","fetchIdentifyGeoJson","withGeom","fetchIdentifyItem","requestOptions","sendIdentifyRequest","ev","deprecatedMapClick","lngLat","getCirclePolygonCoordinates","radius","post","createIdentifyItem","isImageAllowed","nd","tileNoData","format","version","simplification","isObject","date","year","month","day","dt","hour","minute","second","Date","toISOString","bbox","width","height","size","timestamp","now","_pixelsInMeter","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","createNgwLayerAdapter","pixelsInMeterWidth","div","cssText","body","px","offsetWidth","removeChild","getMapWidthForLanInMeters","PI","cos","getZoomFromScale","LN2","centerLat","crsScale","zoom"],"sourceRoot":""}