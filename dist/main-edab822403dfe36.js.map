{"version":3,"file":"main-edab822403dfe36.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/createPopupContent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwExtent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/prepareNgwFieldsToPropertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItems.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatureCollection.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatures.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createGeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/ngwApiToAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createRasterAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/utils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowNgwAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/BookmarkItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createNgwWebmapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwResource.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createBasemapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createAsyncAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/IdentifyItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/constants.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeature.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/identifyUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getCompanyLogo.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/appendNgwResources.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/prepareWebMapOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/getIentifyRadius.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/NgwMap.ts"],"sourcesContent":["import { Feature } from 'geojson';\nimport { ResourceItem } from '@nextgis/ngw-connector';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem,\n): HTMLElement | string {\n  if (__BROWSER__) {\n    const element = document.createElement('div');\n    if (item && item.feature_layer) {\n      item.feature_layer.fields.forEach((x) => {\n        if (x.grid_visibility) {\n          const value = feature.properties && feature.properties[x.keyname];\n          if (value) {\n            const propElem = document.createElement('div');\n            element.appendChild(propElem);\n            propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n          }\n        }\n      });\n    } else if (feature.properties) {\n      for (const p in feature.properties) {\n        const propElem = document.createElement('div');\n        element.appendChild(propElem);\n        propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n      }\n    }\n    return element;\n  } else {\n    return '';\n  }\n}\n","import { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy',\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions,\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach((x) => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { WebmapResource, ResourceItem } from '@nextgis/ngw-connector';\nimport type {\n  FetchNgwLayerExtentOptions,\n  FetchNgwLayerItemExtentOptions,\n} from '../interfaces';\n\nexport function getNgwWebmapExtent(\n  webmap: WebmapResource,\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function fetchNgwLayerExtent({\n  resourceId,\n  connector,\n  cache = true,\n}: FetchNgwLayerExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get('layer.extent', { cache }, { id: resourceId })\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwLayerItemExtent({\n  resourceId,\n  featureId,\n  connector,\n  cache = true,\n}: FetchNgwLayerItemExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get(\n      'feature_layer.feature.item_extent',\n      { cache },\n      { id: resourceId, fid: featureId },\n    )\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return CancelablePromise.resolve(getNgwWebmapExtent(item.webmap));\n  } else {\n    const resource = item.resource;\n    if (resource.cls && resource.cls.indexOf('style') !== -1) {\n      return connector.getResource(resource.parent.id).then((res) => {\n        if (res) {\n          return fetchNgwLayerExtent({\n            resourceId: res.resource.id,\n            connector,\n          });\n        }\n      });\n    } else {\n      return fetchNgwLayerExtent({ resourceId: resource.id, connector });\n    }\n  }\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport type { NgwLayerOptions } from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector,\n): Promise<number> {\n  const resource = options.resource;\n  const item = resource as ResourceItem;\n\n  // @ts-ignore @deprecated\n  let { keyname, resourceId } = options;\n\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else if (\n      item.resource &&\n      item.resource !== undefined &&\n      'resource' in item\n    ) {\n      resourceId = (resource as ResourceItem).resource.id;\n    } else {\n      // TODO: safe remove this case\n      resourceId = await resourceIdFromLayerOptions(\n        resource as NgwLayerOptions,\n        connector,\n      );\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResource(keyname);\n    if (resourceItem) {\n      resourceId = resourceItem.resource.id;\n    }\n  }\n  return resourceId;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  checkIfPropertyFilter,\n  PropertiesFilter,\n  PropertyFilter,\n} from '@nextgis/properties-filter';\nimport {\n  defined,\n  degrees2meters,\n  getBoundsCoordinates,\n  isLngLatBoundsArray,\n} from '@nextgis/utils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type {\n  FeatureItem,\n  RequestItemAdditionalParams,\n} from '@nextgis/ngw-connector';\nimport type { LngLatArray, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureRequestParams,\n  FetchNgwItemsOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\n\nexport const FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson',\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry,\n  };\n  return feature;\n}\n\nexport function updateItemRequestParam<\n  P extends FeatureProperties = FeatureProperties,\n>(params: FeatureRequestParams, options: NgwFeatureRequestOptions<P>): void {\n  const { extensions, geom, fields, srs } = options;\n  params.extensions = extensions ? extensions.join(',') : '';\n  if (fields !== undefined) {\n    params.fields = Array.isArray(fields) ? fields.join(',') : '';\n  }\n  if (geom !== undefined) {\n    params.geom = geom ? 'yes' : 'no';\n    if (!geom) {\n      delete params.srs;\n      delete params.geom_format;\n    }\n  }\n  if (defined(srs)) {\n    params.srs = srs;\n  }\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nexport function createFeatureFieldFilterQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n  _queries: CancelablePromise<FeatureItem<P, G>[]>[] = [],\n  _parentAllParams: [string, any][] = [],\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const { filters } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter((x) => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    const isFldStr = field !== 'id' ? 'fld_' : '';\n    return [`${isFldStr}${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach((f) => {\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)],\n          }),\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f,\n          },\n          _queries,\n          [..._parentAllParams],\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filters: [string, any][] = [];\n    const propertiesFilterList: PropertiesFilter[] = [];\n    for (const f of filters_) {\n      if (checkIfPropertyFilter(f)) {\n        filters.push(createParam(f));\n      } else {\n        propertiesFilterList.push(f);\n      }\n    }\n\n    if (propertiesFilterList.length) {\n      for (const x of propertiesFilterList) {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: x,\n          },\n          _queries,\n          [..._parentAllParams, ...filters],\n        );\n      }\n    } else {\n      _queries.push(\n        fetchNgwLayerItemsRequest<G, P>({\n          ...opt,\n          paramList: [..._parentAllParams, ...filters],\n        }),\n      );\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    const offset = opt.offset !== undefined ? opt.offset : 0;\n    const limit = opt.limit !== undefined ? opt.limit : items.length;\n    if (opt.offset || opt.limit) {\n      return items.splice(offset, limit);\n    }\n    return items;\n  });\n}\n\nfunction createWktFromCoordArray(coord: LngLatArray[]): string {\n  const polygon = coord.map(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    return x + ' ' + y;\n  });\n  return `POLYGON((${polygon.join(', ')}))`;\n}\n\nexport function fetchNgwLayerItemsRequest<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  const {\n    connector,\n    limit,\n    offset,\n    intersects,\n    orderBy,\n    resourceId,\n    paramList,\n  } = options;\n  if (limit) {\n    if (limit !== Number.POSITIVE_INFINITY) {\n      params.limit = limit;\n    }\n  } else {\n    // Strict restriction on loading data from large layers\n    params.limit = 7000;\n  }\n  if (offset) {\n    params.offset = offset;\n  }\n  // TODO: fix type for options\n  updateItemRequestParam(params, options as { [field: string]: any });\n\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  if (Array.isArray(intersects)) {\n    const coordinates = isLngLatBoundsArray(intersects)\n      ? getBoundsCoordinates(intersects)\n      : intersects;\n\n    params.intersects = createWktFromCoordArray(coordinates);\n  } else if (typeof intersects === 'string') {\n    params.intersects = intersects;\n  }\n\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  const reqParams = {\n    id: resourceId,\n    ...params,\n  };\n\n  return connector.get(\n    'feature_layer.feature.collection',\n    { cache: options.cache },\n    reqParams,\n  ) as CancelablePromise<FeatureItem<P, G>[]>;\n}\n\nexport function prepareFieldsToNgw<\n  T extends FeatureProperties = FeatureProperties,\n>(\n  item: T,\n  resourceFields: Pick<FeatureProperties, 'keyname' | 'datatype'>[],\n): Record<keyof T, any> {\n  const fields = {} as Record<keyof T, any>;\n  if (item) {\n    resourceFields.forEach((x) => {\n      if (x.keyname in item) {\n        const keyname = x.keyname;\n        const prop = item[keyname];\n        let value: any;\n        if (prop !== undefined) {\n          if (x.datatype === 'STRING') {\n            value = prop ? String(prop) : null;\n            // TODO: remove after v 3.0.0. For backward compatibility\n            if (value === 'null') {\n              value = null;\n            }\n          } else if (x.datatype === 'BIGINT' || x.datatype === 'INTEGER') {\n            value = typeof prop === 'string' ? parseInt(prop, 10) : prop;\n          } else if (x.datatype === 'REAL') {\n            value = typeof prop === 'string' ? parseFloat(prop) : prop;\n          } else if (x.datatype === 'BOOLEAN') {\n            value =\n              typeof prop === 'boolean' || typeof prop === 'number'\n                ? Number(!!prop)\n                : null;\n          } else if (x.datatype === 'DATE' || x.datatype === 'DATETIME') {\n            let dt: Date | undefined;\n            if (typeof prop === 'object' && !((prop as any) instanceof Date)) {\n              value = prop;\n            } else {\n              if ((prop as any) instanceof Date) {\n                dt = prop as any;\n              } else {\n                const parse = Date.parse(String(prop));\n                if (parse) {\n                  dt = new Date(parse);\n                }\n              }\n              if (dt) {\n                value = {\n                  year: dt.getFullYear(),\n                  month: dt.getMonth(),\n                  day: dt.getDay(),\n                };\n                if (x.datatype === 'DATETIME') {\n                  value.hour = dt.getHours();\n                  value.minute = dt.getMinutes();\n                  value.second = dt.getSeconds();\n                }\n              }\n            }\n          }\n        }\n        fields[keyname as keyof T] = value ?? null;\n      }\n    });\n  }\n  return fields;\n}\n","import { isObject, defined } from '@nextgis/utils';\nimport type { NgwDateFormat, NgwDateTimeFormat } from '@nextgis/ngw-connector';\n\nexport function prepareNgwFieldsToPropertiesFilter(\n  fields: Record<string, any>,\n): Record<string, any> {\n  let f: keyof typeof fields;\n  for (f in fields) {\n    const field = fields[f];\n    if (isObject(field)) {\n      const date = field as NgwDateFormat | NgwDateTimeFormat;\n      if (defined(date.year) && defined(date.month) && defined(date.day)) {\n        const dt: [number, number, number, number?, number?, number?] = [\n          date.year,\n          date.month - 1,\n          date.day,\n        ];\n        if ('hour' in date) {\n          [date.hour, date.minute, date.second].forEach((x) => {\n            dt.push(x);\n          });\n        }\n        fields[f] = new Date(...dt).toISOString();\n      }\n    }\n  }\n  return fields;\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createFeatureFieldFilterQueries,\n  fetchNgwLayerItemsRequest,\n} from './featureLayerUtils';\nimport { prepareNgwFieldsToPropertiesFilter } from './prepareNgwFieldsToPropertiesFilter';\n\nimport type { Geometry } from 'geojson';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({\n      ...options,\n      filters,\n    }).then((data) => {\n      // Additional client-side filter check\n      data.filter((y) => {\n        const fields = prepareNgwFieldsToPropertiesFilter({ ...y.fields });\n        const result = propertiesFilter(fields, filters);\n        return result;\n      });\n      return data;\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  } else {\n    return fetchNgwLayerItemsRequest<G, P>(options);\n  }\n}\n","import { fetchNgwLayerFeatures } from './fetchNgwLayerFeatures';\n\nimport type { Geometry, FeatureCollection } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { FetchNgwItemsOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeatureCollection<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemsOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatures<G, P>(options).then((features) => {\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features,\n    };\n    return featureCollection;\n  });\n}\n","import { fetchNgwLayerItems } from './fetchNgwLayerItems';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<Feature<G, P>[]> {\n  return fetchNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach((y) => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    return features;\n  });\n}\n","import { EventEmitter } from 'events';\nimport { debounce } from '@nextgis/utils';\nimport { propertiesFilter } from '@nextgis/properties-filter';\nimport { createPopupContent } from '../utils/createPopupContent';\nimport { getLayerFilterOptions } from '../utils/getLayerFilterOptions';\nimport { fetchNgwResourceExtent } from '../utils/fetchNgwExtent';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { fetchNgwLayerFeatureCollection } from '../utils/fetchNgwLayerFeatureCollection';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\nimport { prepareNgwFieldsToPropertiesFilter } from '../utils/prepareNgwFieldsToPropertiesFilter';\n\nimport type { FeatureCollection } from 'geojson';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { Type } from '@nextgis/utils';\nimport type {\n  GeoJsonAdapterOptions,\n  VectorLayerAdapter,\n  FilterOptions,\n  LayerAdapter,\n} from '@nextgis/webmap';\nimport type {\n  NgwLayerOptions,\n  GetClassAdapterOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  props: GetClassAdapterOptions,\n): Promise<Type<VectorLayerAdapter>> {\n  const {\n    item,\n    webMap,\n    Adapter,\n    connector,\n    layerOptions,\n    addLayerOptionsPriority: alop,\n  } = props;\n  const addLayerOptionsPriority = alop ?? true;\n  const options = layerOptions as NgwLayerOptions<'GEOJSON'>;\n  const GeoJsonAdapter: Type<VectorLayerAdapter> =\n    Adapter || webMap.mapAdapter.layerAdapters.GEOJSON;\n\n  let _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n  let _dataPromise: CancelablePromise<FeatureCollection> | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (options.adapterOptions?.popupOptions?.fromProperties) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const getData = async (\n    filters?: PropertiesFilter,\n    filterOpt?: NgwFeatureRequestOptions,\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: filterOpt };\n    _dataPromise = fetchNgwLayerFeatureCollection({\n      resourceId,\n      filters,\n      connector,\n      cache: true,\n      ...filterOpt,\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  class NgwGeoJsonAdapter extends GeoJsonAdapter {\n    emitter = new EventEmitter();\n    _count?: number;\n    __onMapMove?: () => void;\n    __onMapMoveStart?: () => void;\n    __enableMapMoveListener?: (e: LayerAdapter) => void;\n    __disableMapMoveListener?: (e: LayerAdapter) => void;\n\n    async addLayer(opt: GeoJsonAdapterOptions) {\n      let needUpdate = !opt.data;\n      const waitFullLoad =\n        opt.waitFullLoad !== undefined ? opt.waitFullLoad : true;\n      if (options.id !== undefined) {\n        opt.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (options.adapterOptions) {\n        // TODO: remove addLayerOptionsPriority options/\n        // in some cases, addLayer options must be used,\n        // but in others factory method options needs first\n        if (addLayerOptionsPriority) {\n          opt = {\n            ...options.adapterOptions,\n            ...opt,\n          };\n        } else {\n          opt = {\n            ...opt,\n            ...options.adapterOptions,\n          };\n        }\n      }\n      if (opt.data && Object.keys(opt.data).length === 0) {\n        opt.data = undefined;\n        needUpdate = false;\n      }\n      const layer = super.addLayer(opt);\n      this.options.strategy = opt.strategy || undefined;\n\n      _lastFilterArgs = {\n        filters: opt.propertiesFilter,\n        options: getLayerFilterOptions(opt),\n      };\n      let updatePromise: Promise<any> | undefined;\n      if (needUpdate) {\n        updatePromise = this.updateLayer();\n      }\n      if (waitFullLoad && updatePromise) {\n        await updatePromise;\n      }\n      if (this.options.strategy === 'BBOX' && !_fullDataLoad) {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    getExtent() {\n      const hasData = this.getLayers && this.getLayers().length;\n      if (this.options.strategy === 'BBOX' || hasData) {\n        return fetchNgwResourceExtent(item, connector);\n      } else {\n        if (super.getExtent) {\n          return super.getExtent();\n        }\n      }\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      this.__onMapMoveStart = undefined;\n      abort();\n    }\n\n    getCount() {\n      if (this._count !== undefined) {\n        return this._count;\n      }\n      return connector\n        .get(\n          'feature_layer.feature.count',\n          { cache: true },\n          {\n            id: resourceId,\n          },\n        )\n        .then((resp) => {\n          if (resp) {\n            this._count = resp.total_count;\n            return this._count;\n          }\n        });\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy === 'BBOX') {\n        await webMap.onLoad('create');\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = webMap.getBounds();\n      }\n      if (removed) {\n        return;\n      }\n      try {\n        const data = await getData(filterArgs.filters, {\n          ...filterArgs.options,\n          srs: this.options.srs,\n        });\n        const count = await this.getCount();\n        _fullDataLoad = count === data.features.length;\n        await webMap.setLayerData(this, data);\n        this.emitter.emit('updated');\n      } catch (er) {\n        if (er instanceof Error && er.name !== 'CancelError') {\n          throw er;\n        }\n      }\n      if (super.updateLayer) {\n        super.updateLayer();\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter((e) => {\n          const props_ =\n            e.feature &&\n            e.feature.properties &&\n            prepareNgwFieldsToPropertiesFilter({ ...e.feature.properties });\n          if (props_) {\n            return propertiesFilter(props_, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await getData(filters, {\n          ...opt,\n          srs: this.options.srs,\n        });\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    _addBboxEventListener() {\n      this.__enableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener(this);\n    }\n\n    _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      this.__onMapMoveStart = abort;\n      webMap.emitter.on('movestart', this.__onMapMoveStart);\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.removeListener('moveend', this.__onMapMove);\n      }\n      if (this.__onMapMoveStart) {\n        webMap.emitter.removeListener('movestart', this.__onMapMoveStart);\n      }\n    }\n  }\n\n  return NgwGeoJsonAdapter;\n}\n","import {\n  WebMap,\n  RasterAdapterOptions,\n  ImageAdapterOptions,\n  WmsAdapterOptions,\n} from '@nextgis/webmap';\n\nimport { NgwLayerOptions, TileNoData } from '../interfaces';\nimport { updateImageParams } from './utils';\n\nexport interface GetLayerAdapterOptions {\n  options: NgwLayerOptions;\n  webMap?: WebMap;\n  baseUrl?: string;\n}\n\nexport function ngwApiToAdapterOptions({\n  options,\n  webMap,\n  baseUrl,\n}: GetLayerAdapterOptions):\n  | RasterAdapterOptions\n  | ImageAdapterOptions\n  | undefined {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap && webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = options.resource;\n  const nd: TileNoData = options.tileNoData ? options.tileNoData : 200;\n\n  if (typeof resourceId === 'number') {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          params: { resource: resourceId, nd: nd },\n          updateWmsParams: (params: Record<string, any>) =>\n            updateImageParams({ nd: nd, ...params }, resourceId),\n        } as ImageAdapterOptions;\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      const adapterOptions = options.adapterOptions as WmsAdapterOptions;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: adapterOptions && adapterOptions.layers,\n        headers: options.headers,\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url,\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'MODEL_3D') {\n      url = baseUrl + `/api/component/model_3d/${resourceId}/data.glb`;\n      return { url };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId +\n        '&nd=' +\n        nd;\n      return { url, adapter };\n    }\n  } else if (resourceId !== undefined) {\n    throw new Error(\n      'Option `resource` must be number, not ' + typeof resourceId,\n    );\n  } else {\n    console.log('Option `resource` not set');\n  }\n}\n\n/** @deprecated use {@link ngwApiToAdapterOptions} instead */\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n): RasterAdapterOptions | ImageAdapterOptions | undefined {\n  return ngwApiToAdapterOptions({ options, webMap, baseUrl });\n}\n","import { defined } from '@nextgis/utils';\n\nimport { ngwApiToAdapterOptions } from '../utils/ngwApiToAdapterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { Type } from '@nextgis/utils';\nimport type { ResourceItem, ResourceCls } from '@nextgis/ngw-connector';\nimport type { MainLayerAdapter, ImageAdapterOptions } from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  GetClassAdapterOptions,\n} from '../interfaces';\n\nexport async function createRasterAdapter({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  const resourceCls = item.resource.cls;\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    tmsclient_layer: 'IMAGE',\n  };\n  let adapter =\n    layerOptions.adapter ||\n    (resourceCls && clsAdapterAlias[resourceCls]) ||\n    'IMAGE';\n  if (adapter !== undefined) {\n    layerOptions.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const AdapterClass = webMap.mapAdapter.layerAdapters[\n    adapter\n  ] as Type<MainLayerAdapter>;\n  if (AdapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(\n      layerOptions,\n      connector,\n    );\n    return class RasterAdapter extends AdapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem = item;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = ngwApiToAdapterOptions({\n          options: layerOptions,\n          webMap,\n          baseUrl: connector.options.baseUrl || '',\n        });\n        if (opt) {\n          const layerAdapterOptions: ImageAdapterOptions = {\n            ...opt,\n            setViewDelay: layerOptions.adapterOptions?.setViewDelay,\n            params: { resource: resourceId },\n            // @deprecated\n            layers: String(resourceId),\n            resourceId: resourceId,\n          };\n          if (\n            layerOptions.adapterOptions &&\n            defined(layerOptions.adapterOptions.setViewDelay)\n          ) {\n            layerAdapterOptions.setViewDelay =\n              layerOptions.adapterOptions.setViewDelay;\n          }\n          this.options = { ...this.options, ...layerAdapterOptions };\n          // if (__DEV__) {\n          //   Object.defineProperty(this.options, 'layers', {\n          //     get: () => {\n          //       console.warn('Do not use `layers` in ImageAdapterOptions');\n          //       return String(resourceId);\n          //     },\n          //   });\n          //   Object.defineProperty(this.options, 'resourceId', {\n          //     get: () => {\n          //       console.warn('Do not use `resourceId` in ImageAdapterOptions');\n          //       return resourceId;\n          //     },\n          //   });\n          // }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (defined(id)) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","import { EventEmitter } from 'events';\nimport { ItemOptions, Item } from '@nextgis/item';\nimport { treeSome } from '@nextgis/tree';\nimport {\n  WebMap,\n  LayerAdapter,\n  LayerAdapterDefinition,\n  ImageAdapterOptions,\n} from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { objectAssign } from '@nextgis/utils';\n\nimport { setScaleRatio } from './utils/utils';\nimport { TreeGroup, TreeLayer, TreeItem } from './interfaces';\n\nexport class NgwWebmapItem extends Item<ItemOptions> {\n  static GetAdapterFromLayerType: {\n    [layerType: string]: (\n      item: TreeItem,\n      options: any,\n      webMap: WebMap,\n      connector?: NgwConnector,\n    ) => LayerAdapterDefinition;\n  } = {};\n\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: NgwWebmapItem): boolean {\n          if (item) {\n            if (\n              item.item.item_type === 'group' ||\n              item.item.item_type === 'root'\n            ) {\n              return treeSome<TreeGroup | TreeLayer>(\n                item.item,\n                (i) => ('layer_enabled' in i ? i.layer_enabled : false),\n                (i) => (i as TreeGroup).children,\n              );\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            }\n            // else if (item.item.item_type === 'root') {\n            //   return true;\n            // }\n          }\n          return false;\n        },\n        onSet(\n          value: boolean,\n          options?: Record<string, any>,\n          item?: NgwWebmapItem,\n        ): void {\n          if (item && item.item.item_type === 'layer') {\n            if (item.layer) {\n              if (value) {\n                item.webMap.showLayer(item.layer);\n              } else {\n                item.webMap.hideLayer(item.layer);\n              }\n            }\n            item.item['layer_enabled'] = value;\n          }\n        },\n      },\n    ],\n  };\n\n  item: TreeGroup | TreeLayer;\n  connector?: NgwConnector;\n  layer?: LayerAdapter;\n  readonly emitter = new EventEmitter();\n\n  protected _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n    noInit?: boolean,\n  ) {\n    super({ ...NgwWebmapItem.options, ...options });\n    if (connector) {\n      this.connector = connector;\n    }\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n    this.initProperties();\n    if (!noInit) {\n      this._init(item);\n    }\n  }\n\n  static async create(\n    webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n  ): Promise<NgwWebmapItem> {\n    const ngwWebmapItem = new NgwWebmapItem(\n      webMap,\n      item,\n      options,\n      connector,\n      parent,\n      true,\n    );\n    await ngwWebmapItem._init(item);\n    return ngwWebmapItem;\n  }\n\n  initItem(item: TreeGroup | TreeLayer): Promise<void> {\n    const i = item;\n    const options: Partial<ImageAdapterOptions> = this.getItemOptions(item);\n    const setNewLayer = (l: LayerAdapter) => {\n      i._layer = l;\n      this.layer = l;\n      const enabled = this.properties.get('visibility');\n      if (enabled) {\n        this.properties.set('visibility', true);\n      }\n\n      if (options.opacity !== undefined) {\n        this.webMap.setLayerOpacity(l, options.opacity);\n      }\n    };\n\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        this.getChildren(item).forEach((x) => {\n          const children = new NgwWebmapItem(\n            this.webMap,\n            x,\n            this.options,\n            this.connector,\n            this,\n          );\n          this.tree.addChild(children);\n        });\n      }\n      return Promise.resolve();\n    } else {\n      let adapter: LayerAdapterDefinition | undefined;\n      if (item.item_type === 'layer') {\n        adapter = item.adapter || item.layer_adapter.toUpperCase();\n      } else if (NgwWebmapItem.GetAdapterFromLayerType[item.item_type]) {\n        const getAdapter =\n          NgwWebmapItem.GetAdapterFromLayerType[item.item_type];\n        adapter = getAdapter(item, options, this.webMap, this.connector);\n      }\n\n      if (adapter) {\n        return this.webMap.addLayer(adapter, options).then((newLayer) => {\n          setNewLayer(newLayer);\n        });\n      }\n    }\n    if (item._layer) {\n      return Promise.resolve(setNewLayer(item._layer));\n    }\n    return Promise.reject('No layer added');\n  }\n\n  bringToFront(): void {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      // console.log(this.item);\n    }\n  }\n\n  protected getItemOptions(item: TreeGroup | TreeLayer): Record<string, any> {\n    const transparency = item.item_type === 'layer' && item.layer_transparency;\n    const opacity =\n      typeof transparency === 'number' ? (100 - transparency) / 100 : undefined;\n    const options: Partial<ImageAdapterOptions> = {\n      visibility: false,\n      headers: this.options.headers,\n      crossOrigin: this.options.crossOrigin,\n      setViewDelay: this.options.setViewDelay,\n      params: { resource: this.item.resourceId },\n    };\n    if (this.options.order) {\n      const subOrder =\n        this.options.drawOrderEnabled && 'draw_order_position' in item\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n\n      // 9 > 0009, 11 > 0011\n      // TODO: find better way to set order in sub level, not limit by 1000 layer in group\n      const subLevel = String(subOrder).padStart(4, '0');\n      options.order = Number((this.options.order | 0) + '.' + subLevel);\n    }\n    if (item.item_type === 'layer') {\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      objectAssign(options, {\n        updateWmsParams: item.updateWmsParams,\n        url: item.url,\n        headers: this.options.headers,\n        ratio: this.options.ratio,\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n      });\n    }\n    if (opacity !== undefined) {\n      options.opacity = opacity;\n    }\n    return options;\n  }\n\n  protected getChildren(item: TreeGroup): (TreeGroup | TreeLayer)[] {\n    return [...item.children].reverse();\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private _init(item: TreeGroup | TreeLayer) {\n    this.initItem(item).then(() => {\n      this.emitter.emit('init');\n    });\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import NgwConnector, { GeometryType } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../adapters/createAsyncAdapter';\nimport { NgwWebmapLayerAdapter } from '../NgwWebmapLayerAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, VectorAdapterLayerType } from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwLayerOptions,\n  NgwWebmapAdapterOptions,\n} from '../interfaces';\n\nexport function updateImageParams(\n  params: Record<string, any>,\n  resourceId: number,\n): Record<string, any> {\n  const { bbox, width, height, nd } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now(),\n    nd,\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'point',\n  LINESTRING: 'line',\n  POLYGON: 'polygon',\n  MULTIPOINT: 'point',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'polygon',\n  POINTZ: 'point',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'polygon',\n  MULTIPOINTZ: 'point',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'polygon',\n};\n\nexport function createNgwLayerAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, connector);\n}\n\n/** @deprecated use {@link createNgwLayerAdapter} instead */\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  return createNgwLayerAdapter(options, webMap, connector);\n}\n\nexport interface ExtendNgwWebmapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendNgwWebmapLayerAdapter(\n  opt: ExtendNgwWebmapLayerAdapterOptions,\n): Type<NgwWebmapLayerAdapter> {\n  class A extends NgwWebmapLayerAdapter {\n    constructor(map: any, options: NgwWebmapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth(): number {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number): number {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 0): number {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n\n  const centerLat = lat;\n  const crsScale =\n    (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n  const zoom = getZoomFromScale(crsScale);\n  return zoom;\n\n  // return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import type { WebMap, MainLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport type { Type } from '@nextgis/utils';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  adapterOptions?: Record<string, any>;\n  onLayerAdded?: <L extends MainLayerAdapter = MainLayerAdapter>(\n    layer: L,\n  ) => void;\n  createAdapter: (\n    firstShowAdapter: FirstShowAdapter,\n  ) => Promise<Type<MainLayerAdapter> | undefined>;\n}\n\ninterface FirstShowAdapter extends MainLayerAdapter {\n  loadLayer: () => Promise<MainLayerAdapter[]>;\n  destroyed: () => boolean;\n}\n\nexport async function createOnFirstShowAdapter({\n  webMap,\n  adapterOptions = {},\n  onLayerAdded,\n  createAdapter,\n}: CreateOnFirstShowAdapterOptions): Promise<Type<FirstShowAdapter>> {\n  class OnFirstShowAdapter implements MainLayerAdapter {\n    options: AdapterOptions = {};\n    layer: MainLayerAdapter[] = [];\n    _removed = false;\n    _creatingInProgress = false;\n\n    addLayer() {\n      return this.layer;\n    }\n\n    removeLayer() {\n      this._removed = true;\n      this.layer.forEach((x) => webMap.removeLayer(x));\n    }\n\n    destroyed() {\n      return this._removed;\n    }\n\n    showLayer() {\n      this.options.visibility = true;\n      if (this.layer.length) {\n        this.layer.forEach((x) => {\n          webMap.showLayer(x);\n        });\n      } else {\n        this.loadLayer();\n      }\n    }\n\n    async loadLayer() {\n      if (!this.layer.length && !this._creatingInProgress) {\n        this._creatingInProgress = true;\n        const Adapter = await createAdapter(this);\n        if (Adapter) {\n          const adapter = new Adapter(webMap.mapAdapter.map, {\n            ...adapterOptions,\n          });\n          const realLayer: MainLayerAdapter = await adapter.addLayer({\n            order: this.options.order,\n            headers: this.options.headers,\n            baselayer: this.options.baselayer,\n          });\n          if (onLayerAdded) {\n            onLayerAdded(adapter);\n          }\n          Object.assign(adapter.options, adapterOptions);\n          adapter.layer = realLayer;\n          if (this._removed) {\n            webMap.removeLayer(adapter);\n          }\n          if (this.options.visibility) {\n            await webMap.showLayer(adapter);\n          }\n          this.layer.push(adapter);\n          this._creatingInProgress = false;\n        }\n      }\n      return this.layer;\n    }\n\n    hideLayer() {\n      this.options.visibility = false;\n      if (this.layer) {\n        this.layer.forEach((x) => webMap.hideLayer(x));\n      }\n    }\n  }\n  return OnFirstShowAdapter;\n}\n","import { Type } from '@nextgis/utils';\nimport { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport NgwConnector, { BasemapWebmapItem } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from './createAsyncAdapter';\nimport { createOnFirstShowAdapter } from './createOnFirstShowAdapter';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  item: BasemapWebmapItem;\n  adapterOptions?: Record<string, any>;\n  idPrefix?: string;\n}\n\nexport async function createOnFirstShowNgwAdapter({\n  webMap,\n  connector,\n  item,\n  adapterOptions = {},\n  idPrefix = 'first-show-adapter',\n}: CreateOnFirstShowAdapterOptions): Promise<Type<MainLayerAdapter>> {\n  const createAdapter = () => {\n    return createAsyncAdapter(\n      {\n        resource: item.resource_id,\n        adapterOptions: {\n          name: item.display_name,\n          opacity: item.opacity,\n        },\n      },\n      webMap,\n      connector,\n    );\n  };\n  const onLayerAdded = (adapter: MainLayerAdapter) => {\n    adapter.options.baselayer = false;\n    adapter.id = idPrefix + '-' + item.resource_id;\n  };\n\n  const OnFirstNgwShowAdapter = createOnFirstShowAdapter({\n    webMap,\n    adapterOptions,\n    onLayerAdded,\n    createAdapter,\n  });\n\n  return OnFirstNgwShowAdapter;\n}\n","import { Feature, Point } from 'geojson';\nimport { createGeoJsonFeature, fetchNgwLayerItem } from '@nextgis/ngw-kit';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\ninterface BookmarkItemOptions {\n  connector: NgwConnector;\n  resourceId: number;\n  item: FeatureItem;\n  labelField?: string;\n}\n\nexport class BookmarkItem {\n  readonly name: string;\n  readonly resourceId: number;\n  readonly item: FeatureItem;\n\n  private _extent?: LngLatBoundsArray;\n\n  constructor(private options: BookmarkItemOptions) {\n    this.resourceId = options.resourceId;\n    const item = options.item;\n    this.item = item;\n    if (options.labelField && item.fields) {\n      this.name = item.fields[options.labelField];\n    } else {\n      this.name = String(item.id);\n    }\n  }\n\n  extent(): CancelablePromise<LngLatBoundsArray> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return this.options.connector\n      .get('feature_layer.feature.item_extent', null, {\n        id: this.resourceId,\n        fid: this.item.id,\n      })\n      .then((resp) => {\n        const { minLat, minLon, maxLat, maxLon } = resp.extent;\n        const lonLat = [minLon, minLat, maxLon, maxLat];\n        this._extent = lonLat;\n        return lonLat;\n      });\n  }\n\n  geoJson(): CancelablePromise<Feature<Point, any>> {\n    if (this.item.geom) {\n      return CancelablePromise.resolve(createGeoJsonFeature(this.item));\n    } else {\n      return fetchNgwLayerItem({\n        resourceId: this.resourceId,\n        featureId: this.item.id,\n        connector: this.options.connector,\n        geom: true,\n        fields: null,\n        extensions: null,\n      }).then((onlyGeomItem) => {\n        const geom = onlyGeomItem.geom;\n        this.item.geom = geom;\n        return createGeoJsonFeature(this.item);\n      });\n    }\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  fetchNgwLayerItems,\n  WEBMAP_BASELAYER_ID_PREFIX,\n} from '@nextgis/ngw-kit';\n\nimport { NgwWebmapItem } from './NgwWebmapItem';\nimport { createOnFirstShowNgwAdapter } from './adapters/createOnFirstShowNgwAdapter';\nimport { ngwApiToAdapterOptions } from './utils/ngwApiToAdapterOptions';\nimport { getNgwWebmapExtent } from './utils/fetchNgwExtent';\nimport { updateImageParams } from './utils/utils';\nimport { BookmarkItem } from './BookmarkItem';\n\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type { Type, LngLatBoundsArray } from '@nextgis/utils';\nimport type { ItemOptions } from '@nextgis/item';\nimport type {\n  WebmapResource,\n  BasemapWebmap,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport type { WebMap, RasterAdapterOptions } from '@nextgis/webmap';\nimport type {\n  TreeGroup,\n  TreeLayer,\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  NgwWebmapAdapterOptions,\n  NgwWebmapLayerAdapterEvents,\n} from './interfaces';\n\nexport class NgwWebmapLayerAdapter<M = any> implements ResourceAdapter<M> {\n  layer?: NgwWebmapItem;\n\n  NgwWebmapItem: Type<NgwWebmapItem> = NgwWebmapItem;\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  webmapClassName = 'webmap';\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwWebmapLayerAdapterEvents\n  > = new EventEmitter();\n  protected _extent?: LngLatBoundsArray;\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  constructor(public map: M, public options: NgwWebmapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: NgwWebmapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n    this.layer = await this._getWebMapLayerItem();\n    return this.layer;\n  }\n\n  removeLayer(): void {\n    const mapAdapter = this.options.webMap.mapAdapter;\n\n    this.getDependLayers().forEach((x) => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    // delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer(): void {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer(): void {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getNgwWebmapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<NgwWebmapItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  getBookmarksResourceId(): number | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return webmap.bookmark_resource.id;\n    }\n  }\n\n  fetchBookmarks(): CancelablePromise<BookmarkItem[]> {\n    const bookmarkResId = this.getBookmarksResourceId();\n    const connector = this.options.connector;\n    if (bookmarkResId) {\n      return connector.getResourceOrFail(bookmarkResId).then((item) => {\n        const labelField = item.feature_layer?.fields.find(\n          (x) => x.label_field,\n        );\n        const keyname = labelField && labelField.keyname;\n        return fetchNgwLayerItems({\n          connector,\n          resourceId: bookmarkResId,\n          geom: false,\n          fields: keyname ? [keyname] : undefined,\n        }).then((items) => {\n          const bookmarks: BookmarkItem[] = [];\n          for (const i of items) {\n            const bookmark = new BookmarkItem({\n              item: i,\n              resourceId: bookmarkResId,\n              labelField: keyname,\n              connector,\n            });\n            bookmarks.push(bookmark);\n          }\n          return bookmarks;\n        });\n      });\n    }\n    throw new Error(\n      'Webmap was not loaded correctly, it is impossible to extract bookmarks',\n    );\n  }\n\n  async getIdentificationIds(): Promise<number[]> {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => b.id - a.id);\n      deps.forEach((x) => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  protected async _getWebMapLayerItem(): Promise<NgwWebmapItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<NgwWebmapItem>((resolve) => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.setViewDelay = this.options.setViewDelay;\n          options.order = this.options.order;\n          options.ratio = this.options.ratio;\n          options.crossOrigin = this.options.crossOrigin;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new this.NgwWebmapItem(\n            this.options.webMap,\n            webmap.root_item,\n            options,\n            this.options.connector,\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    const data = await this.options.connector.getResource(id);\n    if (data) {\n      this.response = data;\n      const webmap = data[\n        this.webmapClassName as keyof ResourceItem\n      ] as WebmapResource;\n      if (data.basemap_webmap && data.basemap_webmap.basemaps.length) {\n        this._setBasemaps(data.basemap_webmap);\n      } else if (this.options.defaultBasemap) {\n        const webMap = this.options.webMap;\n        webMap.addBaseLayer('OSM', {\n          id: 'webmap-default-baselayer',\n          name: 'OpenStreetMap',\n        });\n      }\n      if (webmap) {\n        this._extent = [\n          webmap.extent_left,\n          webmap.extent_bottom,\n          webmap.extent_right,\n          webmap.extent_top,\n        ];\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    }\n  }\n\n  private _setBasemaps(baseWebmap: BasemapWebmap) {\n    const webMap = this.options.webMap;\n    let enabledAlreadySet = false;\n    baseWebmap.basemaps.forEach((x) => {\n      createOnFirstShowNgwAdapter({\n        webMap,\n        connector: this.options.connector,\n        item: x,\n        adapterOptions: { crossOrigin: this.options.crossOrigin },\n      }).then((adapter) => {\n        // to avoid set many basemaps on init\n        const visibility = enabledAlreadySet ? false : x.enabled;\n        webMap.addBaseLayer(adapter, {\n          id: WEBMAP_BASELAYER_ID_PREFIX + x.resource_id,\n          name: x.display_name,\n          opacity: x.opacity,\n          visibility,\n        });\n        if (x.enabled) {\n          enabledAlreadySet = true;\n        }\n      });\n    });\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem,\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map((x) =>\n            this._updateItemsParams(x, webMap, data),\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.connector.options.baseUrl +\n            '/api/component/render/image',\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = (params) =>\n          updateImageParams(params, resourceId);\n        const adapter = item.layer_adapter.toUpperCase() as NgwLayerAdapterType;\n        const layerAdapterOptions = ngwApiToAdapterOptions({\n          options: {\n            adapter,\n            resource: resourceId,\n          },\n          webMap,\n          baseUrl: this.options.connector.options.baseUrl || '',\n        }) as RasterAdapterOptions;\n        item = {\n          ...item,\n          ...layerAdapterOptions,\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: NgwWebmapItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector.getResource(id).then((y) => {\n            if (y) {\n              const parentId = Number(y.resource.parent.id);\n              item.parentId = parentId;\n              return parentId;\n            }\n          });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter((x) => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n}\n","import { NgwWebmapLayerAdapter as NWLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { Type } from '@nextgis/utils';\nimport type { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createWebMapAdapter({\n  layerOptions: options,\n  webMap,\n  connector,\n}: GetClassAdapterOptions): Promise<Type<NWLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class NgwWebmapLayerAdapter extends NWLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        url: '',\n        webMap,\n        resourceId,\n        connector,\n      });\n    }\n  };\n}\n","import { fetchNgwResourceExtent } from './utils/fetchNgwExtent';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { ResourceItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  protected _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await fetchNgwResourceExtent(\n        this.item,\n        this.connector,\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import { QmsKit } from '@nextgis/qms-kit';\n\nimport type { Type } from '@nextgis/utils';\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createBasemapLayerAdapter({\n  webMap,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  if (item.basemap_layer) {\n    const qms = item.basemap_layer.qms;\n    const url = item.basemap_layer.url;\n    if (qms) {\n      const qms_ = JSON.parse(qms);\n      const adapter = Promise.resolve(\n        QmsKit.utils.createQmsAdapter(webMap, undefined, {\n          qms: qms_,\n          baselayer: true,\n        }),\n      );\n      return adapter;\n    } else if (url) {\n      const TileAdapter = webMap.mapAdapter.layerAdapters.TILE as Type<\n        MainLayerAdapter<any, any, TileAdapterOptions>\n      >;\n      if (TileAdapter) {\n        class BasemapTileAdapter extends TileAdapter {\n          async addLayer(opt: TileAdapterOptions) {\n            return super.addLayer({ ...opt, url });\n          }\n        }\n        return BasemapTileAdapter;\n      }\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport { WebMap } from '@nextgis/webmap';\nimport { Type, applyMixins } from '@nextgis/utils';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createNgwWebmapAdapter';\nimport { NgwResource } from '../NgwResource';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { createBasemapLayerAdapter } from './createBasemapLayerAdapter';\n\nimport type {\n  GetClassAdapterCallback,\n  GetClassAdapterOptions,\n  GetClassAdapterByType,\n  ResourceAdapter,\n  NgwLayerOptions,\n  GetClassAdapter,\n  ClassAdapter,\n} from '../interfaces';\n\nexport const classAdapters: Record<string, GetClassAdapter> = {};\n\nconst supportCls: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'basemap_layer',\n  'vector_layer',\n  'raster_layer',\n  'webmap',\n  // in tms branch\n  'tmsclient_layer',\n];\n\nasync function createAdapterFromFirstStyle({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions) {\n  const parent = item.resource.id;\n  const childrenStyles = await connector.getResourceChildren(parent);\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...layerOptions, resource: firstStyle.resource.id },\n      webMap,\n      connector,\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: ClassAdapter | undefined;\n  let item: ResourceItem | undefined;\n  const adapterType = options.adapter;\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  if (resourceId) {\n    const resourceOptions = options as NgwLayerOptions;\n    const itemFromResOpt = resourceOptions.resource as ResourceItem;\n    if (\n      itemFromResOpt &&\n      itemFromResOpt.resource &&\n      itemFromResOpt.resource.id !== undefined\n    ) {\n      item = itemFromResOpt;\n    } else {\n      item = await connector.getResource(resourceId);\n    }\n    if (item) {\n      const cls = item.resource.cls;\n      const layerOptions: NgwLayerOptions = {\n        ...options,\n        resource: resourceId,\n      };\n\n      const adapterOptions: GetClassAdapterOptions = {\n        layerOptions,\n        webMap,\n        connector,\n        item,\n      };\n\n      if (supportCls.indexOf(cls) !== -1) {\n        if (cls === 'webmap') {\n          adapter = createWebMapAdapter(adapterOptions);\n        } else if (cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(adapterOptions);\n            } else {\n              return createAdapterFromFirstStyle(adapterOptions);\n            }\n          } else {\n            adapter = createGeoJsonAdapter(adapterOptions);\n          }\n        } else if (cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(adapterOptions);\n        } else if (cls === 'basemap_layer') {\n          adapter = createBasemapLayerAdapter(adapterOptions);\n        } else {\n          if (adapterType === 'GEOJSON') {\n            const parentItem = await connector.getResource(\n              item.resource.parent.id,\n            );\n            if (parentItem) {\n              const parentOptions: NgwLayerOptions = {\n                ...options,\n                resource: item.resource.parent.id,\n              };\n              adapter = createGeoJsonAdapter({\n                ...adapterOptions,\n                item: parentItem,\n                layerOptions: parentOptions,\n              });\n            }\n          } else {\n            adapter = createRasterAdapter(adapterOptions);\n          }\n        }\n      } else if (classAdapters[cls]) {\n        const getClassAdapter = classAdapters[cls];\n        let classAdapter: GetClassAdapterCallback | undefined;\n        if (adapterType && typeof classAdapter !== 'function') {\n          classAdapter = (getClassAdapter as GetClassAdapterByType)[\n            adapterType\n          ];\n        } else {\n          classAdapter = getClassAdapter as GetClassAdapterCallback;\n        }\n        if (classAdapter) {\n          adapter = classAdapter(adapterOptions);\n        }\n      } else {\n        throw `Resource class '${cls}' not yet supported.`;\n      }\n    } else {\n      throw 'Resource item is not found';\n    }\n  }\n\n  if (adapter) {\n    return adapter.then((x) => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        if (item) {\n          resourceAdapter.prototype.item = item;\n          resourceAdapter.prototype.resourceId = item.resource.id;\n          resourceAdapter.prototype.connector = connector;\n        }\n\n        applyMixins(resourceAdapter, [NgwResource], { replace: false });\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import NgwConnector from '@nextgis/ngw-connector';\n\nimport { extendNgwWebmapLayerAdapter } from './utils/utils';\nimport { NgwWebmapLayerAdapter } from './NgwWebmapLayerAdapter';\nimport { classAdapters } from './adapters/createAsyncAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, StarterKit, LayerAdapterCreators } from '@nextgis/webmap';\nimport type {\n  NgwKitOptions,\n  GetClassAdapter,\n  NgwWebmapAdapterOptions,\n} from './interfaces';\n\nexport class NgwKit implements StarterKit {\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl || '';\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth,\n      });\n    }\n  }\n\n  static addClassAdapters(cls: string, adapter: GetClassAdapter): void {\n    classAdapters[cls] = adapter;\n  }\n\n  async onLoadSync(webMap: WebMap): Promise<NgwWebmapLayerAdapter | undefined> {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: Partial<NgwWebmapAdapterOptions> = {\n            resourceId: r,\n            connector: this.connector,\n            webMap,\n          };\n          const layer = (await webMap.addLayer(NgwWebmapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            pixelRadius: this.options.pixelRadius,\n            ...options,\n          })) as NgwWebmapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap)),\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<NgwWebmapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendNgwWebmapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl,\n    });\n  }\n}\n","import { fetchNgwLayerItem, IdentifyItemOptions } from '.';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { NgwFeatureItemResponse } from '.';\nimport type { GeoJsonObject, Geometry, Feature } from 'geojson';\nimport type {\n  FeatureItemExtensions,\n  FeatureResource,\n  LayerFeature,\n  VectorLayerResourceItem,\n} from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport { FetchNgwItemOptions } from './interfaces';\n\nexport class IdentifyItem<F = FeatureProperties, G extends Geometry = Geometry>\n  implements LayerFeature\n{\n  readonly id: number;\n  readonly label: string;\n  readonly layerId: number;\n  readonly parent: string;\n  readonly fields: FeatureProperties;\n  geom?: GeoJsonObject;\n  extensions?: FeatureItemExtensions;\n\n  private connector: NgwConnector;\n  private _item?: NgwFeatureItemResponse<F, G>;\n  private _geojson?: Feature<G, F>;\n  private _resource?: VectorLayerResourceItem;\n\n  constructor(options: IdentifyItemOptions) {\n    const f = options.feature;\n    this.id = f.id;\n    this.label = f.label;\n    this.layerId = f.layerId;\n    this.parent = f.parent;\n    this.fields = f.fields;\n    this.geom = f.geom;\n    this.connector = options.connector;\n  }\n\n  identify(\n    options: Partial<FetchNgwItemOptions<F>> = {},\n  ): CancelablePromise<NgwFeatureItemResponse<F, G>> {\n    if (this._item) {\n      return CancelablePromise.resolve(this._item);\n    }\n    return fetchNgwLayerItem<G, F>({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n      fields: null,\n      extensions: ['attachment', 'description'],\n      ...options,\n    }).then((resp) => {\n      this._item = resp;\n      this.geom = resp.geom;\n      this.extensions = resp.extensions;\n      return resp;\n    });\n  }\n\n  resource(): CancelablePromise<FeatureResource> {\n    if (this._resource) {\n      return CancelablePromise.resolve(this._resource.feature_layer);\n    }\n    return this.connector.getResource(this.layerId).then((resp) => {\n      this._resource = resp as VectorLayerResourceItem;\n      return this._resource.feature_layer;\n    });\n  }\n\n  geojson(): CancelablePromise<Feature<G, F>> {\n    if (this._geojson) {\n      return CancelablePromise.resolve(this._geojson);\n    }\n    return this.identify().then((resp) => {\n      return resp.toGeojson().then((geojson) => {\n        this._geojson = geojson;\n        return geojson;\n      });\n    });\n  }\n}\n","export const WEBMAP_BASELAYER_ID_PREFIX = 'webmap-baselayer';\n","import { Geometry } from 'geojson';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createGeoJsonFeature,\n  FEATURE_REQUEST_PARAMS,\n  updateItemRequestParam,\n} from './featureLayerUtils';\n\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  NgwFeatureItemResponse,\n  FeatureRequestParams,\n  FetchNgwItemOptions,\n} from '../interfaces';\n\nexport function fetchNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G>> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  updateItemRequestParam(params, options);\n  const queryParams = {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params,\n  };\n  const cache = options.cache || true;\n  return options.connector\n    .get('feature_layer.feature.item', { cache }, queryParams)\n    .then((resp) => {\n      return {\n        ...resp,\n        toGeojson: () => {\n          if (resp.geom) {\n            return CancelablePromise.resolve(createGeoJsonFeature<G, P>(resp));\n          } else {\n            return fetchNgwLayerItem({\n              ...options,\n              geom: true,\n              fields: null,\n              extensions: null,\n            }).then((onlyGeomItem) => {\n              const geom = onlyGeomItem.geom;\n              return createGeoJsonFeature<G, P>({ ...resp, geom });\n            });\n          }\n        },\n      } as NgwFeatureItemResponse<P, G>;\n    });\n}\n","import { fetchNgwLayerItem } from './fetchNgwLayerItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FetchNgwItemOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>,\n>(options: FetchNgwItemOptions<P>): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerItem<G, P>(options).then((item) => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  JsonMap,\n  degrees2meters,\n  getCirclePolygonCoordinates,\n  deprecatedMapClick,\n} from '@nextgis/utils';\nimport { IdentifyItem } from '../IdentifyItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type { MapClickEvent } from '@nextgis/webmap';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  LayerFeature,\n  FeatureLayersIdentify,\n} from '@nextgis/ngw-connector';\nimport type {\n  FeatureIdentifyRequestOptions,\n  GetIdentifyGeoJsonOptions,\n  IdentifyRequestOptions,\n  NgwFeatureItemResponse,\n  IdentifyItemOptions,\n  NgwIdentifyItem,\n  NgwIdentify,\n} from '../interfaces';\n\nexport function getIdentifyItems(\n  identify: NgwIdentify,\n  multiple = false,\n): NgwIdentifyItem[] {\n  let params:\n    | { resourceId: number; featureId: number; feature: LayerFeature }\n    | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort((a, b) => {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const identifyItem = identify[l];\n    if ('features' in identifyItem) {\n      const layerFeatures = identifyItem.features;\n      const resourceId = Number(l);\n      const feature: LayerFeature | undefined = layerFeatures[0];\n      if (feature) {\n        params = {\n          featureId: feature.id,\n          resourceId,\n          feature,\n        };\n        paramsList.push(params);\n        if (!multiple) {\n          break;\n        }\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function fetchIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      if ('features' in item) {\n        const withGeom = item.features.find((x) => x.geom);\n\n        if (withGeom && withGeom.geom) {\n          const geom = withGeom.geom as Geometry;\n          return CancelablePromise.resolve(\n            createGeoJsonFeature({\n              ...withGeom,\n              geom,\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerFeature({ connector, ...params[0] });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\nexport function fetchIdentifyItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: GetIdentifyGeoJsonOptions<G, P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n  const { connector, identify } = options;\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerItem<G, P>({\n      connector,\n      ...options.requestOptions,\n      ...params[0],\n    });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\n/**\n * @deprecated use {@link fetchIdentifyGeoJson} instead\n */\nexport function getIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  return fetchIdentifyGeoJson(options);\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  deprecatedMapClick(ev);\n  const [lng, lat] = ev.lngLat;\n\n  let geom: number[][] = [];\n\n  if (options.geom) {\n    const polygon =\n      options.geom.type === 'Feature'\n        ? options.geom.geometry\n        : options.geom.type === 'Polygon'\n        ? options.geom\n        : false;\n    if (polygon) {\n      geom = polygon.coordinates[0];\n    }\n  }\n  if (!geom.length) {\n    geom = getCirclePolygonCoordinates(lng, lat, options.radius);\n  }\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers,\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\nexport function createIdentifyItem<\n  F = FeatureProperties,\n  G extends Geometry = Geometry,\n>(opt: IdentifyItemOptions): IdentifyItem<F, G> {\n  return new IdentifyItem<F, G>(opt);\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport { CompanyLogoOptions } from '../interfaces';\n\nexport async function getCompanyLogo(\n  connector: NgwConnector,\n  options?: CompanyLogoOptions,\n): Promise<HTMLElement | undefined> {\n  const settings = await connector.get('pyramid.settings', null, {\n    component: 'pyramid',\n  });\n  if (settings && settings.company_logo && settings.company_logo.enabled) {\n    const anchor = document.createElement('a');\n    anchor.style.position = 'absolute';\n    anchor.style.bottom = '0';\n    anchor.style.right = '0';\n    anchor.style.padding = options?.padding ?? '10px';\n    anchor.className = 'ngw-map-logo';\n    if (options && options.cssClass) {\n      anchor.className += ' ' + options.cssClass;\n    }\n    const img = new Image();\n    img.style.maxHeight = '100px';\n    img.style.maxWidth = '100px';\n    img.src = '';\n    try {\n      const src = await connector.get('pyramid.company_logo', {\n        responseType: 'blob',\n      });\n      const urlCreator = window.URL || window.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(src);\n      img.src = imageUrl;\n    } catch (er) {\n      console.log(er);\n    }\n\n    if (\n      settings.company_logo.link !== null &&\n      settings.company_logo.link.trim() !== ''\n    ) {\n      anchor.href = settings.company_logo.link;\n      anchor.target = '_blank';\n      if (settings.company_logo.link.search(/:\\/\\/nextgis/) !== -1) {\n        img.alt = 'Get your own Web GIS at nextgis.com';\n      }\n    }\n    anchor.appendChild(img);\n    return anchor;\n  }\n}\n","import type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type { NgwResourceDefinition } from '../interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: Partial<NgwLayerOptions>,\n  overwriteOptions?: Partial<NgwLayerOptions>,\n): void {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resource,\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({\n      ...defOptions,\n      resource: resourceId,\n      id,\n      ...overwriteOptions,\n    });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n","import { deepmerge } from '@nextgis/utils';\nimport { StarterKit, MapOptions } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { NgwKit } from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from '../interfaces';\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  whitlabel: false,\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"https://nextgis.com\" target=\"_blank\">©NextGIS</a>',\n      ],\n    },\n  },\n  pixelRadius: 10,\n};\n\nexport function prepareWebMapOptions(options: NgwMapOptions): MapOptions {\n  const kits: StarterKit[] = [new QmsKit()];\n  if (options.starterKits) {\n    options.starterKits.forEach((x) => {\n      kits.push(x);\n    });\n  }\n\n  if (!options.connector) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl || '',\n      auth: options.auth,\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  options = deepmerge(OPTIONS, options);\n\n  if (!options.center && !options.bounds) {\n    options.bounds = [-179, -90, 180, 90];\n    options.maxBounds = options.bounds;\n  }\n\n  if (options.connector) {\n    kits.push(\n      new NgwKit({\n        connector: options.connector,\n        auth: options.auth,\n      }),\n    );\n  }\n  options = {\n    ...options,\n    starterKits: kits,\n    create: false,\n  };\n  return options;\n}\n","import { LngLatArray } from '@nextgis/utils';\n\nexport function getIdentifyRadius(\n  center: LngLatArray,\n  zoom: number,\n  pixelRadius: number,\n): number {\n  pixelRadius = pixelRadius ?? 10;\n  const metresPerPixel =\n    (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n    Math.pow(2, zoom + 8);\n  const radius = pixelRadius * metresPerPixel * 0.0005;\n  return radius;\n}\n","import StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined, isObject } from '@nextgis/utils';\nimport { AdapterOptions, WebMap } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\n\nimport {\n  fetchNgwLayerFeatureCollection,\n  fetchNgwResourceExtent,\n  createNgwLayerAdapter,\n  fetchNgwLayerFeature,\n  fetchIdentifyGeoJson,\n  sendIdentifyRequest,\n  createIdentifyItem,\n  fetchNgwLayerItems,\n  fetchIdentifyItem,\n  fetchNgwLayerItem,\n  getIdentifyItems,\n  getCompanyLogo,\n} from '@nextgis/ngw-kit';\nimport { deprecatedWarn } from '@nextgis/utils';\nimport { getIcon } from '@nextgis/icons';\n\nimport { appendNgwResources } from './utils/appendNgwResources';\nimport { prepareWebMapOptions } from './utils/prepareWebMapOptions';\n\nimport type { JsonMap, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureItem,\n  LayerFeature,\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureLayersIdentifyItems,\n} from '@nextgis/ngw-connector';\nimport type {\n  OnLayerClickOptions,\n  ControlPosition,\n  FilterOptions,\n  MapClickEvent,\n  LayerAdapter,\n  WebMapEvents,\n  MapControls,\n  FitOptions,\n  LayerDef,\n} from '@nextgis/webmap';\nimport type {\n  NgwIdentify,\n  NgwWebmapItem,\n  ResourceAdapter,\n  FetchNgwItemsOptions,\n  NgwFeatureItemResponse,\n  NgwFeatureRequestOptions,\n} from '@nextgis/ngw-kit';\nimport type { Geometry, Feature, FeatureCollection } from 'geojson';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type {\n  NgwIdentifyEvent,\n  NgwMapOptions,\n  NgwMapEvents,\n  NgwLayers,\n} from './interfaces';\nimport type { FetchNgwItemOptions } from '@nextgis/ngw-kit';\nimport { getIdentifyRadius } from './utils/getIentifyRadius';\n\ntype PromiseGroup = 'select' | 'identify';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import { NgwMap } from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n *   qmsId: 448,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<\n  M = unknown,\n  L = unknown,\n  C = unknown,\n  O extends NgwMapOptions<C> = NgwMapOptions<C>,\n> extends WebMap<M, L, C, NgwMapEvents, O> {\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<EventEmitter, NgwMapEvents> =\n    new EventEmitter();\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private $$selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private $$selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n  private _promises: Record<PromiseGroup, CancelablePromise[]> = {\n    select: [],\n    identify: [],\n  };\n\n  constructor(options: O) {\n    super(prepareWebMapOptions(options) as O);\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      if (this.options.whitlabel) {\n        this._whiteLabel();\n      }\n    });\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param options - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    await this.onLoad('controls:create');\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource definition.\n   * @param options - set layer identification parameters and render method.\n   *\n   * @example\n   * ```javascript\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resource: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resource: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  async addNgwLayer(\n    options: NgwLayerOptions,\n  ): Promise<ResourceAdapter | undefined> {\n    await this.onMapLoad();\n    // @ts-ignore for backward compatibility\n    const { keyname, resourceId } = options;\n\n    if (keyname || resourceId !== undefined) {\n      deprecatedWarn(\n        'set `resource` options instead of `keyname` or `resourceId`',\n      );\n    }\n\n    const resource = options.resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resource, resourceId or keyname is required parameter to add NGW layer',\n      );\n    }\n    if (defined(this.options.baseUrl)) {\n      try {\n        if (defined(this.options.setViewDelay)) {\n          options.adapterOptions = options.adapterOptions || {};\n          if (!defined(options.adapterOptions.setViewDelay)) {\n            options.adapterOptions.setViewDelay = this.options.setViewDelay;\n          }\n        }\n        const adapter = createNgwLayerAdapter(options, this, this.connector);\n        const adapterOpts = {\n          visibility: true,\n          // TODO: do not merge options, use only `adapterOptions`\n          ...options,\n          ...options.adapterOptions,\n        } as AdapterOptions;\n        const layer = (await this.addLayer(\n          adapter,\n          adapterOpts,\n        )) as ResourceAdapter<M, L, AdapterOptions>;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n          layer.options.name =\n            layer.options.name ||\n            (layer.item && layer.item.resource.display_name);\n          if (layer.options.baselayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n        return layer;\n      } catch (er) {\n        const resId =\n          isObject(resource) && 'id' in resource\n            ? resource.id\n            : keyname || resourceId || resource;\n        console.error(`Can't add NGW layer ${resId}.`, er);\n      }\n    }\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit(): void {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  fetchNgwLayerItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureItem> {\n    return fetchNgwLayerItem<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerItems<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(\n    options: Omit<FetchNgwItemsOptions<F>, 'connector'>,\n  ): CancelablePromise<FeatureItem<F, G>[]> {\n    return fetchNgwLayerItems<G, F>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<Feature<G, P>> {\n    return fetchNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemsOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return fetchNgwLayerFeatureCollection({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchIdentifyItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    identify: NgwIdentify,\n    requestOptions?: NgwFeatureRequestOptions,\n    // multiple = false\n  ): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n    const promise = fetchIdentifyItem<G, P>({\n      identify,\n      connector: this.connector,\n      requestOptions,\n      // multiple,\n    });\n\n    this._addPromise('identify', promise);\n    return promise;\n  }\n\n  fetchIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    const promise = fetchIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple,\n    });\n    if (promise && 'then' in promise) {\n      this._addPromise('identify', promise);\n      return promise;\n    } else {\n      return CancelablePromise.resolve(promise);\n    }\n  }\n\n  /**\n   * @deprecated use {@link fetchIdentifyGeoJson} instead\n   */\n  getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    return this.fetchIdentifyGeoJson(identify, multiple);\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some((x) => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as NgwWebmapItem[];\n        const dependFit = dependLayers.find((x) => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.fitLayer(ngwLayer);\n   * ngwMap.fitLayer('ngw_layer_name');\n   * ```\n   */\n  async fitLayer(layerDef: LayerDef, options?: FitOptions): Promise<void> {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent, options);\n        }\n      } else {\n        let item: ResourceItem | undefined;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.getResource(resourceId);\n        }\n        if (item) {\n          fetchNgwResourceExtent(item, this.connector).then((extent) => {\n            if (extent) {\n              this.fitBounds(extent, options);\n            }\n          });\n        }\n      }\n    } else {\n      super.fitLayer(layerDef, options);\n    }\n  }\n\n  /** @deprecated use {@link NgwMap.fitLayer} instead */\n  async zoomToLayer(layerDef: string | ResourceAdapter): Promise<void> {\n    return this.fitLayer(layerDef);\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection(): void {\n    if (!this.$$selectFromNgwRaster) {\n      this.$$selectFromNgwRaster = (ev: MapClickEvent) => {\n        const count = this.emitter.listenerCount('ngw:select');\n        if (count) {\n          this._selectFromNgwRaster(ev);\n        }\n      };\n      this.$$selectFromNgwVector = (ev: OnLayerClickOptions) => {\n        if (this.emitter.listenerCount('ngw:select')) {\n          this._selectFromNgwVector(ev);\n        }\n      };\n      this.emitter.on('click', this.$$selectFromNgwRaster);\n      this.emitter.on('layer:click', this.$$selectFromNgwVector);\n    }\n  }\n\n  disableSelection(): void {\n    if (this.$$selectFromNgwRaster) {\n      this.emitter.removeListener('click', this.$$selectFromNgwRaster);\n      this.emitter.removeListener('click', this._selectFromNgwVector);\n      this.$$selectFromNgwRaster = undefined;\n      this.$$selectFromNgwVector = undefined;\n    }\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItem} instead\n   */\n  getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return this.fetchNgwLayerItem(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItems} instead\n   */\n  getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions,\n  ): CancelablePromise<FeatureItem[]> {\n    return this.fetchNgwLayerItems(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeature} instead\n   */\n  getNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends JsonMap = JsonMap,\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return this.fetchNgwLayerFeature(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeatures} instead\n   */\n  getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends JsonMap = JsonMap,\n  >(\n    options: FetchNgwItemsOptions<P>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return this.fetchNgwLayerFeatures(options);\n  }\n\n  /** @deprecated use {@link NgwMap.cancelPromises} instead */\n  cancelPromise(...args: PromiseGroup[]): void {\n    this.cancelPromises(...args);\n  }\n\n  cancelPromises(...args: PromiseGroup[]): void {\n    if (!args.length) {\n      args = Object.keys(this._promises) as PromiseGroup[];\n    }\n    args.forEach((name) => {\n      const group = this._promises[name];\n      if (group) {\n        group.forEach((x) => x.cancel());\n        this._promises[name] = [];\n      }\n    });\n  }\n\n  private _addPromise(groupName: PromiseGroup, promise: CancelablePromise) {\n    const group = this._promises[groupName];\n    if (group && group.indexOf(promise) === -1) {\n      const removeFromGroup = () => {\n        const index = group.indexOf(promise);\n        if (index !== -1) {\n          group.splice(index, 1);\n        }\n      };\n      promise.then(removeFromGroup);\n      promise.catch(removeFromGroup);\n      group.push(promise);\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create();\n    if (this.options.qmsId) {\n      this._addQmsBaseLayer();\n    }\n    if (this.options.osm) {\n      this._addOsmBaseLayer();\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed,\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach((x) => {\n        const overwriteOptions: Partial<NgwLayerOptions> = {};\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n    for (const r of resources) {\n      try {\n        await this.addNgwLayer(r);\n      } catch (er) {\n        console.log(er);\n      }\n    }\n    this._emitStatusEvent('ngw-map:create', this);\n    this.enableSelection();\n  }\n\n  private _addOsmBaseLayer() {\n    this.addBaseLayer('OSM');\n  }\n\n  private _addQmsBaseLayer() {\n    let qmsId: number;\n    let qmsLayerName: string | undefined;\n    if (Array.isArray(this.options.qmsId)) {\n      qmsId = this.options.qmsId[0];\n      qmsLayerName = this.options.qmsId[1];\n    } else {\n      qmsId = Number(this.options.qmsId);\n    }\n    const qmsLayerOptions: Partial<QmsAdapterOptions> = {\n      qmsId,\n    };\n    if (qmsLayerName) {\n      qmsLayerOptions.id = qmsLayerName;\n    }\n\n    this.addBaseLayer('QMS', qmsLayerOptions);\n  }\n\n  private _selectFromNgwVector(\n    ev: OnLayerClickOptions,\n  ): FeatureLayersIdentify | undefined {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties || {},\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry,\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature],\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items,\n        };\n        this._emitStatusEvent(\n          'ngw:select',\n          this._prepareToIdentify({\n            ...identify,\n            resources: [id],\n            sourceType: 'vector',\n          } as NgwIdentify),\n        );\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    const layers = Object.values(this._ngwLayers);\n    layers.sort((a, b) => {\n      if (a.layer.order && b.layer.order) {\n        return b.layer.order - a.layer.order;\n      }\n      return 1;\n    });\n    layers.forEach((l) => {\n      const layer = l.layer;\n      const identFunc =\n        typeof layer.getIdentificationIds === 'function'\n          ? layer.getIdentificationIds\n          : false;\n      if (identFunc && layer.options.selectable && this.isLayerVisible(layer)) {\n        promises.push(identFunc.call(layer));\n      }\n    });\n    const getIdsPromise = Promise.all(promises);\n    const getIds = await getIdsPromise;\n    const ids: number[] = [];\n    getIds.forEach((x) => {\n      if (x) {\n        x.forEach((y) => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    let zoom = this.getZoom();\n    zoom = zoom !== undefined ? zoom : 20;\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const radius = getIdentifyRadius(center, zoom, pixelRadius);\n\n    const selectPromise = sendIdentifyRequest(ev, {\n      layers: ids,\n      connector: this.connector,\n      radius,\n    }).then((resp) => {\n      this._emitStatusEvent(\n        'ngw:select',\n        this._prepareToIdentify({\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev,\n        }),\n      );\n      return resp;\n    });\n    this._addPromise('select', selectPromise);\n    return selectPromise;\n  }\n\n  private _prepareToIdentify<\n    F = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(identify: NgwIdentify): NgwIdentifyEvent {\n    const getIdentifyItems_ = () => {\n      return getIdentifyItems(identify, true).map((x) => {\n        return createIdentifyItem<F, G>({\n          feature: x.feature,\n          connector: this.connector,\n        });\n      });\n    };\n    return {\n      ...identify,\n      getIdentifyItems: getIdentifyItems_,\n    };\n  }\n\n  private async _whiteLabel() {\n    const container = this.getContainer();\n    if (container) {\n      const logo = await getCompanyLogo(\n        this.connector,\n        this.options.companyLogoOptions,\n      );\n      if (logo) {\n        container.appendChild(logo);\n      }\n    }\n  }\n}\n"],"names":["createPopupContent","feature","item","element","document","createElement","feature_layer","fields","forEach","x","grid_visibility","value","properties","keyname","propElem","appendChild","innerHTML","display_name","p","filterOptionsKeys","getLayerFilterOptions","options","filterOptions","opt","undefined","getNgwWebmapExtent","webmap","bottom","left","top","right","extent","fetchNgwLayerExtent","resourceId","connector","cache","get","id","then","resp","maxLat","maxLon","minLat","minLon","fetchNgwResourceExtent","CancelablePromise","resource","cls","indexOf","getResource","parent","res","resourceIdFromLayerOptions","resourceItem","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","geometry","geom","type","updateItemRequestParam","params","extensions","join","Array","isArray","defined","createFeatureFieldFilterQueries","_queries","_parentAllParams","filters","logic","filters_","filter","createParam","pf","field","operation","f","checkIfPropertyFilter","push","fetchNgwLayerItemsRequest","paramList","propertiesFilterList","length","itemsParts","items","reduce","a","b","concat","offset","limit","splice","polygon","intersects","orderBy","Number","POSITIVE_INFINITY","order_by","coordinates","isLngLatBoundsArray","getBoundsCoordinates","map","lng","lat","degrees2meters","reqParams","prepareNgwFieldsToPropertiesFilter","isObject","date","year","month","day","dt","hour","minute","second","Date","toISOString","fetchNgwLayerItems","data","y","propertiesFilter","fetchNgwLayerFeatureCollection","features","fetchNgwLayerFeatures","createGeoJsonAdapter","props","webMap","Adapter","layerOptions","alop","addLayerOptionsPriority","GeoJsonAdapter","mapAdapter","layerAdapters","GEOJSON","_fullDataLoad","adapterOptions","popupOptions","fromProperties","getData","filterOpt","abort","_lastFilterArgs","_dataPromise","removed","cancel","NgwGeoJsonAdapter","EventEmitter","needUpdate","waitFullLoad","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","Object","keys","layer","this","strategy","updatePromise","updateLayer","_addBboxEventListener","hasData","getLayers","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","__onMapMoveStart","_count","total_count","filterArgs","onLoad","getBounds","getCount","count","setLayerData","emitter","emit","Error","name","e","props_","setData","clearLayer","_addMoveEventListener","on","debounce","removeListener","ngwApiToAdapterOptions","url","baseUrl","adapter","getLayerAdapters","isImageAllowed","IMAGE","nd","tileNoData","headers","updateWmsParams","updateImageParams","format","version","layers","simplification","console","log","createRasterAdapter","resourceCls","clsAdapterAlias","wmsserver_service","tmsclient_layer","AdapterClass","_options","layerAdapterOptions","setViewDelay","String","addOptions","NgwWebmapItem","noInit","tree","setParent","item_type","_rootDescendantsCount","_sumUp","children","root","getRoot","initProperties","_init","i","getItemOptions","setNewLayer","l","_layer","set","opacity","setLayerOpacity","getChildren","addChild","Promise","resolve","layer_adapter","toUpperCase","GetAdapterFromLayerType","getAdapter","addLayer","newLayer","reject","transparency","layer_transparency","visibility","crossOrigin","order","subOrder","drawOrderEnabled","draw_order_position","subLevel","padStart","maxZoom","layer_max_scale_denom","_mapScaleToZoomLevel","minZoom","layer_min_scale_denom","objectAssign","ratio","minScale","maxScale","reverse","scale","centerLat","getZoomFromScale","pixelsInMeterWidth","getMapWidthForLanInMeters","setScaleRatio","initItem","totalValue","child","ngwWebmapItem","Item","createOnFirstShowAdapter","onLayerAdded","createAdapter","OnFirstShowAdapter","_removed","removeLayer","showLayer","loadLayer","_creatingInProgress","baselayer","realLayer","assign","hideLayer","idPrefix","OnFirstNgwShowAdapter","resource_id","createAsyncAdapter","getProperty","treeSome","layer_enabled","onSet","BookmarkItem","labelField","_extent","fid","lonLat","fetchNgwLayerItem","featureId","onlyGeomItem","NgwWebmapLayerAdapter","r","_getWebMapLayerItem","getDependLayers","response","_webmapLayersIds","property","getDescendants","bookmark_resource","bookmarkResId","getBookmarksResourceId","getResourceOrFail","find","label_field","bookmarks","bookmark","visibleLayers","ids","_getWebMapIds","sort","parentId","visible","isBlocked","getWebMapConfig","root_item","auth","getAuthorizationHeaders","draw_order_enabled","webmapClassName","basemap_webmap","basemaps","_setBasemaps","defaultBasemap","addBaseLayer","extent_left","extent_bottom","extent_right","extent_top","_updateItemsParams","baseWebmap","enabledAlreadySet","createOnFirstShowNgwAdapter","enabled","WEBMAP_BASELAYER_ID_PREFIX","fixUrlStr","layer_style_id","webMapItem","promises","promise","all","createWebMapAdapter","NWLayerAdapter","NgwResource","createBasemapLayerAdapter","basemap_layer","qms","qms_","JSON","parse","QmsKit","TileAdapter","TILE","BasemapTileAdapter","classAdapters","supportCls","createAdapterFromFirstStyle","getResourceChildren","childrenStyles","firstStyle","adapterType","itemFromResOpt","parentItem","parentOptions","getClassAdapter","classAdapter","resourceAdapter","prototype","applyMixins","replace","bbox","width","height","size","timestamp","now","_pixelsInMeter","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","createNgwLayerAdapter","extendNgwWebmapLayerAdapter","div","style","cssText","body","px","offsetWidth","removeChild","Math","PI","cos","LN2","NgwKit","NgwConnector","resourceIds","fit","pixelRadius","_getLayerAdapter","_createAdapter","IdentifyItem","label","layerId","_item","_resource","_geojson","identify","toGeojson","geojson","queryParams","fetchNgwLayerFeature","getIdentifyItems","multiple","resources","paramsList","isNaN","sortingArr","fry","identifyItem","layerFeatures","fetchIdentifyGeoJson","withGeom","fetchIdentifyItem","requestOptions","sendIdentifyRequest","ev","deprecatedMapClick","lngLat","getCirclePolygonCoordinates","radius","post","createIdentifyItem","getCompanyLogo","component","settings","company_logo","anchor","position","padding","className","cssClass","img","Image","maxHeight","maxWidth","src","responseType","urlCreator","window","URL","webkitURL","imageUrl","createObjectURL","link","trim","href","target","search","alt","appendNgwResources","defOptions","overwriteOptions","OPTIONS","whitlabel","controls","controlsOptions","ZOOM","ATTRIBUTION","customAttribution","getIdentifyRadius","center","zoom","abs","pow","NgwMap","kits","starterKits","deepmerge","bounds","maxBounds","create","prepareWebMapOptions","select","_createWebMap","container","getContainer","classList","add","_whiteLabel","controlDef","onMapLoad","deprecatedWarn","adapterOpts","getLayerId","_ngwLayers","getActiveBaseLayer","resId","error","setCenter","setZoom","fitBounds","_addPromise","n","mem","getIdentificationIds","some","dependLayers","dependFit","layerDef","ngwLayer","getExtent","fitLayer","event","getLayer","$$selectFromNgwRaster","listenerCount","_selectFromNgwRaster","$$selectFromNgwVector","_selectFromNgwVector","cancelPromises","args","_promises","group","groupName","removeFromGroup","index","catch","_initMapState","qmsId","_addQmsBaseLayer","osm","_addOsmBaseLayer","layerFitAllowed","_isFitFromResource","webmapId","addNgwLayer","_emitStatusEvent","enableSelection","qmsLayerName","qmsLayerOptions","featureCount","_prepareToIdentify","sourceType","values","identFunc","selectable","isLayerVisible","call","getIdsPromise","getIds","getCenter","getZoom","selectPromise","companyLogoOptions","logo","WebMap","getIcon"],"sourceRoot":""}