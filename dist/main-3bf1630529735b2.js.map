{"version":3,"file":"main-3bf1630529735b2.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/paint/src/typeHelpers.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/fromPaintExpression.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/preparePaint.ts","webpack://clear_horizon/./@nextgis/packages/properties-filter/src/propertiesFilter.ts"],"sourcesContent":["import type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  PropertiesPaint,\n  GeometryPaint,\n  Expression,\n  IconPaint,\n  Paint,\n} from './interfaces';\n\nexport function isExpression(value: unknown): value is Expression {\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { isExpression } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  Expression,\n  ExpressionName,\n} from './interfaces';\n\ntype ExpressionFun = (feature: Feature, args: any[]) => SimpleType;\n\nfunction get(feature: Feature, args: any[]) {\n  const field = args[0];\n  return feature.properties && feature.properties[field];\n}\n\nfunction match(feature: Feature, args: any[]) {\n  const [lookup, ...cases] = args;\n  let property = lookup;\n  if (Array.isArray(lookup)) {\n    property = featureExpression(feature, lookup as Expression);\n  }\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry];\n    if (key === property) {\n      return cases[fry + 1];\n    }\n  }\n  return defValue;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFun } = {\n  get,\n  match,\n};\n\ntype SimpleType = string | number | boolean | undefined;\n\ntype PropertyExpressionCb = (feature: Feature) => SimpleType;\n\nfunction featureExpression(feature: Feature, expression: Expression) {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(feature, args);\n  }\n  return undefined;\n}\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    return featureExpression(feature, expression);\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: Record<string, any>,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  Paint,\n  PropertyPaint,\n  GeometryPaint,\n  PropertiesPaint,\n  GetPaintCallback,\n  GetPaintFunction,\n  GetCustomPaintOptions,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  for (const p of propertiesPaint) {\n    if (p) {\n      if (Array.isArray(p)) {\n        paintsFilters.push(p);\n      } else {\n        mask = p as VectorAdapterLayerPaint;\n      }\n    }\n  }\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nexport function expressionCallback<P = Record<string, any>>(\n  paint: P,\n  defaultPaint?: P,\n  getPaintFunctions?: Record<string, GetPaintFunction>,\n) {\n  const expressionCallback = createExpressionCallback(paint);\n  if (expressionCallback) {\n    const expressionPaintCb = (feature: Feature) => {\n      return preparePaint(\n        expressionCallback(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n    expressionPaintCb.paint = paint;\n    return expressionPaintCb;\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  newPaint = { ...newPaint, ...paint };\n  newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n  newPaint.stroke =\n    newPaint.stroke !== undefined\n      ? newPaint.stroke\n      : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  return newPaint;\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint?: GeometryPaint,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint(\n        paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    newPaint = expressionCallback(paint, defaultPaint, getPaintFunctions);\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import type { Feature } from 'geojson';\nimport type {\n  Operation,\n  Properties,\n  PropertiesFilter,\n  PropertyFilter,\n} from './interfaces';\n\nfunction reEscape(s: string): string {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operation]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function isPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/** @deprecated use {@link isPropertyFilter} instead */\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  return isPropertyFilter(filter);\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter,\n): boolean {\n  const properties: Properties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter<T extends Properties = Properties>(\n  properties: T,\n  filters: PropertiesFilter<T>,\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (isPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n"],"names":["isPaint","paint","Object","prototype","toString","call","isPaintCallback","expressions","get","feature","args","field","properties","match","lookup","cases","property","Array","isArray","featureExpression","defValue","splice","length","fry","expression","name","expressionFun","createPropertyExpressionCb","excludeExpressionList","preparePaint","defaultPaint","getPaintFunctions","Error","newPaint","getPaintFunction","getPaint","type","isPropertiesPaint","propertiesPaint","mask","paintsFilters","p","push","find","x","featureFilter","createPropertiesPaint","from","options","updatePaintOptionFromCallback","expressionCallback","value","withExpression","indexOf","p_","val","fromCb","createExpressionCallback","expressionPaintCb","fill","undefined","stroke","strokeColor","strokeOpacity","color","fillColor","opacity","fillOpacity","like","b","a","iLike","String","toUpperCase","s","re","replace","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","ilike","isPropertyFilter","filter","pf","filters","$id","id","propertiesFilter","logic","filterFunction","operation","operationExec","prop","value_","cleanField","filters_","some","every"],"sourceRoot":""}