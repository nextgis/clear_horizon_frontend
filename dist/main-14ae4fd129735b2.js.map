{"version":3,"file":"main-14ae4fd129735b2.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/appendNgwResources.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/prepareWebMapOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/NgwMap.ts"],"sourcesContent":["import type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type { NgwResourceDefinition } from '../interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: Partial<NgwLayerOptions>,\n  overwriteOptions?: Partial<NgwLayerOptions>,\n): void {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resource,\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({\n      ...defOptions,\n      resource: resourceId,\n      id,\n      ...overwriteOptions,\n    });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n","import { deepmerge } from '@nextgis/utils';\nimport { StarterKit, MapOptions } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { NgwKit } from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from '../interfaces';\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  whitlabel: false,\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"https://nextgis.com\" target=\"_blank\">©NextGIS</a>',\n      ],\n    },\n  },\n  pixelRadius: 10,\n};\n\nexport function prepareWebMapOptions(options: NgwMapOptions): MapOptions {\n  const kits: StarterKit[] = [new QmsKit()];\n  if (options.starterKits) {\n    options.starterKits.forEach((x) => {\n      kits.push(x);\n    });\n  }\n\n  if (!options.connector) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl || '',\n      auth: options.auth,\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  options = deepmerge(OPTIONS, options);\n\n  if (!options.center && !options.bounds) {\n    options.bounds = [-179, -90, 180, 90];\n    // options.maxBounds = options.bounds;\n  }\n\n  if (options.connector) {\n    kits.push(\n      new NgwKit({\n        connector: options.connector,\n        auth: options.auth,\n      }),\n    );\n  }\n  options = {\n    ...options,\n    starterKits: kits,\n    create: false,\n  };\n  return options;\n}\n","import StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined, isObject, getIdentifyRadius } from '@nextgis/utils';\nimport { AdapterOptions, WebMap } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\n\nimport {\n  fetchNgwLayerFeatureCollection,\n  fetchNgwResourceExtent,\n  createNgwLayerAdapter,\n  fetchNgwLayerFeature,\n  fetchIdentifyGeoJson,\n  sendIdentifyRequest,\n  createIdentifyItem,\n  fetchNgwLayerItems,\n  fetchIdentifyItem,\n  fetchNgwLayerItem,\n  getIdentifyItems,\n  getCompanyLogo,\n  fetchNgwExtent,\n} from '@nextgis/ngw-kit';\nimport { deprecatedWarn } from '@nextgis/utils';\nimport { getIcon } from '@nextgis/icons';\n\nimport { appendNgwResources } from './utils/appendNgwResources';\nimport { prepareWebMapOptions } from './utils/prepareWebMapOptions';\n\nimport type { JsonMap, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureItem,\n  LayerFeature,\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureLayersIdentifyItems,\n} from '@nextgis/ngw-connector';\nimport type {\n  OnLayerMouseOptions,\n  ControlPosition,\n  MapClickEvent,\n  LayerAdapter,\n  WebMapEvents,\n  MapControls,\n  FitOptions,\n  LayerDef,\n} from '@nextgis/webmap';\nimport type {\n  NgwIdentify,\n  NgwWebmapItem,\n  ResourceAdapter,\n  FetchNgwItemsOptions,\n  NgwFeatureItemResponse,\n  NgwFeatureRequestOptions,\n} from '@nextgis/ngw-kit';\nimport type { Geometry, Feature, FeatureCollection } from 'geojson';\nimport type { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type {\n  NgwIdentifyEvent,\n  NgwMapOptions,\n  NgwMapEvents,\n  NgwLayers,\n} from './interfaces';\nimport type { FetchNgwItemOptions } from '@nextgis/ngw-kit';\n\ntype PromiseGroup = 'select' | 'identify';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import { NgwMap } from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n *   qmsId: 448,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<\n  M = unknown,\n  L = unknown,\n  C = unknown,\n  O extends NgwMapOptions<M, C> = NgwMapOptions<M, C>,\n> extends WebMap<M, L, C, NgwMapEvents, O> {\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<EventEmitter, NgwMapEvents> =\n    new EventEmitter();\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private $$selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private $$selectFromNgwVector?: (ev: OnLayerMouseOptions) => void;\n  private _promises: Record<PromiseGroup, CancelablePromise[]> = {\n    select: [],\n    identify: [],\n  };\n\n  constructor(options: O) {\n    super(prepareWebMapOptions(options) as O);\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      if (this.options.whitlabel) {\n        this._whiteLabel();\n      }\n    });\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param options - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    await this.onLoad('controls:create');\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource definition.\n   * @param options - set layer identification parameters and render method.\n   *\n   * @example\n   * ```javascript\n   * // Add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resource: 4005 });\n   * // Add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resource: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  async addNgwLayer(\n    options: NgwLayerOptions,\n  ): Promise<ResourceAdapter | undefined> {\n    await this.onMapLoad();\n    // @ts-ignore for backward compatibility\n    const { keyname, resourceId } = options;\n\n    if (keyname || resourceId !== undefined) {\n      deprecatedWarn(\n        'set `resource` options instead of `keyname` or `resourceId`',\n      );\n    }\n\n    const resource = options.resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resource, resourceId or keyname is required parameter to add NGW layer',\n      );\n    }\n    if (defined(this.options.baseUrl)) {\n      try {\n        if (defined(this.options.setViewDelay)) {\n          options.adapterOptions = options.adapterOptions || {};\n          if (!defined(options.adapterOptions.setViewDelay)) {\n            options.adapterOptions.setViewDelay = this.options.setViewDelay;\n          }\n        }\n        const adapter = createNgwLayerAdapter(options, this, this.connector);\n        const adapterOpts = {\n          visibility: true,\n          // TODO: do not merge options, use only `adapterOptions`\n          ...options,\n          ...options.adapterOptions,\n        } as AdapterOptions;\n        const layer = (await this.addLayer(\n          adapter,\n          adapterOpts,\n        )) as ResourceAdapter<M, L, AdapterOptions>;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n          layer.options.name =\n            layer.options.name ||\n            (layer.item && layer.item.resource.display_name);\n          if (layer.options.baselayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n        return layer;\n      } catch (er) {\n        const resId =\n          isObject(resource) && 'id' in resource\n            ? resource.id\n            : keyname || resourceId || resource;\n        console.error(`Can't add NGW layer ${resId}.`, er);\n      }\n    }\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit(): void {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  fetchNgwLayerItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureItem> {\n    return fetchNgwLayerItem<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerItems<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(\n    options: Omit<FetchNgwItemsOptions<F>, 'connector'>,\n  ): CancelablePromise<FeatureItem<F, G>[]> {\n    return fetchNgwLayerItems<G, F>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<Feature<G, P>> {\n    return fetchNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemsOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return fetchNgwLayerFeatureCollection({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchIdentifyItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    identify: NgwIdentify,\n    requestOptions?: NgwFeatureRequestOptions,\n    // multiple = false\n  ): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n    const promise = fetchIdentifyItem<G, P>({\n      identify,\n      connector: this.connector,\n      requestOptions,\n      // multiple,\n    });\n\n    this._addPromise('identify', promise);\n    return promise;\n  }\n\n  fetchIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    const promise = fetchIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple,\n    });\n    if (promise && 'then' in promise) {\n      this._addPromise('identify', promise);\n      return promise;\n    } else {\n      return CancelablePromise.resolve(promise);\n    }\n  }\n\n  /**\n   * @deprecated use {@link fetchIdentifyGeoJson} instead\n   */\n  getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    return this.fetchIdentifyGeoJson(identify, multiple);\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some((x) => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as NgwWebmapItem[];\n        const dependFit = dependLayers.find((x) => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resource: 4005 });\n   * ngwMap.fitLayer(ngwLayer);\n   * ngwMap.fitLayer('ngw_layer_name');\n   * ```\n   */\n  async fitLayer(\n    layerDef: LayerDef | number,\n    options?: FitOptions,\n  ): Promise<void> {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getBounds) {\n        const bounds = await ngwLayer.layer.getBounds();\n        if (bounds) {\n          this.fitBounds(bounds, options);\n        }\n      } else {\n        let item: ResourceItem | undefined;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.getResource(resourceId);\n        }\n        if (item) {\n          fetchNgwExtent({\n            resourceId: item.resource.id,\n            connector: this.connector,\n          }).then((extent) => {\n            if (extent) {\n              this.fitBounds(extent, options);\n            }\n          });\n        }\n      }\n    } else {\n      super.fitLayer(\n        typeof layerDef === 'number' ? String(layerDef) : layerDef,\n        options,\n      );\n    }\n  }\n\n  /** @deprecated use {@link NgwMap.fitLayer} instead */\n  async zoomToLayer(layerDef: string | ResourceAdapter): Promise<void> {\n    return this.fitLayer(layerDef);\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection(): void {\n    if (!this.$$selectFromNgwRaster) {\n      this.$$selectFromNgwRaster = (ev: MapClickEvent) => {\n        const count = this._getSelectListenersCount();\n        if (count) {\n          this.selectFromNgwRaster(ev);\n        }\n      };\n      this.$$selectFromNgwVector = (ev: OnLayerMouseOptions) => {\n        const count = this._getSelectListenersCount();\n        if (count) {\n          this._selectFromNgwVector(ev);\n        }\n      };\n      this.emitter.on('click', this.$$selectFromNgwRaster);\n      this.emitter.on('layer:click', this.$$selectFromNgwVector);\n    }\n  }\n\n  disableSelection(): void {\n    if (this.$$selectFromNgwRaster) {\n      this.emitter.removeListener('click', this.$$selectFromNgwRaster);\n      this.$$selectFromNgwRaster = undefined;\n    }\n    if (this.$$selectFromNgwVector) {\n      this.emitter.removeListener('layer:click', this.$$selectFromNgwVector);\n\n      this.$$selectFromNgwVector = undefined;\n    }\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItem} instead\n   */\n  getNgwLayerItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureItem> {\n    return this.fetchNgwLayerItem<G, P>(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItems} instead\n   */\n  getNgwLayerItems<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(\n    options: Omit<FetchNgwItemsOptions<F>, 'connector'>,\n  ): CancelablePromise<FeatureItem<F, G>[]> {\n    return this.fetchNgwLayerItems<F, G>(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeature} instead\n   */\n  getNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<Feature<G, P>> {\n    return this.fetchNgwLayerFeature<G, P>(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeatures} instead\n   */\n  getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends JsonMap = JsonMap,\n  >(\n    options: FetchNgwItemsOptions<P>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return this.fetchNgwLayerFeatures(options);\n  }\n\n  /** @deprecated use {@link NgwMap.cancelPromises} instead */\n  cancelPromise(...args: PromiseGroup[]): void {\n    this.cancelPromises(...args);\n  }\n\n  cancelPromises(...args: PromiseGroup[]): void {\n    if (!args.length) {\n      args = Object.keys(this._promises) as PromiseGroup[];\n    }\n    args.forEach((name) => {\n      const group = this._promises[name];\n      if (group) {\n        group.forEach((x) => x.cancel());\n        this._promises[name] = [];\n      }\n    });\n  }\n\n  async selectFromNgwRaster(\n    ev: MapClickEvent,\n  ): Promise<NgwIdentifyEvent | undefined> {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    const layers = Object.values(this._ngwLayers);\n    layers.sort((a, b) => {\n      if (a.layer.order && b.layer.order) {\n        return b.layer.order - a.layer.order;\n      }\n      return 1;\n    });\n    for (const l of layers) {\n      const layer = l.layer;\n      const identFunc =\n        typeof layer.getIdentificationIds === 'function'\n          ? layer.getIdentificationIds\n          : false;\n      if (identFunc && layer.options.selectable && this.isLayerVisible(layer)) {\n        promises.push(identFunc.call(layer));\n      }\n    }\n    const getIdsPromise = Promise.all(promises);\n    const getIds = await getIdsPromise;\n    const ids: number[] = [];\n    for (const x of getIds) {\n      if (x) {\n        ids.push(...x);\n      }\n    }\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    let zoom = this.getZoom();\n    zoom = zoom !== undefined ? zoom : 20;\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const radius = getIdentifyRadius(center, zoom, pixelRadius);\n\n    const selectPromise = sendIdentifyRequest(ev, {\n      layers: ids,\n      connector: this.connector,\n      radius,\n    }).then((resp) => {\n      const identify: NgwIdentify = {\n        ...resp,\n        resources: ids,\n        sourceType: 'raster',\n        event: ev,\n      };\n      const identifyEvent: NgwIdentifyEvent = this._prepareToIdentify(identify);\n      this._emitStatusEvent('ngw:select', identifyEvent);\n      return identifyEvent;\n    });\n    this._addPromise('select', selectPromise);\n    return selectPromise;\n  }\n\n  private _addPromise(groupName: PromiseGroup, promise: CancelablePromise) {\n    const group = this._promises[groupName];\n    if (group && group.indexOf(promise) === -1) {\n      const removeFromGroup = () => {\n        const index = group.indexOf(promise);\n        if (index !== -1) {\n          group.splice(index, 1);\n        }\n      };\n      promise.then(removeFromGroup);\n      promise.catch(removeFromGroup);\n      group.push(promise);\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create();\n    if (this.options.qmsId) {\n      this._addQmsBaseLayer();\n    }\n    if (this.options.osm) {\n      this._addOsmBaseLayer();\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed,\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      for (const x of this.options.resources) {\n        const overwriteOptions: Partial<NgwLayerOptions> = {};\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      }\n    }\n    for (const r of resources) {\n      try {\n        await this.addNgwLayer(r);\n      } catch (er) {\n        console.warn(er);\n      }\n    }\n    this._emitStatusEvent('ngw-map:create', this);\n    this.enableSelection();\n  }\n\n  private _addOsmBaseLayer() {\n    this.addBaseLayer('OSM');\n  }\n\n  private _addQmsBaseLayer() {\n    let qmsId: number;\n    let qmsLayerName: string | undefined;\n    if (Array.isArray(this.options.qmsId)) {\n      qmsId = this.options.qmsId[0];\n      qmsLayerName = this.options.qmsId[1];\n    } else {\n      qmsId = Number(this.options.qmsId);\n    }\n    const qmsLayerOptions: Partial<QmsAdapterOptions> = {\n      qmsId,\n    };\n    if (qmsLayerName) {\n      qmsLayerOptions.id = qmsLayerName;\n    }\n\n    this.addBaseLayer('QMS', qmsLayerOptions);\n  }\n\n  private _selectFromNgwVector(\n    ev: OnLayerMouseOptions,\n  ): FeatureLayersIdentify | undefined {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    const selectable = layer.options.selectable && this.isLayerVisible(layer);\n    if (!selectable) {\n      return undefined;\n    }\n    // Item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties || {},\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry,\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature],\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items,\n        };\n        this._emitStatusEvent(\n          'ngw:select',\n          this._prepareToIdentify({\n            ...identify,\n            resources: [id],\n            sourceType: 'vector',\n          } as NgwIdentify),\n        );\n        return identify;\n      }\n    }\n  }\n\n  private _prepareToIdentify<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(identify: NgwIdentify): NgwIdentifyEvent {\n    const getIdentifyItems_ = () => {\n      return getIdentifyItems(identify, true).map((x) => {\n        return createIdentifyItem<F, G>({\n          feature: x.feature,\n          connector: this.connector,\n        });\n      });\n    };\n    return {\n      ...identify,\n      getIdentifyItems: getIdentifyItems_,\n    };\n  }\n\n  private _getSelectListenersCount() {\n    return this.emitter.listenerCount('ngw:select');\n  }\n\n  private async _whiteLabel() {\n    const container = this.getContainer();\n    if (container) {\n      const logo = await getCompanyLogo(\n        this.connector,\n        this.options.companyLogoOptions,\n      );\n      if (logo) {\n        container.appendChild(logo);\n      }\n    }\n  }\n}\n"],"names":["appendNgwResources","options","resource","defOptions","overwriteOptions","Number","push","Array","isArray","resourceId","id","OPTIONS","target","baseUrl","whitlabel","controls","controlsOptions","ZOOM","position","ATTRIBUTION","customAttribution","pixelRadius","NgwMap","kits","QmsKit","starterKits","forEach","x","connector","NgwConnector","auth","deepmerge","center","bounds","NgwKit","create","prepareWebMapOptions","EventEmitter","select","identify","_createWebMap","then","container","getContainer","classList","add","_whiteLabel","controlDef","this","onLoad","onMapLoad","keyname","undefined","deprecatedWarn","Error","defined","setViewDelay","adapterOptions","adapter","createNgwLayerAdapter","adapterOpts","visibility","addLayer","layer","getLayerId","_ngwLayers","name","item","display_name","baselayer","getActiveBaseLayer","resId","isObject","console","error","zoom","setCenter","setZoom","fitBounds","fetchNgwLayerItem","fetchNgwLayerItems","fetchNgwLayerFeature","fetchNgwLayerFeatureCollection","requestOptions","promise","fetchIdentifyItem","_addPromise","multiple","fetchIdentifyGeoJson","CancelablePromise","n","mem","getIdentificationIds","ids","some","getDependLayers","dependLayers","dependFit","find","parentId","layerDef","String","ngwLayer","getBounds","getResource","fetchNgwExtent","extent","fitLayer","event","getLayer","layerId","$$selectFromNgwRaster","ev","_getSelectListenersCount","selectFromNgwRaster","$$selectFromNgwVector","_selectFromNgwVector","emitter","on","removeListener","fetchNgwLayerFeatures","cancelPromises","args","length","Object","keys","_promises","group","cancel","_emitStatusEvent","promises","layers","values","sort","a","b","order","l","identFunc","selectable","isLayerVisible","call","getIdsPromise","Promise","all","getIds","getCenter","getZoom","radius","getIdentifyRadius","selectPromise","sendIdentifyRequest","resp","resources","sourceType","identifyEvent","_prepareToIdentify","groupName","indexOf","removeFromGroup","index","splice","catch","params","_initMapState","qmsId","_addQmsBaseLayer","osm","_addOsmBaseLayer","layerFitAllowed","_isFitFromResource","webmapId","fit","r","addNgwLayer","warn","enableSelection","addBaseLayer","qmsLayerName","qmsLayerOptions","feature","featureId","featureCount","features","fields","properties","label","parent","geom","geometry","getIdentifyItems","map","createIdentifyItem","listenerCount","getCompanyLogo","companyLogoOptions","logo","appendChild","WebMap","getIcon"],"sourceRoot":""}