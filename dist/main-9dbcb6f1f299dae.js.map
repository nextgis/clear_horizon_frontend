{"version":3,"sources":["webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/CancelError.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/PromiseControl.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/TimeoutError.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/CancelablePromise.ts","webpack://clear_horizon/./@nextgis/packages/cancelable-promise/src/index.ts"],"names":["name","Object","setPrototypeOf","CancelError","prototype","Error","options","_promises","Map","this","size","remove","promise","has","delete","_onStop","get","add","key","exist","onStart","isLoaded","set","finally","abort","forEach","x","cancel","clear","waitFunc","func","WaitForMe","bind","target","descriptor","originalMethod","value","result","apply","args","GetOrCreateDecorator","onStop","TimeoutError","handleCallback","resolve","reject","callback","r","e","ID","executor","timeout","id","_isCanceled","_isPending","_cancelHandlers","_children","_cancelPromise","Promise","resolve_","reject_","_setCanceledCallback","er","promises","CancelablePromise","attach","error","handler","push","setTimeout","_promise","race","createControl","opt","PromiseControl","all","values","then","catch","p","onfulfilled","onrejected","_parentPromise","undefined","onfinally","parent","_getTopParent","length","_destroy","hasParent"],"mappings":"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","file":"main-9dbcb6f1f299dae.js","sourcesContent":["export class CancelError extends Error {\n  name = 'CancelError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, CancelError.prototype);\n  }\n}\n","import CancelablePromise from '.';\n\nexport interface PromiseControlOptions {\n  onStart?: () => void;\n  onStop?: () => void;\n}\n\ntype Key = CancelablePromise | string | number | symbol;\n\nexport class PromiseControl {\n  private _promises: Map<Key, CancelablePromise> = new Map();\n\n  get isLoaded(): boolean {\n    return this._promises.size > 0;\n  }\n\n  constructor(private options: PromiseControlOptions = {}) {}\n\n  remove(promise: Key): void {\n    if (this._promises.has(promise)) {\n      this._promises.delete(promise);\n      this._onStop();\n    }\n  }\n\n  get(promise: Key): CancelablePromise | undefined {\n    return this._promises.get(promise);\n  }\n\n  add<T extends CancelablePromise = CancelablePromise>(\n    promise: T,\n    name?: string | number | symbol\n  ): CancelablePromise<T> {\n    const key = name ? name : promise;\n    const exist = this._promises.get(key);\n    if (this.options.onStart && !this.isLoaded) {\n      this.options.onStart();\n    }\n    if (exist) {\n      return exist;\n    }\n    this._promises.set(key, promise);\n    promise.finally(() => {\n      this.remove(key);\n    });\n    return promise;\n  }\n\n  abort(): void {\n    if (this.isLoaded) {\n      this._promises.forEach((x) => {\n        if (x.cancel) {\n          x.cancel();\n        }\n      });\n      this._promises.clear();\n      this._onStop();\n    }\n  }\n\n  waitFunc<T>(func: () => any, name = ''): CancelablePromise<T> {\n    name = name || func.name;\n    const exist = this.get(name);\n    if (exist) {\n      return exist;\n    }\n    return this.add(func(), name);\n  }\n\n  WaitForMe(name: string | symbol = ''): MethodDecorator {\n    const get = this.get.bind(this);\n    const add = this.add.bind(this);\n    return function (\n      target: unknown,\n      key: string | symbol,\n      descriptor: PropertyDescriptor\n    ): PropertyDescriptor {\n      const originalMethod = descriptor.value;\n      name = name || key;\n      descriptor.value = function (...args: any[]) {\n        const exist = get(name);\n        if (exist) {\n          return exist;\n        }\n        const result = add(originalMethod.apply(this, args), name);\n        return result;\n      };\n\n      return descriptor;\n    };\n  }\n\n  /** @deprecated use {@link PromiseControl.WaitForMe } instead */\n  GetOrCreateDecorator(name: string | symbol = ''): MethodDecorator {\n    return this.WaitForMe(name);\n  }\n\n  private _onStop(): void {\n    if (this.options.onStop && !this.isLoaded) {\n      this.options.onStop();\n    }\n  }\n}\n","export class TimeoutError extends Error {\n  name = 'TimeoutError';\n\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n","import { CancelError } from './CancelError';\nimport { PromiseControl, PromiseControlOptions } from './PromiseControl';\nimport { TimeoutError } from './TimeoutError';\n\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\nexport type OnCancelFunction = (cancelHandler: () => void) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nlet ID = 0;\n\n/**\n * Promise that can be canceled\n *\n * @example\n * Catch `CancelError`\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject) => {\n *  setTimeout(() => resolve(), 100);\n * }).catch((er) => {\n *  if (er.name === \"CancelError\") {\n *    // handle cancel error\n *  }\n *  throw er;\n * });\n *\n * promise.cancel();\n * ```\n * @example\n * Handle `onCancel` callback\n * ```javascript\n * import CancelablePromise from \"@nextgis/cancelable-promise\";\n *\n * const promise = new CancelablePromise((resolve, reject, onCancel) => {\n *   const xhr = new XMLHttpRequest();\n *   xhr.open(\"GET\", url, true);\n *   xhr.onload = () => {\n *     resolve(xhr.responseText);\n *   };\n *   xhr.onerror = (er) => {\n *     reject(er);\n *   };\n *\n *   onCancel(() => {\n *     xhr.abort();\n *   });\n *\n *   xhr.send();\n * });\n *\n * promise.cancel();\n * ```\n * @public\n */\nexport class CancelablePromise<T = any> implements Promise<T> {\n  static CancelError = CancelError;\n  static TimeoutError = TimeoutError;\n  static PromiseControl = PromiseControl;\n\n  readonly [Symbol.toStringTag]: string;\n  readonly id = ID++;\n  private _isCanceled = false;\n  private _isPending = true;\n  private _promise?: Promise<T>;\n  private _cancelPromise?: Promise<T>;\n  private _cancelHandlers: (() => void)[] = [];\n  private _setCanceledCallback?: (er?: any) => void;\n  private _parentPromise?: CancelablePromise;\n  private _children: CancelablePromise[] = [];\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void,\n      onCancel: OnCancelFunction\n    ) => void,\n    timeout?: number\n  ) {\n    this._cancelPromise = new Promise<any>((resolve_, reject_) => {\n      this._setCanceledCallback = (er) => resolve_(er || new CancelError());\n    });\n    const promises = [\n      this._cancelPromise,\n      new Promise<T>((resolve, reject) => {\n        const onResolve = (value?: T | PromiseLike<T>) => {\n          if (value instanceof CancelablePromise) {\n            this.attach(value);\n          } else {\n            this._isPending = false;\n          }\n          // TODO: fix types, `undefined` not allowed since 19.12.2020\n          resolve(value as T | PromiseLike<T>);\n        };\n\n        const onReject = (error: any) => {\n          this._isPending = false;\n          reject(error);\n        };\n\n        const onCancel: OnCancelFunction = (handler) => {\n          if (!this._isPending) {\n            throw new Error(\n              'The `onCancel` handler was attached after the promise settled.'\n            );\n          }\n\n          this._cancelHandlers.push(handler);\n        };\n\n        return executor(onResolve, onReject, onCancel);\n      }),\n    ];\n    if (timeout) {\n      promises.push(\n        new Promise((resolve, reject) => {\n          setTimeout(() => {\n            if (this._isPending) {\n              try {\n                this.cancel();\n              } finally {\n                reject(new TimeoutError());\n              }\n            }\n          }, timeout);\n        })\n      );\n    }\n    this._promise = Promise.race(promises);\n  }\n\n  static createControl(opt?: PromiseControlOptions): PromiseControl {\n    return new PromiseControl(opt);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve) => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values).then(resolve).catch(reject);\n    });\n  }\n\n  attach(p: CancelablePromise): void {\n    if (this._isCanceled) {\n      p.cancel();\n    } else {\n      this._children.push(p);\n    }\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise((resolve, reject) => {\n      if (this._promise) {\n        const reject_ = (r: any) => {\n          if (onrejected) {\n            handleCallback(resolve, reject, onrejected, r);\n          } else {\n            reject(r);\n          }\n        };\n        this._promise.then((r) => {\n          if (this._isCanceled) {\n            reject_(r);\n          } else {\n            if (onfulfilled) {\n              handleCallback(resolve, reject, onfulfilled, r);\n            } else {\n              resolve(r);\n            }\n          }\n        }, reject_);\n      }\n    });\n    p._parentPromise = this;\n    this._children.push(p);\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: Error) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<T | TResult> {\n    if (this._isCanceled && onrejected) {\n      onrejected(new CancelError());\n    }\n    return this.then(undefined, onrejected);\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    if (this._isCanceled) {\n      return Promise.reject(new CancelError());\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  cancel(): this {\n    if (this._isCanceled) {\n      return this;\n    }\n    this._isCanceled = true;\n    const parent = this._getTopParent();\n    if (parent) {\n      parent.cancel();\n    }\n\n    if (this._children) {\n      this._children.forEach((x) => x.cancel());\n    }\n\n    if (this._isPending) {\n      if (this._cancelHandlers.length) {\n        try {\n          for (const handler of this._cancelHandlers) {\n            handler();\n          }\n        } catch (error) {\n          // this._setCanceledCallback(error);\n        }\n      }\n      if (this._setCanceledCallback) {\n        this._setCanceledCallback();\n      }\n    }\n    this._destroy();\n\n    return this;\n  }\n\n  private _getTopParent() {\n    let parent = this._parentPromise;\n    let hasParent = !!parent;\n    while (hasParent) {\n      if (parent && parent._parentPromise) {\n        parent = parent._parentPromise;\n        hasParent = !!parent;\n      } else {\n        hasParent = false;\n      }\n    }\n    return parent;\n  }\n\n  private _destroy() {\n    this._setCanceledCallback = undefined;\n    this._cancelPromise = undefined;\n    this._promise = undefined;\n  }\n}\n\nObject.setPrototypeOf(CancelablePromise.prototype, Promise.prototype);\n","/**\n * A promise you can stop\n *\n * @packageDocumentation\n */\nimport { CancelablePromise } from './CancelablePromise';\n\nexport default CancelablePromise;\n"],"sourceRoot":""}