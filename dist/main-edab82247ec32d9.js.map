{"version":3,"file":"main-edab82247ec32d9.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/createPopupContent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/prepareNgwFieldsToPropertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItems.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatureCollection.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatures.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwExtent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createGeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createRasterAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/utils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowNgwAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/BookmarkItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createNgwWebmapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwResource.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createBasemapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createAsyncAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/IdentifyItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeature.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/identifyUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getCompanyLogo.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/appendNgwResources.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/prepareWebMapOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/NgwMap.ts"],"sourcesContent":["import { Feature } from 'geojson';\nimport { ResourceItem } from '@nextgis/ngw-connector';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem,\n): HTMLElement | string {\n  if (__BROWSER__) {\n    const element = document.createElement('div');\n    if (item && item.feature_layer) {\n      item.feature_layer.fields.forEach((x) => {\n        if (x.grid_visibility) {\n          const value = feature.properties && feature.properties[x.keyname];\n          if (value) {\n            const propElem = document.createElement('div');\n            element.appendChild(propElem);\n            propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n          }\n        }\n      });\n    } else if (feature.properties) {\n      for (const p in feature.properties) {\n        const propElem = document.createElement('div');\n        element.appendChild(propElem);\n        propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n      }\n    }\n    return element;\n  } else {\n    return '';\n  }\n}\n","import { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy',\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions,\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach((x) => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport type { NgwLayerOptions } from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector,\n): Promise<number> {\n  const resource = options.resource;\n  const item = resource as ResourceItem;\n\n  // @ts-ignore @deprecated\n  let { keyname, resourceId } = options;\n\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else if (\n      item.resource &&\n      item.resource !== undefined &&\n      'resource' in item\n    ) {\n      resourceId = (resource as ResourceItem).resource.id;\n    } else {\n      // TODO: safe remove this case\n      resourceId = await resourceIdFromLayerOptions(\n        resource as NgwLayerOptions,\n        connector,\n      );\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResource(keyname);\n    if (resourceItem) {\n      resourceId = resourceItem.resource.id;\n    }\n  }\n  return resourceId;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  checkIfPropertyFilter,\n  PropertiesFilter,\n  PropertyFilter,\n} from '@nextgis/properties-filter';\nimport {\n  defined,\n  degrees2meters,\n  getBoundsCoordinates,\n  isLngLatBoundsArray,\n} from '@nextgis/utils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type {\n  FeatureItem,\n  RequestItemAdditionalParams,\n} from '@nextgis/ngw-connector';\nimport type { LngLatArray, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureRequestParams,\n  FetchNgwItemsOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\n\nexport const FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson',\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry,\n  };\n  return feature;\n}\n\nexport function updateItemRequestParam<\n  P extends FeatureProperties = FeatureProperties,\n>(params: FeatureRequestParams, options: NgwFeatureRequestOptions<P>): void {\n  const { extensions, geom, fields, srs } = options;\n  params.extensions = extensions ? extensions.join(',') : '';\n  if (fields !== undefined) {\n    params.fields = Array.isArray(fields) ? fields.join(',') : '';\n  }\n  if (geom !== undefined) {\n    params.geom = geom ? 'yes' : 'no';\n    if (!geom) {\n      delete params.srs;\n      delete params.geom_format;\n    }\n  }\n  if (defined(srs)) {\n    params.srs = srs;\n  }\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nexport function createFeatureFieldFilterQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n  _queries: CancelablePromise<FeatureItem<P, G>[]>[] = [],\n  _parentAllParams: [string, any][] = [],\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const { filters } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter((x) => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    const isFldStr = field !== 'id' ? 'fld_' : '';\n    return [`${isFldStr}${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach((f) => {\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)],\n          }),\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f,\n          },\n          _queries,\n          [..._parentAllParams],\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filters: [string, any][] = [];\n    const propertiesFilterList: PropertiesFilter[] = [];\n    for (const f of filters_) {\n      if (checkIfPropertyFilter(f)) {\n        filters.push(createParam(f));\n      } else {\n        propertiesFilterList.push(f);\n      }\n    }\n\n    if (propertiesFilterList.length) {\n      for (const x of propertiesFilterList) {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: x,\n          },\n          _queries,\n          [..._parentAllParams, ...filters],\n        );\n      }\n    } else {\n      _queries.push(\n        fetchNgwLayerItemsRequest<G, P>({\n          ...opt,\n          paramList: [..._parentAllParams, ...filters],\n        }),\n      );\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    const offset = opt.offset !== undefined ? opt.offset : 0;\n    const limit = opt.limit !== undefined ? opt.limit : items.length;\n    if (opt.offset || opt.limit) {\n      return items.splice(offset, limit);\n    }\n    return items;\n  });\n}\n\nfunction createWktFromCoordArray(coord: LngLatArray[]): string {\n  const polygon = coord.map(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    return x + ' ' + y;\n  });\n  return `POLYGON((${polygon.join(', ')}))`;\n}\n\nexport function fetchNgwLayerItemsRequest<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  const {\n    connector,\n    limit,\n    offset,\n    intersects,\n    orderBy,\n    resourceId,\n    paramList,\n  } = options;\n  if (limit) {\n    if (limit !== Number.POSITIVE_INFINITY) {\n      params.limit = limit;\n    }\n  } else {\n    // Strict restriction on loading data from large layers\n    params.limit = 7000;\n  }\n  if (offset) {\n    params.offset = offset;\n  }\n  // TODO: fix type for options\n  updateItemRequestParam(params, options as { [field: string]: any });\n\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  if (Array.isArray(intersects)) {\n    const coordinates = isLngLatBoundsArray(intersects)\n      ? getBoundsCoordinates(intersects)\n      : intersects;\n\n    params.intersects = createWktFromCoordArray(coordinates);\n  } else if (typeof intersects === 'string') {\n    params.intersects = intersects;\n  }\n\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  const reqParams = {\n    id: resourceId,\n    ...params,\n  };\n\n  return connector.get(\n    'feature_layer.feature.collection',\n    { cache: options.cache },\n    reqParams,\n  ) as CancelablePromise<FeatureItem<P, G>[]>;\n}\n\nexport function prepareFieldsToNgw<\n  T extends FeatureProperties = FeatureProperties,\n>(\n  item: T,\n  resourceFields: Pick<FeatureProperties, 'keyname' | 'datatype'>[],\n): Record<keyof T, any> {\n  const fields = {} as Record<keyof T, any>;\n  if (item) {\n    resourceFields.forEach((x) => {\n      if (x.keyname in item) {\n        const keyname = x.keyname;\n        const prop = item[keyname];\n        let value: any;\n        if (prop !== undefined) {\n          if (x.datatype === 'STRING') {\n            value = prop ? String(prop) : null;\n            // TODO: remove after v 3.0.0. For backward compatibility\n            if (value === 'null') {\n              value = null;\n            }\n          } else if (x.datatype === 'BIGINT' || x.datatype === 'INTEGER') {\n            value = typeof prop === 'string' ? parseInt(prop, 10) : prop;\n          } else if (x.datatype === 'REAL') {\n            value = typeof prop === 'string' ? parseFloat(prop) : prop;\n          } else if (x.datatype === 'BOOLEAN') {\n            value =\n              typeof prop === 'boolean' || typeof prop === 'number'\n                ? Number(!!prop)\n                : null;\n          } else if (x.datatype === 'DATE' || x.datatype === 'DATETIME') {\n            let dt: Date | undefined;\n            if (typeof prop === 'object' && !((prop as any) instanceof Date)) {\n              value = prop;\n            } else {\n              if ((prop as any) instanceof Date) {\n                dt = prop as any;\n              } else {\n                const parse = Date.parse(String(prop));\n                if (parse) {\n                  dt = new Date(parse);\n                }\n              }\n              if (dt) {\n                value = {\n                  year: dt.getFullYear(),\n                  month: dt.getMonth(),\n                  day: dt.getDay(),\n                };\n                if (x.datatype === 'DATETIME') {\n                  value.hour = dt.getHours();\n                  value.minute = dt.getMinutes();\n                  value.second = dt.getSeconds();\n                }\n              }\n            }\n          }\n        }\n        fields[keyname as keyof T] = value ?? null;\n      }\n    });\n  }\n  return fields;\n}\n","import { isObject, defined } from '@nextgis/utils';\nimport type { NgwDateFormat, NgwDateTimeFormat } from '@nextgis/ngw-connector';\n\nexport function prepareNgwFieldsToPropertiesFilter(\n  fields: Record<string, any>,\n): Record<string, any> {\n  let f: keyof typeof fields;\n  for (f in fields) {\n    const field = fields[f];\n    if (isObject(field)) {\n      const date = field as NgwDateFormat | NgwDateTimeFormat;\n      if (defined(date.year) && defined(date.month) && defined(date.day)) {\n        const dt: [number, number, number, number?, number?, number?] = [\n          date.year,\n          date.month - 1,\n          date.day,\n        ];\n        if ('hour' in date) {\n          [date.hour, date.minute, date.second].forEach((x) => {\n            dt.push(x);\n          });\n        }\n        fields[f] = new Date(...dt).toISOString();\n      }\n    }\n  }\n  return fields;\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createFeatureFieldFilterQueries,\n  fetchNgwLayerItemsRequest,\n} from './featureLayerUtils';\nimport { prepareNgwFieldsToPropertiesFilter } from './prepareNgwFieldsToPropertiesFilter';\n\nimport type { Geometry } from 'geojson';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({\n      ...options,\n      filters,\n    }).then((data) => {\n      // Additional client-side filter check\n      data.filter((y) => {\n        const fields = prepareNgwFieldsToPropertiesFilter({ ...y.fields });\n        const result = propertiesFilter(fields, filters);\n        return result;\n      });\n      return data;\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  } else {\n    return fetchNgwLayerItemsRequest<G, P>(options);\n  }\n}\n","import { fetchNgwLayerFeatures } from './fetchNgwLayerFeatures';\n\nimport type { Geometry, FeatureCollection } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { FetchNgwItemsOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeatureCollection<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemsOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatures<G, P>(options).then((features) => {\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features,\n    };\n    return featureCollection;\n  });\n}\n","import { fetchNgwLayerItems } from './fetchNgwLayerItems';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<Feature<G, P>[]> {\n  return fetchNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach((y) => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    return features;\n  });\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport type { LngLatBoundsArray } from '@nextgis/webmap';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { WebmapResource, ResourceItem } from '@nextgis/ngw-connector';\nimport type {\n  FetchNgwLayerExtentOptions,\n  FetchNgwLayerItemExtentOptions,\n} from '../interfaces';\n\nexport function getNgwWebmapExtent(\n  webmap: WebmapResource,\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function fetchNgwLayerExtent({\n  resourceId,\n  connector,\n  cache = true,\n}: FetchNgwLayerExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get('layer.extent', { cache }, { id: resourceId })\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwLayerItemExtent({\n  resourceId,\n  featureId,\n  connector,\n  cache = true,\n}: FetchNgwLayerItemExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get(\n      'feature_layer.feature.item_extent',\n      { cache },\n      { id: resourceId, fid: featureId },\n    )\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return CancelablePromise.resolve(getNgwWebmapExtent(item.webmap));\n  } else {\n    const resource = item.resource;\n    if (resource.cls && resource.cls.indexOf('style') !== -1) {\n      return connector.getResource(resource.parent.id).then((res) => {\n        if (res) {\n          return fetchNgwLayerExtent({\n            resourceId: res.resource.id,\n            connector,\n          });\n        }\n      });\n    } else {\n      return fetchNgwLayerExtent({ resourceId: resource.id, connector });\n    }\n  }\n}\n","import { EventEmitter } from 'events';\nimport {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  FilterOptions,\n  LayerAdapter,\n} from '@nextgis/webmap';\nimport { debounce } from '@nextgis/utils';\nimport { PropertiesFilter, propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\nimport { createPopupContent } from '../utils/createPopupContent';\nimport { getLayerFilterOptions } from '../utils/getLayerFilterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport {\n  NgwLayerOptions,\n  GetClassAdapterOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\nimport { fetchNgwLayerFeatureCollection } from '../utils/fetchNgwLayerFeatureCollection';\nimport { fetchNgwResourceExtent } from '../utils/fetchNgwExtent';\n\nimport type { FeatureCollection } from 'geojson';\nimport { prepareNgwFieldsToPropertiesFilter } from '../utils/prepareNgwFieldsToPropertiesFilter';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  props: GetClassAdapterOptions,\n): Promise<Type<VectorLayerAdapter>> {\n  const {\n    item,\n    webMap,\n    Adapter,\n    connector,\n    layerOptions,\n    addLayerOptionsPriority: alop,\n  } = props;\n  const addLayerOptionsPriority = alop ?? true;\n  const options = layerOptions as NgwLayerOptions<'GEOJSON'>;\n  const GeoJsonAdapter: Type<VectorLayerAdapter> =\n    Adapter || webMap.mapAdapter.layerAdapters.GEOJSON;\n\n  let _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n  let _dataPromise: CancelablePromise<FeatureCollection> | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (options.adapterOptions?.popupOptions?.fromProperties) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const getData = async (\n    filters?: PropertiesFilter,\n    filterOpt?: NgwFeatureRequestOptions,\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: filterOpt };\n    _dataPromise = fetchNgwLayerFeatureCollection({\n      resourceId,\n      filters,\n      connector,\n      cache: true,\n      ...filterOpt,\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  class NgwGeoJsonAdapter extends GeoJsonAdapter {\n    emitter = new EventEmitter();\n    _count?: number;\n    __onMapMove?: () => void;\n    __onMapMoveStart?: () => void;\n    __enableMapMoveListener?: (e: LayerAdapter) => void;\n    __disableMapMoveListener?: (e: LayerAdapter) => void;\n\n    async addLayer(opt: GeoJsonAdapterOptions) {\n      let needUpdate = !opt.data;\n      const waitFullLoad =\n        opt.waitFullLoad !== undefined ? opt.waitFullLoad : true;\n      if (options.id !== undefined) {\n        opt.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (options.adapterOptions) {\n        // TODO: remove addLayerOptionsPriority options/\n        // in some cases, addLayer options must be used,\n        // but in others factory method options needs first\n        if (addLayerOptionsPriority) {\n          opt = {\n            ...options.adapterOptions,\n            ...opt,\n          };\n        } else {\n          opt = {\n            ...opt,\n            ...options.adapterOptions,\n          };\n        }\n      }\n      if (opt.data && Object.keys(opt.data).length === 0) {\n        opt.data = undefined;\n        needUpdate = false;\n      }\n      const layer = super.addLayer(opt);\n      this.options.strategy = opt.strategy || undefined;\n\n      _lastFilterArgs = {\n        filters: opt.propertiesFilter,\n        options: getLayerFilterOptions(opt),\n      };\n      let updatePromise: Promise<any> | undefined;\n      if (needUpdate) {\n        updatePromise = this.updateLayer();\n      }\n      if (waitFullLoad && updatePromise) {\n        await updatePromise;\n      }\n      if (this.options.strategy === 'BBOX' && !_fullDataLoad) {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    getExtent() {\n      const hasData = this.getLayers && this.getLayers().length;\n      if (this.options.strategy === 'BBOX' || hasData) {\n        return fetchNgwResourceExtent(item, connector);\n      } else {\n        if (super.getExtent) {\n          return super.getExtent();\n        }\n      }\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      this.__onMapMoveStart = undefined;\n      abort();\n    }\n\n    getCount() {\n      if (this._count !== undefined) {\n        return this._count;\n      }\n      return connector\n        .get(\n          'feature_layer.feature.count',\n          { cache: true },\n          {\n            id: resourceId,\n          },\n        )\n        .then((resp) => {\n          if (resp) {\n            this._count = resp.total_count;\n            return this._count;\n          }\n        });\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy === 'BBOX') {\n        await webMap.onLoad('create');\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = webMap.getBounds();\n      }\n      if (removed) {\n        return;\n      }\n      try {\n        const data = await getData(filterArgs.filters, {\n          ...filterArgs.options,\n          srs: this.options.srs,\n        });\n        const count = await this.getCount();\n        _fullDataLoad = count === data.features.length;\n        await webMap.setLayerData(this, data);\n        this.emitter.emit('updated');\n      } catch (er) {\n        if (er.name !== 'CancelError') {\n          throw er;\n        }\n      }\n      if (super.updateLayer) {\n        super.updateLayer();\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter((e) => {\n          const props_ =\n            e.feature &&\n            e.feature.properties &&\n            prepareNgwFieldsToPropertiesFilter({ ...e.feature.properties });\n          if (props_) {\n            return propertiesFilter(props_, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await getData(filters, {\n          ...opt,\n          srs: this.options.srs,\n        });\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    _addBboxEventListener() {\n      this.__enableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener(this);\n    }\n\n    _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      this.__onMapMoveStart = abort;\n      webMap.emitter.on('movestart', this.__onMapMoveStart);\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.removeListener('moveend', this.__onMapMove);\n      }\n      if (this.__onMapMoveStart) {\n        webMap.emitter.removeListener('movestart', this.__onMapMoveStart);\n      }\n    }\n  }\n\n  return NgwGeoJsonAdapter;\n}\n","import {\n  WebMap,\n  RasterAdapterOptions,\n  ImageAdapterOptions,\n  WmsAdapterOptions,\n} from '@nextgis/webmap';\n\nimport { NgwLayerOptions, TileNoData } from '../interfaces';\nimport { updateImageParams } from './utils';\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n): RasterAdapterOptions | ImageAdapterOptions | undefined {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = options.resource;\n  const nd: TileNoData = options.tileNoData ? options.tileNoData : 200;\n\n  if (typeof resourceId === 'number') {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          params: { resource: resourceId, nd: nd },\n          updateWmsParams: (params: Record<string, any>) =>\n            updateImageParams({ nd: nd, ...params }, resourceId),\n        } as ImageAdapterOptions;\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      const adapterOptions = options.adapterOptions as WmsAdapterOptions;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: adapterOptions && adapterOptions.layers,\n        headers: options.headers,\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url,\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'MODEL_3D') {\n      url = baseUrl + `/api/component/model_3d/${resourceId}/data.glb`;\n      return { url };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId +\n        '&nd=' +\n        nd;\n      return { url, adapter };\n    }\n  } else if (resourceId !== undefined) {\n    throw new Error(\n      'Option `resource` must be number, not ' + typeof resourceId,\n    );\n  } else {\n    console.log('Option `resource` not set');\n  }\n}\n","import {\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  GetClassAdapterOptions,\n} from '../interfaces';\nimport { MainLayerAdapter, Type, ImageAdapterOptions } from '@nextgis/webmap';\nimport { defined } from '@nextgis/utils';\nimport { ResourceItem, ResourceCls } from '@nextgis/ngw-connector';\n\nimport { getLayerAdapterOptions } from '../utils/getLayerAdapterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nexport async function createRasterAdapter({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  const resourceCls = item.resource.cls;\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    tmsclient_layer: 'IMAGE',\n  };\n  let adapter =\n    layerOptions.adapter ||\n    (resourceCls && clsAdapterAlias[resourceCls]) ||\n    'IMAGE';\n  if (adapter !== undefined) {\n    layerOptions.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const adapterClass = webMap.mapAdapter.layerAdapters[\n    adapter\n  ] as Type<MainLayerAdapter>;\n  if (adapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(\n      layerOptions,\n      connector,\n    );\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem = item;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(\n          layerOptions,\n          webMap,\n          connector.options.baseUrl || '',\n        );\n        if (opt) {\n          const layerAdapterOptions: ImageAdapterOptions = {\n            ...opt,\n            setViewDelay: layerOptions.adapterOptions?.setViewDelay,\n            params: { resource: resourceId },\n            // @deprecated\n            layers: String(resourceId),\n            resourceId: resourceId,\n          };\n          if (\n            layerOptions.adapterOptions &&\n            defined(layerOptions.adapterOptions.setViewDelay)\n          ) {\n            layerAdapterOptions.setViewDelay =\n              layerOptions.adapterOptions.setViewDelay;\n          }\n          this.options = { ...this.options, ...layerAdapterOptions };\n          // if (__DEV__) {\n          //   Object.defineProperty(this.options, 'layers', {\n          //     get: () => {\n          //       console.warn('Do not use `layers` in ImageAdapterOptions');\n          //       return String(resourceId);\n          //     },\n          //   });\n          //   Object.defineProperty(this.options, 'resourceId', {\n          //     get: () => {\n          //       console.warn('Do not use `resourceId` in ImageAdapterOptions');\n          //       return resourceId;\n          //     },\n          //   });\n          // }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (defined(id)) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","import { EventEmitter } from 'events';\nimport { ItemOptions, Item } from '@nextgis/item';\nimport { treeSome } from '@nextgis/tree';\nimport {\n  WebMap,\n  LayerAdapter,\n  LayerAdapterDefinition,\n  ImageAdapterOptions,\n} from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { objectAssign } from '@nextgis/utils';\n\nimport { setScaleRatio } from './utils/utils';\nimport { TreeGroup, TreeLayer, TreeItem } from './interfaces';\n\nexport class NgwWebmapItem extends Item<ItemOptions> {\n  static GetAdapterFromLayerType: {\n    [layerType: string]: (\n      item: TreeItem,\n      options: any,\n      webMap: WebMap,\n      connector?: NgwConnector,\n    ) => LayerAdapterDefinition;\n  } = {};\n\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: NgwWebmapItem): boolean {\n          if (item) {\n            if (\n              item.item.item_type === 'group' ||\n              item.item.item_type === 'root'\n            ) {\n              return treeSome<TreeGroup | TreeLayer>(\n                item.item,\n                (i) => ('layer_enabled' in i ? i.layer_enabled : false),\n                (i) => (i as TreeGroup).children,\n              );\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            }\n            // else if (item.item.item_type === 'root') {\n            //   return true;\n            // }\n          }\n          return false;\n        },\n        onSet(\n          value: boolean,\n          options?: Record<string, any>,\n          item?: NgwWebmapItem,\n        ): void {\n          if (item && item.item.item_type === 'layer') {\n            if (item.layer) {\n              if (value) {\n                item.webMap.showLayer(item.layer);\n              } else {\n                item.webMap.hideLayer(item.layer);\n              }\n            }\n            item.item['layer_enabled'] = value;\n          }\n        },\n      },\n    ],\n  };\n\n  item: TreeGroup | TreeLayer;\n  connector?: NgwConnector;\n  layer?: LayerAdapter;\n  readonly emitter = new EventEmitter();\n\n  protected _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n    noInit?: boolean,\n  ) {\n    super({ ...NgwWebmapItem.options, ...options });\n    if (connector) {\n      this.connector = connector;\n    }\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n    this.initProperties();\n    if (!noInit) {\n      this._init(item);\n    }\n  }\n\n  static async create(\n    webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n  ): Promise<NgwWebmapItem> {\n    const ngwWebmapItem = new NgwWebmapItem(\n      webMap,\n      item,\n      options,\n      connector,\n      parent,\n      true,\n    );\n    await ngwWebmapItem._init(item);\n    return ngwWebmapItem;\n  }\n\n  initItem(item: TreeGroup | TreeLayer): Promise<void> {\n    const i = item;\n    const options: Partial<ImageAdapterOptions> = this.getItemOptions(item);\n    const setNewLayer = (l: LayerAdapter) => {\n      i._layer = l;\n      this.layer = l;\n      const enabled = this.properties.get('visibility');\n      if (enabled) {\n        this.properties.set('visibility', true);\n      }\n\n      if (options.opacity !== undefined) {\n        this.webMap.setLayerOpacity(l, options.opacity);\n      }\n    };\n\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        this.getChildren(item).forEach((x) => {\n          const children = new NgwWebmapItem(\n            this.webMap,\n            x,\n            this.options,\n            this.connector,\n            this,\n          );\n          this.tree.addChild(children);\n        });\n      }\n      return Promise.resolve();\n    } else {\n      let adapter: LayerAdapterDefinition | undefined;\n      if (item.item_type === 'layer') {\n        adapter = item.adapter || item.layer_adapter.toUpperCase();\n      } else if (NgwWebmapItem.GetAdapterFromLayerType[item.item_type]) {\n        const getAdapter =\n          NgwWebmapItem.GetAdapterFromLayerType[item.item_type];\n        adapter = getAdapter(item, options, this.webMap, this.connector);\n      }\n\n      if (adapter) {\n        return this.webMap.addLayer(adapter, options).then((newLayer) => {\n          setNewLayer(newLayer);\n        });\n      }\n    }\n    if (item._layer) {\n      return Promise.resolve(setNewLayer(item._layer));\n    }\n    return Promise.reject('No layer added');\n  }\n\n  bringToFront(): void {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      // console.log(this.item);\n    }\n  }\n\n  protected getItemOptions(item: TreeGroup | TreeLayer): Record<string, any> {\n    const transparency = item.item_type === 'layer' && item.layer_transparency;\n    const opacity =\n      typeof transparency === 'number' ? (100 - transparency) / 100 : undefined;\n    const options: Partial<ImageAdapterOptions> = {\n      visibility: false,\n      headers: this.options.headers,\n      crossOrigin: this.options.crossOrigin,\n      setViewDelay: this.options.setViewDelay,\n      params: { resource: this.item.resourceId },\n    };\n    if (this.options.order) {\n      const subOrder =\n        this.options.drawOrderEnabled && 'draw_order_position' in item\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n\n      // 9 > 0009, 11 > 0011\n      // TODO: find better way to set order in sub level, not limit by 1000 layer in group\n      const subLevel = String(subOrder).padStart(4, '0');\n      options.order = Number((this.options.order | 0) + '.' + subLevel);\n    }\n    if (item.item_type === 'layer') {\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      objectAssign(options, {\n        updateWmsParams: item.updateWmsParams,\n        url: item.url,\n        headers: this.options.headers,\n        ratio: this.options.ratio,\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n      });\n    }\n    if (opacity !== undefined) {\n      options.opacity = opacity;\n    }\n    return options;\n  }\n\n  protected getChildren(item: TreeGroup): (TreeGroup | TreeLayer)[] {\n    return [...item.children].reverse();\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private _init(item: TreeGroup | TreeLayer) {\n    this.initItem(item).then(() => {\n      this.emitter.emit('init');\n    });\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import { WebMap, Type, VectorAdapterLayerType } from '@nextgis/webmap';\nimport NgwConnector, { GeometryType } from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  NgwWebmapAdapterOptions,\n  ResourceAdapter,\n} from '../interfaces';\nimport { createAsyncAdapter } from '../adapters/createAsyncAdapter';\nimport { NgwWebmapLayerAdapter } from '../NgwWebmapLayerAdapter';\n\nexport function updateImageParams(\n  params: Record<string, any>,\n  resourceId: number,\n): Record<string, any> {\n  const { bbox, width, height, nd } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now(),\n    nd,\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'point',\n  LINESTRING: 'line',\n  POLYGON: 'polygon',\n  MULTIPOINT: 'point',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'polygon',\n  POINTZ: 'point',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'polygon',\n  MULTIPOINTZ: 'point',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'polygon',\n};\n\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, connector);\n}\n\nexport interface ExtendNgwWebmapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendNgwWebmapLayerAdapter(\n  opt: ExtendNgwWebmapLayerAdapterOptions,\n): Type<NgwWebmapLayerAdapter> {\n  class A extends NgwWebmapLayerAdapter {\n    constructor(map: any, options: NgwWebmapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth(): number {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number): number {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 0): number {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n\n  const centerLat = lat;\n  const crsScale =\n    (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n  const zoom = getZoomFromScale(crsScale);\n  return zoom;\n\n  // return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import {\n  WebMap,\n  Type,\n  MainLayerAdapter,\n  AdapterOptions,\n} from '@nextgis/webmap';\nimport NgwConnector, { BasemapWebmapItem } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from './createAsyncAdapter';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  item: BasemapWebmapItem;\n  adapterOptions?: Record<string, any>;\n  idPrefix?: string;\n}\n\nexport async function createOnFirstShowNgwAdapter({\n  webMap,\n  connector,\n  item,\n  adapterOptions = {},\n  idPrefix = 'basemapwebmap',\n}: CreateOnFirstShowAdapterOptions): Promise<Type<MainLayerAdapter>> {\n  class OnFirstShowAdapter implements MainLayerAdapter {\n    options: AdapterOptions = {};\n    layer: MainLayerAdapter[] = [];\n    _removed = false;\n\n    addLayer() {\n      return this.layer;\n    }\n\n    removeLayer() {\n      this._removed = true;\n      this.layer.forEach((x) => webMap.removeLayer(x));\n    }\n\n    showLayer() {\n      this.options.visibility = true;\n      if (this.layer.length) {\n        this.layer.forEach((x) => {\n          webMap.showLayer(x);\n        });\n      } else {\n        createAsyncAdapter(\n          {\n            resource: item.resource_id,\n            adapterOptions: {\n              name: item.display_name,\n              opacity: item.opacity,\n            },\n          },\n          webMap,\n          connector,\n        ).then((Adapter) => {\n          if (Adapter) {\n            const adapter = new Adapter(webMap.mapAdapter.map, {\n              ...adapterOptions,\n              baselayer: false,\n            });\n            adapter.addLayer({}).then((baselayer: MainLayerAdapter) => {\n              adapter.options.baselayer = false;\n              Object.assign(adapter.options, adapterOptions);\n              adapter.id = idPrefix + '-' + item.resource_id;\n              adapter.layer = baselayer;\n              if (this._removed) {\n                webMap.removeLayer(adapter);\n              }\n              if (this.options.visibility) {\n                webMap.showLayer(adapter);\n              }\n              this.layer.push(adapter);\n            });\n          }\n        });\n      }\n    }\n\n    hideLayer() {\n      this.options.visibility = false;\n      if (this.layer) {\n        this.layer.forEach((x) => webMap.hideLayer(x));\n      }\n    }\n  }\n  return OnFirstShowAdapter;\n}\n","import { Feature, Point } from 'geojson';\nimport { createGeoJsonFeature, fetchNgwLayerItem } from '@nextgis/ngw-kit';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\ninterface BookmarkItemOptions {\n  connector: NgwConnector;\n  resourceId: number;\n  item: FeatureItem;\n  labelField?: string;\n}\n\nexport class BookmarkItem {\n  readonly name: string;\n  readonly resourceId: number;\n  readonly item: FeatureItem;\n\n  private _extent?: LngLatBoundsArray;\n\n  constructor(private options: BookmarkItemOptions) {\n    this.resourceId = options.resourceId;\n    const item = options.item;\n    this.item = item;\n    if (options.labelField && item.fields) {\n      this.name = item.fields[options.labelField];\n    } else {\n      this.name = String(item.id);\n    }\n  }\n\n  extent(): CancelablePromise<LngLatBoundsArray> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return this.options.connector\n      .get('feature_layer.feature.item_extent', null, {\n        id: this.resourceId,\n        fid: this.item.id,\n      })\n      .then((resp) => {\n        const { minLat, minLon, maxLat, maxLon } = resp.extent;\n        const lonLat = [minLon, minLat, maxLon, maxLat];\n        this._extent = lonLat;\n        return lonLat;\n      });\n  }\n\n  geoJson(): CancelablePromise<Feature<Point, any>> {\n    if (this.item.geom) {\n      return CancelablePromise.resolve(createGeoJsonFeature(this.item));\n    } else {\n      return fetchNgwLayerItem({\n        resourceId: this.resourceId,\n        featureId: this.item.id,\n        connector: this.options.connector,\n        geom: true,\n        fields: null,\n        extensions: null,\n      }).then((onlyGeomItem) => {\n        const geom = onlyGeomItem.geom;\n        this.item.geom = geom;\n        return createGeoJsonFeature(this.item);\n      });\n    }\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { fixUrlStr } from '@nextgis/utils';\nimport { fetchNgwLayerItems } from '@nextgis/ngw-kit';\n\nimport { NgwWebmapItem } from './NgwWebmapItem';\nimport { createOnFirstShowNgwAdapter } from './adapters/createOnFirstShowNgwAdapter';\nimport { getLayerAdapterOptions } from './utils/getLayerAdapterOptions';\nimport { getNgwWebmapExtent } from './utils/fetchNgwExtent';\nimport { updateImageParams } from './utils/utils';\nimport { BookmarkItem } from './BookmarkItem';\n\nimport type { Type } from '@nextgis/utils';\nimport type { ItemOptions } from '@nextgis/item';\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type {\n  ResourceItem,\n  WebmapResource,\n  BasemapWebmap,\n} from '@nextgis/ngw-connector';\nimport type {\n  WebMap,\n  LngLatBoundsArray,\n  RasterAdapterOptions,\n} from '@nextgis/webmap';\nimport type {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  NgwWebmapAdapterOptions,\n  NgwWebmapLayerAdapterEvents,\n  ResourceAdapter,\n} from './interfaces';\n\nexport class NgwWebmapLayerAdapter<M = any> implements ResourceAdapter<M> {\n  layer?: NgwWebmapItem;\n\n  NgwWebmapItem: Type<NgwWebmapItem> = NgwWebmapItem;\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  webmapClassName = 'webmap';\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwWebmapLayerAdapterEvents\n  > = new EventEmitter();\n  protected _extent?: LngLatBoundsArray;\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  constructor(public map: M, public options: NgwWebmapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: NgwWebmapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n    this.layer = await this._getWebMapLayerItem();\n    return this.layer;\n  }\n\n  removeLayer(): void {\n    const mapAdapter = this.options.webMap.mapAdapter;\n\n    this.getDependLayers().forEach((x) => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    // delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer(): void {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer(): void {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getNgwWebmapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<NgwWebmapItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  getBookmarksResourceId(): number | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return webmap.bookmark_resource.id;\n    }\n  }\n\n  fetchBookmarks(): CancelablePromise<BookmarkItem[]> {\n    const bookmarkResId = this.getBookmarksResourceId();\n    const connector = this.options.connector;\n    if (bookmarkResId) {\n      return connector.getResourceOrFail(bookmarkResId).then((item) => {\n        const labelField = item.feature_layer?.fields.find(\n          (x) => x.label_field,\n        );\n        const keyname = labelField && labelField.keyname;\n        return fetchNgwLayerItems({\n          connector,\n          resourceId: bookmarkResId,\n          geom: false,\n          fields: keyname ? [keyname] : undefined,\n        }).then((items) => {\n          const bookmarks: BookmarkItem[] = [];\n          for (const i of items) {\n            const bookmark = new BookmarkItem({\n              item: i,\n              resourceId: bookmarkResId,\n              labelField: keyname,\n              connector,\n            });\n            bookmarks.push(bookmark);\n          }\n          return bookmarks;\n        });\n      });\n    }\n    throw new Error(\n      'Webmap was not loaded correctly, it is impossible to extract bookmarks',\n    );\n  }\n\n  async getIdentificationIds(): Promise<number[]> {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => b.id - a.id);\n      deps.forEach((x) => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  protected async _getWebMapLayerItem(): Promise<NgwWebmapItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<NgwWebmapItem>((resolve) => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.setViewDelay = this.options.setViewDelay;\n          options.order = this.options.order;\n          options.ratio = this.options.ratio;\n          options.crossOrigin = this.options.crossOrigin;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new this.NgwWebmapItem(\n            this.options.webMap,\n            webmap.root_item,\n            options,\n            this.options.connector,\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    const data = await this.options.connector.getResource(id);\n    if (data) {\n      this.response = data;\n      const webmap = data[\n        this.webmapClassName as keyof ResourceItem\n      ] as WebmapResource;\n      if (data.basemap_webmap && data.basemap_webmap.basemaps.length) {\n        this._setBasemaps(data.basemap_webmap);\n      } else if (this.options.defaultBasemap) {\n        const webMap = this.options.webMap;\n        webMap.addBaseLayer('OSM', {\n          id: 'webmap-default-baselayer',\n          name: 'OpenStreetMap',\n        });\n      }\n      if (webmap) {\n        this._extent = [\n          webmap.extent_left,\n          webmap.extent_bottom,\n          webmap.extent_right,\n          webmap.extent_top,\n        ];\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    }\n  }\n\n  private _setBasemaps(baseWebmap: BasemapWebmap) {\n    const webMap = this.options.webMap;\n    let enabledAlreadySet = false;\n    baseWebmap.basemaps.forEach((x) => {\n      createOnFirstShowNgwAdapter({\n        webMap,\n        connector: this.options.connector,\n        item: x,\n        adapterOptions: { crossOrigin: this.options.crossOrigin },\n      }).then((adapter) => {\n        // to avoid set many basemaps on init\n        const visibility = enabledAlreadySet ? false : x.enabled;\n        webMap.addBaseLayer(adapter, {\n          name: x.display_name,\n          opacity: x.opacity,\n          visibility,\n        });\n        if (x.enabled) {\n          enabledAlreadySet = true;\n        }\n      });\n    });\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem,\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map((x) =>\n            this._updateItemsParams(x, webMap, data),\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.connector.options.baseUrl +\n            '/api/component/render/image',\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = (params) =>\n          updateImageParams(params, resourceId);\n        const adapter = item.layer_adapter.toUpperCase() as NgwLayerAdapterType;\n        const layerAdapterOptions = getLayerAdapterOptions(\n          {\n            adapter,\n            resource: resourceId,\n          },\n          webMap,\n          this.options.connector.options.baseUrl || '',\n        ) as RasterAdapterOptions;\n        item = {\n          ...item,\n          ...layerAdapterOptions,\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: NgwWebmapItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector.getResource(id).then((y) => {\n            if (y) {\n              const parentId = Number(y.resource.parent.id);\n              item.parentId = parentId;\n              return parentId;\n            }\n          });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter((x) => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n}\n","import { Type } from '@nextgis/webmap';\nimport { GetClassAdapterOptions } from '../interfaces';\nimport { NgwWebmapLayerAdapter as NWLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nexport async function createWebMapAdapter({\n  layerOptions: options,\n  webMap,\n  connector,\n}: GetClassAdapterOptions): Promise<Type<NWLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class NgwWebmapLayerAdapter extends NWLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        url: '',\n        webMap,\n        resourceId,\n        connector,\n      });\n    }\n  };\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\nimport { fetchNgwResourceExtent } from './utils/fetchNgwExtent';\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  protected _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await fetchNgwResourceExtent(\n        this.item,\n        this.connector,\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import { Type, MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createBasemapLayerAdapter({\n  webMap,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  if (item.basemap_layer) {\n    const qms = item.basemap_layer.qms;\n    const url = item.basemap_layer.url;\n    if (qms) {\n      const qms_ = JSON.parse(qms);\n      const adapter = Promise.resolve(\n        QmsKit.utils.createQmsAdapter(webMap, undefined, {\n          qms: qms_,\n          baselayer: true,\n        }),\n      );\n      return adapter;\n    } else if (url) {\n      const TileAdapter = webMap.mapAdapter.layerAdapters.TILE as Type<\n        MainLayerAdapter<any, any, TileAdapterOptions>\n      >;\n      if (TileAdapter) {\n        class BasemapTileAdapter extends TileAdapter {\n          async addLayer(opt: TileAdapterOptions) {\n            return super.addLayer({ ...opt, url });\n          }\n        }\n        return BasemapTileAdapter;\n      }\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport { WebMap } from '@nextgis/webmap';\nimport { Type, applyMixins } from '@nextgis/utils';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createNgwWebmapAdapter';\nimport { NgwResource } from '../NgwResource';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { createBasemapLayerAdapter } from './createBasemapLayerAdapter';\n\nimport type {\n  GetClassAdapterCallback,\n  GetClassAdapterOptions,\n  GetClassAdapterByType,\n  ResourceAdapter,\n  NgwLayerOptions,\n  GetClassAdapter,\n  ClassAdapter,\n} from '../interfaces';\n\nexport const classAdapters: Record<string, GetClassAdapter> = {};\n\nconst supportCls: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'basemap_layer',\n  'vector_layer',\n  'raster_layer',\n  'webmap',\n  // in tms branch\n  'tmsclient_layer',\n];\n\nasync function createAdapterFromFirstStyle({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions) {\n  const parent = item.resource.id;\n  const childrenStyles = await connector.getResourceChildren(parent);\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...layerOptions, resource: firstStyle.resource.id },\n      webMap,\n      connector,\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: ClassAdapter | undefined;\n  let item: ResourceItem | undefined;\n  const adapterType = options.adapter;\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  if (resourceId) {\n    const resourceOptions = options as NgwLayerOptions;\n    const itemFromResOpt = resourceOptions.resource as ResourceItem;\n    if (\n      itemFromResOpt &&\n      itemFromResOpt.resource &&\n      itemFromResOpt.resource.id !== undefined\n    ) {\n      item = itemFromResOpt;\n    } else {\n      item = await connector.getResource(resourceId);\n    }\n    if (item) {\n      const cls = item.resource.cls;\n      const layerOptions: NgwLayerOptions = {\n        ...options,\n        resource: resourceId,\n      };\n\n      const adapterOptions: GetClassAdapterOptions = {\n        layerOptions,\n        webMap,\n        connector,\n        item,\n      };\n\n      if (supportCls.indexOf(cls) !== -1) {\n        if (cls === 'webmap') {\n          adapter = createWebMapAdapter(adapterOptions);\n        } else if (cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(adapterOptions);\n            } else {\n              return createAdapterFromFirstStyle(adapterOptions);\n            }\n          } else {\n            adapter = createGeoJsonAdapter(adapterOptions);\n          }\n        } else if (cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(adapterOptions);\n        } else if (cls === 'basemap_layer') {\n          adapter = createBasemapLayerAdapter(adapterOptions);\n        } else {\n          if (adapterType === 'GEOJSON') {\n            const parentItem = await connector.getResource(\n              item.resource.parent.id,\n            );\n            if (parentItem) {\n              const parentOptions: NgwLayerOptions = {\n                ...options,\n                resource: item.resource.parent.id,\n              };\n              adapter = createGeoJsonAdapter({\n                ...adapterOptions,\n                item: parentItem,\n                layerOptions: parentOptions,\n              });\n            }\n          } else {\n            adapter = createRasterAdapter(adapterOptions);\n          }\n        }\n      } else if (classAdapters[cls]) {\n        const getClassAdapter = classAdapters[cls];\n        let classAdapter: GetClassAdapterCallback | undefined;\n        if (adapterType && typeof classAdapter !== 'function') {\n          classAdapter = (getClassAdapter as GetClassAdapterByType)[\n            adapterType\n          ];\n        } else {\n          classAdapter = getClassAdapter as GetClassAdapterCallback;\n        }\n        if (classAdapter) {\n          adapter = classAdapter(adapterOptions);\n        }\n      } else {\n        throw `Resource class '${cls}' not yet supported.`;\n      }\n    } else {\n      throw 'Resource item is not found';\n    }\n  }\n\n  if (adapter) {\n    return adapter.then((x) => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        if (item) {\n          resourceAdapter.prototype.item = item;\n          resourceAdapter.prototype.resourceId = item.resource.id;\n          resourceAdapter.prototype.connector = connector;\n        }\n\n        applyMixins(resourceAdapter, [NgwResource], { replace: false });\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import NgwConnector from '@nextgis/ngw-connector';\n\nimport { extendNgwWebmapLayerAdapter } from './utils/utils';\nimport { NgwWebmapLayerAdapter } from './NgwWebmapLayerAdapter';\nimport { classAdapters } from './adapters/createAsyncAdapter';\n\nimport type {\n  WebMap,\n  StarterKit,\n  Type,\n  LayerAdapterCreators,\n} from '@nextgis/webmap';\nimport type {\n  NgwKitOptions,\n  NgwWebmapAdapterOptions,\n  GetClassAdapter,\n} from './interfaces';\n\nexport class NgwKit implements StarterKit {\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl || '';\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth,\n      });\n    }\n  }\n\n  static addClassAdapters(cls: string, adapter: GetClassAdapter): void {\n    classAdapters[cls] = adapter;\n  }\n\n  async onLoadSync(webMap: WebMap): Promise<NgwWebmapLayerAdapter | undefined> {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: Partial<NgwWebmapAdapterOptions> = {\n            resourceId: r,\n            connector: this.connector,\n            webMap,\n          };\n          const layer = (await webMap.addLayer(NgwWebmapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            pixelRadius: this.options.pixelRadius,\n            ...options,\n          })) as NgwWebmapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap)),\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<NgwWebmapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendNgwWebmapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl,\n    });\n  }\n}\n","import { fetchNgwLayerItem, IdentifyItemOptions } from '.';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { NgwFeatureItemResponse } from '.';\nimport type { GeoJsonObject, Geometry, Feature } from 'geojson';\nimport type {\n  FeatureItemExtensions,\n  FeatureResource,\n  LayerFeature,\n  VectorLayerResourceItem,\n} from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport class IdentifyItem<F = FeatureProperties, G extends Geometry = Geometry>\n  implements LayerFeature\n{\n  readonly id: number;\n  readonly label: string;\n  readonly layerId: number;\n  readonly parent: string;\n  readonly fields: FeatureProperties;\n  geom?: GeoJsonObject;\n  extensions?: FeatureItemExtensions;\n\n  private connector: NgwConnector;\n  private _item?: NgwFeatureItemResponse<F, G>;\n  private _geojson?: Feature<G, F>;\n  private _resource?: VectorLayerResourceItem;\n\n  constructor(options: IdentifyItemOptions) {\n    const f = options.feature;\n    this.id = f.id;\n    this.label = f.label;\n    this.layerId = f.layerId;\n    this.parent = f.parent;\n    this.fields = f.fields;\n    this.geom = f.geom;\n    this.connector = options.connector;\n  }\n\n  identify(): CancelablePromise<NgwFeatureItemResponse<F, G>> {\n    if (this._item) {\n      return CancelablePromise.resolve(this._item);\n    }\n    return fetchNgwLayerItem<G, F>({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n      fields: null,\n      extensions: ['attachment', 'description'],\n    }).then((resp) => {\n      this._item = resp;\n      this.geom = resp.geom;\n      this.extensions = resp.extensions;\n      return resp;\n    });\n  }\n\n  resource(): CancelablePromise<FeatureResource> {\n    if (this._resource) {\n      return CancelablePromise.resolve(this._resource.feature_layer);\n    }\n    return this.connector.getResource(this.layerId).then((resp) => {\n      this._resource = resp as VectorLayerResourceItem;\n      return this._resource.feature_layer;\n    });\n  }\n\n  geojson(): CancelablePromise<Feature<G, F>> {\n    if (this._geojson) {\n      return CancelablePromise.resolve(this._geojson);\n    }\n    return this.identify().then((resp) => {\n      return resp.toGeojson().then((geojson) => {\n        this._geojson = geojson;\n        return geojson;\n      });\n    });\n  }\n}\n","import { Geometry } from 'geojson';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createGeoJsonFeature,\n  FEATURE_REQUEST_PARAMS,\n  updateItemRequestParam,\n} from './featureLayerUtils';\n\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  NgwFeatureItemResponse,\n  FeatureRequestParams,\n  FetchNgwItemOptions,\n} from '../interfaces';\n\nexport function fetchNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G>> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  updateItemRequestParam(params, options);\n  const queryParams = {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params,\n  };\n  const cache = options.cache || true;\n  return options.connector\n    .get('feature_layer.feature.item', { cache }, queryParams)\n    .then((resp) => {\n      return {\n        ...resp,\n        toGeojson: () => {\n          if (resp.geom) {\n            return CancelablePromise.resolve(createGeoJsonFeature<G, P>(resp));\n          } else {\n            return fetchNgwLayerItem({\n              ...options,\n              geom: true,\n              fields: null,\n              extensions: null,\n            }).then((onlyGeomItem) => {\n              const geom = onlyGeomItem.geom;\n              return createGeoJsonFeature<G, P>({ ...resp, geom });\n            });\n          }\n        },\n      } as NgwFeatureItemResponse<P, G>;\n    });\n}\n","import { fetchNgwLayerItem } from './fetchNgwLayerItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FetchNgwItemOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>,\n>(options: FetchNgwItemOptions<P>): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerItem<G, P>(options).then((item) => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  JsonMap,\n  degrees2meters,\n  getCirclePolygonCoordinates,\n  deprecatedMapClick,\n} from '@nextgis/utils';\nimport { IdentifyItem } from '../IdentifyItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type { MapClickEvent } from '@nextgis/webmap';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  LayerFeature,\n  FeatureLayersIdentify,\n} from '@nextgis/ngw-connector';\nimport type {\n  FeatureIdentifyRequestOptions,\n  GetIdentifyGeoJsonOptions,\n  IdentifyRequestOptions,\n  NgwFeatureItemResponse,\n  IdentifyItemOptions,\n  NgwIdentifyItem,\n  NgwIdentify,\n} from '../interfaces';\n\nexport function getIdentifyItems(\n  identify: NgwIdentify,\n  multiple = false,\n): NgwIdentifyItem[] {\n  let params:\n    | { resourceId: number; featureId: number; feature: LayerFeature }\n    | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort((a, b) => {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const identifyItem = identify[l];\n    if ('features' in identifyItem) {\n      const layerFeatures = identifyItem.features;\n      const resourceId = Number(l);\n      const feature: LayerFeature | undefined = layerFeatures[0];\n      if (feature) {\n        params = {\n          featureId: feature.id,\n          resourceId,\n          feature,\n        };\n        paramsList.push(params);\n        if (!multiple) {\n          break;\n        }\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function fetchIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      if ('features' in item) {\n        const withGeom = item.features.find((x) => x.geom);\n\n        if (withGeom && withGeom.geom) {\n          const geom = withGeom.geom as Geometry;\n          return CancelablePromise.resolve(\n            createGeoJsonFeature({\n              ...withGeom,\n              geom,\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerFeature({ connector, ...params[0] });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\nexport function fetchIdentifyItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: GetIdentifyGeoJsonOptions<G, P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n  const { connector, identify } = options;\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerItem<G, P>({\n      connector,\n      ...options.requestOptions,\n      ...params[0],\n    });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\n/**\n * @deprecated use {@link fetchIdentifyGeoJson} instead\n */\nexport function getIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  return fetchIdentifyGeoJson(options);\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  deprecatedMapClick(ev);\n  const [lng, lat] = ev.lngLat;\n\n  let geom: number[][] = [];\n\n  if (options.geom) {\n    const polygon =\n      options.geom.type === 'Feature'\n        ? options.geom.geometry\n        : options.geom.type === 'Polygon'\n        ? options.geom\n        : false;\n    if (polygon) {\n      geom = polygon.coordinates[0];\n    }\n  }\n  if (!geom.length) {\n    geom = getCirclePolygonCoordinates(lng, lat, options.radius);\n  }\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers,\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\nexport function createIdentifyItem<\n  F = FeatureProperties,\n  G extends Geometry = Geometry,\n>(opt: IdentifyItemOptions): IdentifyItem {\n  return new IdentifyItem<F, G>(opt);\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport { CompanyLogoOptions } from '../interfaces';\n\nexport async function getCompanyLogo(\n  connector: NgwConnector,\n  options?: CompanyLogoOptions,\n): Promise<HTMLElement | undefined> {\n  const settings = await connector.get('pyramid.settings', null, {\n    component: 'pyramid',\n  });\n  if (settings && settings.company_logo && settings.company_logo.enabled) {\n    const anchor = document.createElement('a');\n    anchor.style.position = 'absolute';\n    anchor.style.bottom = '0';\n    anchor.style.right = '0';\n    anchor.style.padding = options?.padding ?? '10px';\n    anchor.className = 'ngw-map-logo';\n    if (options && options.cssClass) {\n      anchor.className += ' ' + options.cssClass;\n    }\n    const img = new Image();\n    img.style.maxHeight = '100px';\n    img.style.maxWidth = '100px';\n    img.src = '';\n    try {\n      const src = await connector.get('pyramid.company_logo', {\n        responseType: 'blob',\n      });\n      const urlCreator = window.URL || window.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(src);\n      img.src = imageUrl;\n    } catch (er) {\n      console.log(er);\n    }\n\n    if (\n      settings.company_logo.link !== null &&\n      settings.company_logo.link.trim() !== ''\n    ) {\n      anchor.href = settings.company_logo.link;\n      anchor.target = '_blank';\n      if (settings.company_logo.link.search(/:\\/\\/nextgis/) !== -1) {\n        img.alt = 'Get your own Web GIS at nextgis.com';\n      }\n    }\n    anchor.appendChild(img);\n    return anchor;\n  }\n}\n","import type {\n  NgwLayerOptions,\n} from '@nextgis/ngw-kit';\nimport type { NgwResourceDefinition } from '../interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: Partial<NgwLayerOptions>,\n  overwriteOptions?: Partial<NgwLayerOptions>,\n): void {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resource,\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({\n      ...defOptions,\n      resource: resourceId,\n      id,\n      ...overwriteOptions,\n    });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n","import { deepmerge } from '@nextgis/utils';\nimport { StarterKit, MapOptions } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { NgwKit } from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from '../interfaces';\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  whitlabel: false,\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"https://nextgis.com\" target=\"_blank\">NextGIS</a>',\n      ],\n    },\n  },\n  pixelRadius: 10,\n};\n\nexport function prepareWebMapOptions(options: NgwMapOptions): MapOptions {\n  const kits: StarterKit[] = [new QmsKit()];\n  if (options.starterKits) {\n    options.starterKits.forEach((x) => {\n      kits.push(x);\n    });\n  }\n\n  if (!options.connector) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl || '',\n      auth: options.auth,\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  options = deepmerge(OPTIONS, options);\n\n  if (!options.center && !options.bounds) {\n    options.bounds = [-179, -90, 180, 90];\n    options.maxBounds = options.bounds;\n  }\n\n  if (options.connector) {\n    kits.push(\n      new NgwKit({\n        connector: options.connector,\n        auth: options.auth,\n      }),\n    );\n  }\n  options = {\n    ...options,\n    starterKits: kits,\n    create: false,\n  };\n  return options;\n}\n","import StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined, isObject } from '@nextgis/utils';\nimport { AdapterOptions, WebMap } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\n\nimport {\n  addNgwLayer,\n  fetchNgwLayerItem,\n  fetchNgwLayerItems,\n  fetchNgwLayerFeature,\n  fetchNgwLayerFeatureCollection,\n  fetchIdentifyGeoJson,\n  fetchNgwResourceExtent,\n  sendIdentifyRequest,\n  getCompanyLogo,\n  fetchIdentifyItem,\n  getIdentifyItems,\n  createIdentifyItem,\n  NgwLayerAdapterType,\n} from '@nextgis/ngw-kit';\nimport { deprecatedWarn } from '@nextgis/utils';\nimport { getIcon } from '@nextgis/icons';\n\nimport { appendNgwResources } from './utils/appendNgwResources';\nimport { prepareWebMapOptions } from './utils/prepareWebMapOptions';\n\nimport type { JsonMap, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureItem,\n  LayerFeature,\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureLayersIdentifyItems,\n} from '@nextgis/ngw-connector';\nimport type {\n  OnLayerClickOptions,\n  ControlPosition,\n  FilterOptions,\n  MapClickEvent,\n  LayerAdapter,\n  WebMapEvents,\n  MapControls,\n  FitOptions,\n  LayerDef,\n} from '@nextgis/webmap';\nimport type {\n  NgwIdentify,\n  NgwWebmapItem,\n  ResourceAdapter,\n  FetchNgwItemsOptions,\n  NgwFeatureItemResponse,\n  NgwFeatureRequestOptions,\n} from '@nextgis/ngw-kit';\nimport type { Geometry, Feature, FeatureCollection } from 'geojson';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type { NgwMapOptions, NgwMapEvents, NgwLayers } from './interfaces';\nimport type { FetchNgwItemOptions } from '@nextgis/ngw-kit';\n\ntype PromiseGroup = 'select' | 'identify';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import { NgwMap } from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n *   qmsId: 448,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n * @public\n */\nexport class NgwMap<\n  M = unknown,\n  L = unknown,\n  C = unknown,\n  O extends NgwMapOptions<C> = NgwMapOptions<C>,\n> extends WebMap<M, L, C, NgwMapEvents, O> {\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<EventEmitter, NgwMapEvents> =\n    new EventEmitter();\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private $$selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private $$selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n  private _promises: Record<PromiseGroup, CancelablePromise[]> = {\n    select: [],\n    identify: [],\n  };\n\n  constructor(options: O) {\n    super(prepareWebMapOptions(options) as O);\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      if (this.options.whitlabel) {\n        this._whiteLabel();\n      }\n    });\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param options - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    await this.onLoad('controls:create');\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource definition.\n   * @param options - set layer identification parameters and render method.\n   *\n   * @example\n   * ```javascript\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resource: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resource: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  async addNgwLayer<\n    T extends NgwLayerAdapterType = NgwLayerAdapterType,\n    P = FeatureProperties,\n  >(options: NgwLayerOptions<T, P>): Promise<ResourceAdapter | undefined> {\n    await this.onMapLoad();\n    // @ts-ignore for backward compatibility\n    const { keyname, resourceId } = options;\n\n    if (keyname || resourceId !== undefined) {\n      deprecatedWarn(\n        'set `resource` options instead of `keyname` or `resourceId`',\n      );\n    }\n\n    const resource = options.resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resource, resourceId or keyname is required parameter to add NGW layer',\n      );\n    }\n    if (defined(this.options.baseUrl)) {\n      try {\n        if (defined(this.options.setViewDelay)) {\n          options.adapterOptions = options.adapterOptions || {};\n          if (!defined(options.adapterOptions.setViewDelay)) {\n            options.adapterOptions.setViewDelay = this.options.setViewDelay;\n          }\n        }\n        const adapter = addNgwLayer(options, this, this.connector);\n        const adapterOpts = {\n          visibility: true,\n          // TODO: do not merge options, use only `adapterOptions`\n          ...options,\n          ...options.adapterOptions,\n        } as AdapterOptions;\n        const layer = (await this.addLayer(\n          adapter,\n          adapterOpts,\n        )) as ResourceAdapter<M, L, AdapterOptions>;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baselayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n        return layer;\n      } catch (er) {\n        const resId =\n          isObject(resource) && 'id' in resource\n            ? resource.id\n            : keyname || resourceId || resource;\n        console.error(`Can't add NGW layer ${resId}.`, er);\n      }\n    }\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit(): void {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  fetchNgwLayerItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureItem> {\n    return fetchNgwLayerItem<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerItems<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(\n    options: Omit<FetchNgwItemsOptions<F>, 'connector'>,\n  ): CancelablePromise<FeatureItem<F, G>[]> {\n    return fetchNgwLayerItems<G, F>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<Feature<G, P>> {\n    return fetchNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemsOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return fetchNgwLayerFeatureCollection({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchIdentifyItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    identify: NgwIdentify,\n    requestOptions?: NgwFeatureRequestOptions,\n    // multiple = false\n  ): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n    const promise = fetchIdentifyItem<G, P>({\n      identify,\n      connector: this.connector,\n      requestOptions,\n      // multiple,\n    });\n\n    this._addPromise('identify', promise);\n    return promise;\n  }\n\n  fetchIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    const promise = fetchIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple,\n    });\n    if (promise && 'then' in promise) {\n      this._addPromise('identify', promise);\n      return promise;\n    } else {\n      return CancelablePromise.resolve(promise);\n    }\n  }\n\n  /**\n   * @deprecated use {@link fetchIdentifyGeoJson} instead\n   */\n  getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    return this.fetchIdentifyGeoJson(identify, multiple);\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some((x) => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as NgwWebmapItem[];\n        const dependFit = dependLayers.find((x) => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.fitLayer(ngwLayer);\n   * ngwMap.fitLayer('ngw_layer_name');\n   * ```\n   */\n  async fitLayer(layerDef: LayerDef, options?: FitOptions): Promise<void> {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent, options);\n        }\n      } else {\n        let item: ResourceItem | undefined;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.getResource(resourceId);\n        }\n        if (item) {\n          fetchNgwResourceExtent(item, this.connector).then((extent) => {\n            if (extent) {\n              this.fitBounds(extent, options);\n            }\n          });\n        }\n      }\n    } else {\n      super.fitLayer(layerDef, options);\n    }\n  }\n\n  /** @deprecated use {@link NgwMap.fitLayer} instead */\n  async zoomToLayer(layerDef: string | ResourceAdapter): Promise<void> {\n    return this.fitLayer(layerDef);\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection(): void {\n    if (!this.$$selectFromNgwRaster) {\n      this.$$selectFromNgwRaster = (ev: MapClickEvent) => {\n        const count = this.emitter.listenerCount('ngw:select');\n        if (count) {\n          this._selectFromNgwRaster(ev);\n        }\n      };\n      this.$$selectFromNgwVector = (ev: OnLayerClickOptions) => {\n        if (this.emitter.listenerCount('ngw:select')) {\n          this._selectFromNgwVector(ev);\n        }\n      };\n      this.emitter.on('click', this.$$selectFromNgwRaster);\n      this.emitter.on('layer:click', this.$$selectFromNgwVector);\n    }\n  }\n\n  disableSelection(): void {\n    if (this.$$selectFromNgwRaster) {\n      this.emitter.removeListener('click', this.$$selectFromNgwRaster);\n      this.emitter.removeListener('click', this._selectFromNgwVector);\n      this.$$selectFromNgwRaster = undefined;\n      this.$$selectFromNgwVector = undefined;\n    }\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItem} instead\n   */\n  getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return this.fetchNgwLayerItem(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItems} instead\n   */\n  getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions,\n  ): CancelablePromise<FeatureItem[]> {\n    return this.fetchNgwLayerItems(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeature} instead\n   */\n  getNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends JsonMap = JsonMap,\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return this.fetchNgwLayerFeature(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeatures} instead\n   */\n  getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends JsonMap = JsonMap,\n  >(\n    options: FetchNgwItemsOptions<P>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return this.fetchNgwLayerFeatures(options);\n  }\n\n  /** @deprecated use {@link NgwMap.cancelPromises} instead */\n  cancelPromise(...args: PromiseGroup[]): void {\n    this.cancelPromises(...args);\n  }\n\n  cancelPromises(...args: PromiseGroup[]): void {\n    if (!args.length) {\n      args = Object.keys(this._promises) as PromiseGroup[];\n    }\n    args.forEach((name) => {\n      const group = this._promises[name];\n      if (group) {\n        group.forEach((x) => x.cancel());\n        this._promises[name] = [];\n      }\n    });\n  }\n\n  private _addPromise(groupName: PromiseGroup, promise: CancelablePromise) {\n    const group = this._promises[groupName];\n    if (group && group.indexOf(promise) === -1) {\n      const removeFromGroup = () => {\n        const index = group.indexOf(promise);\n        if (index !== -1) {\n          group.splice(index, 1);\n        }\n      };\n      promise.then(removeFromGroup);\n      promise.catch(removeFromGroup);\n      group.push(promise);\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create();\n    if (this.options.qmsId) {\n      this.addQmsBaseLayer();\n    }\n    if (this.options.osm) {\n      this.addOsmBaseLayer();\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed,\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach((x) => {\n        const overwriteOptions: Partial<NgwLayerOptions> = {};\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n    for (const r of resources) {\n      try {\n        await this.addNgwLayer(r);\n      } catch (er) {\n        console.log(er);\n      }\n    }\n    this._emitStatusEvent('ngw-map:create', this);\n    this.enableSelection();\n  }\n\n  private addOsmBaseLayer() {\n    this.addBaseLayer('OSM');\n  }\n\n  private addQmsBaseLayer() {\n    let qmsId: number;\n    let qmsLayerName: string | undefined;\n    if (Array.isArray(this.options.qmsId)) {\n      qmsId = this.options.qmsId[0];\n      qmsLayerName = this.options.qmsId[1];\n    } else {\n      qmsId = Number(this.options.qmsId);\n    }\n    const qmsLayerOptions: Partial<QmsAdapterOptions> = {\n      qmsId,\n    };\n    if (qmsLayerName) {\n      qmsLayerOptions.id = qmsLayerName;\n    }\n\n    this.addBaseLayer('QMS', qmsLayerOptions);\n  }\n\n  private _selectFromNgwVector(\n    ev: OnLayerClickOptions,\n  ): FeatureLayersIdentify | undefined {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties || {},\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry,\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature],\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items,\n        };\n        this._emitStatusEvent(\n          'ngw:select',\n          this._prepareToIdentify({\n            ...identify,\n            resources: [id],\n            sourceType: 'vector',\n          } as NgwIdentify),\n        );\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    const layers = Object.values(this._ngwLayers);\n    layers.sort((a, b) => {\n      if (a.layer.order && b.layer.order) {\n        return b.layer.order - a.layer.order;\n      }\n      return 1;\n    });\n    layers.forEach((l) => {\n      const layer = l.layer;\n      const identFunc =\n        typeof layer.getIdentificationIds === 'function'\n          ? layer.getIdentificationIds\n          : false;\n      if (identFunc && layer.options.selectable && this.isLayerVisible(layer)) {\n        promises.push(identFunc.call(layer));\n      }\n    });\n    const getIdsPromise = Promise.all(promises);\n    const getIds = await getIdsPromise;\n    const ids: number[] = [];\n    getIds.forEach((x) => {\n      if (x) {\n        x.forEach((y) => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    let zoom = this.getZoom();\n    zoom = zoom !== undefined ? zoom : 20;\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n\n    const selectPromise = sendIdentifyRequest(ev, {\n      layers: ids,\n      connector: this.connector,\n      radius,\n    }).then((resp) => {\n      this._emitStatusEvent(\n        'ngw:select',\n        this._prepareToIdentify({\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev,\n        }),\n      );\n      return resp;\n    });\n    this._addPromise('select', selectPromise);\n    return selectPromise;\n  }\n\n  private _prepareToIdentify(identify: NgwIdentify) {\n    const getIdentifyItems_ = () => {\n      return getIdentifyItems(identify, true).map((x) => {\n        return createIdentifyItem({\n          feature: x.feature,\n          connector: this.connector,\n        });\n      });\n    };\n    return {\n      ...identify,\n      getIdentifyItems: getIdentifyItems_,\n    };\n  }\n\n  private async _whiteLabel() {\n    const container = this.getContainer();\n    if (container) {\n      const logo = await getCompanyLogo(\n        this.connector,\n        this.options.companyLogoOptions,\n      );\n      if (logo) {\n        container.appendChild(logo);\n      }\n    }\n  }\n}\n"],"names":["createPopupContent","feature","item","element","document","createElement","feature_layer","fields","forEach","x","grid_visibility","value","properties","keyname","propElem","appendChild","innerHTML","display_name","p","filterOptionsKeys","getLayerFilterOptions","options","filterOptions","opt","undefined","resourceIdFromLayerOptions","connector","resource","resourceId","id","getResource","resourceItem","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","geometry","geom","type","updateItemRequestParam","params","extensions","join","Array","isArray","defined","createFeatureFieldFilterQueries","_queries","_parentAllParams","filters","logic","filters_","filter","createParam","pf","field","operation","f","checkIfPropertyFilter","push","fetchNgwLayerItemsRequest","paramList","propertiesFilterList","length","CancelablePromise","then","itemsParts","items","reduce","a","b","concat","offset","limit","splice","polygon","intersects","orderBy","Number","POSITIVE_INFINITY","order_by","coordinates","isLngLatBoundsArray","getBoundsCoordinates","map","lng","lat","degrees2meters","reqParams","get","cache","prepareNgwFieldsToPropertiesFilter","isObject","date","year","month","day","dt","hour","minute","second","Date","toISOString","fetchNgwLayerItems","data","y","propertiesFilter","fetchNgwLayerFeatureCollection","features","fetchNgwLayerFeatures","getNgwWebmapExtent","webmap","bottom","left","top","right","extent","fetchNgwLayerExtent","resp","maxLat","maxLon","minLat","minLon","fetchNgwResourceExtent","cls","indexOf","parent","res","createGeoJsonAdapter","props","webMap","Adapter","layerOptions","alop","addLayerOptionsPriority","GeoJsonAdapter","mapAdapter","layerAdapters","GEOJSON","_fullDataLoad","adapterOptions","popupOptions","fromProperties","getData","filterOpt","abort","_lastFilterArgs","_dataPromise","removed","cancel","NgwGeoJsonAdapter","EventEmitter","needUpdate","waitFullLoad","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","Object","keys","layer","this","strategy","updatePromise","updateLayer","_addBboxEventListener","hasData","getLayers","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","__onMapMoveStart","_count","total_count","filterArgs","onLoad","getBounds","getCount","count","setLayerData","emitter","emit","name","e","props_","setData","clearLayer","_addMoveEventListener","on","debounce","removeListener","getLayerAdapterOptions","baseUrl","url","adapter","getLayerAdapters","isImageAllowed","IMAGE","nd","tileNoData","headers","updateWmsParams","updateImageParams","format","version","layers","simplification","Error","console","log","createRasterAdapter","resourceCls","clsAdapterAlias","wmsserver_service","tmsclient_layer","adapterClass","_options","layerAdapterOptions","setViewDelay","String","addOptions","NgwWebmapItem","noInit","tree","setParent","item_type","_rootDescendantsCount","_sumUp","children","root","getRoot","initProperties","_init","i","getItemOptions","setNewLayer","l","_layer","set","opacity","setLayerOpacity","getChildren","addChild","Promise","resolve","layer_adapter","toUpperCase","GetAdapterFromLayerType","getAdapter","addLayer","newLayer","reject","transparency","layer_transparency","visibility","crossOrigin","order","subOrder","drawOrderEnabled","draw_order_position","subLevel","padStart","maxZoom","layer_max_scale_denom","_mapScaleToZoomLevel","minZoom","layer_min_scale_denom","objectAssign","ratio","minScale","maxScale","reverse","scale","centerLat","getZoomFromScale","pixelsInMeterWidth","getMapWidthForLanInMeters","setScaleRatio","initItem","totalValue","child","ngwWebmapItem","Item","idPrefix","OnFirstShowAdapter","_removed","removeLayer","showLayer","createAsyncAdapter","resource_id","baselayer","assign","hideLayer","getProperty","treeSome","layer_enabled","onSet","BookmarkItem","labelField","_extent","fid","lonLat","fetchNgwLayerItem","featureId","onlyGeomItem","NgwWebmapLayerAdapter","r","_getWebMapLayerItem","getDependLayers","response","_webmapLayersIds","property","getDescendants","bookmark_resource","bookmarkResId","getBookmarksResourceId","getResourceOrFail","find","label_field","bookmarks","bookmark","visibleLayers","ids","_getWebMapIds","sort","parentId","visible","isBlocked","getWebMapConfig","root_item","auth","getAuthorizationHeaders","draw_order_enabled","webmapClassName","basemap_webmap","basemaps","_setBasemaps","defaultBasemap","addBaseLayer","extent_left","extent_bottom","extent_right","extent_top","_updateItemsParams","baseWebmap","enabledAlreadySet","createOnFirstShowNgwAdapter","enabled","fixUrlStr","layer_style_id","webMapItem","promises","promise","all","createWebMapAdapter","NWLayerAdapter","NgwResource","createBasemapLayerAdapter","basemap_layer","qms","qms_","JSON","parse","QmsKit","TileAdapter","TILE","BasemapTileAdapter","classAdapters","supportCls","createAdapterFromFirstStyle","getResourceChildren","childrenStyles","firstStyle","adapterType","itemFromResOpt","parentItem","parentOptions","getClassAdapter","classAdapter","resourceAdapter","prototype","applyMixins","replace","bbox","width","height","size","timestamp","now","_pixelsInMeter","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","addNgwLayer","extendNgwWebmapLayerAdapter","div","style","cssText","body","px","offsetWidth","removeChild","Math","PI","cos","LN2","NgwKit","NgwConnector","resourceIds","fit","pixelRadius","_getLayerAdapter","createAdapter","_createAdapter","IdentifyItem","label","layerId","_item","_resource","_geojson","identify","toGeojson","geojson","queryParams","fetchNgwLayerFeature","getIdentifyItems","multiple","resources","paramsList","isNaN","sortingArr","fry","identifyItem","layerFeatures","fetchIdentifyGeoJson","withGeom","fetchIdentifyItem","requestOptions","sendIdentifyRequest","ev","deprecatedMapClick","lngLat","getCirclePolygonCoordinates","radius","post","createIdentifyItem","getCompanyLogo","component","settings","company_logo","anchor","position","padding","className","cssClass","img","Image","maxHeight","maxWidth","src","responseType","urlCreator","window","URL","webkitURL","imageUrl","createObjectURL","link","trim","href","target","search","alt","appendNgwResources","defOptions","overwriteOptions","OPTIONS","whitlabel","controls","controlsOptions","ZOOM","ATTRIBUTION","customAttribution","NgwMap","kits","starterKits","deepmerge","center","bounds","maxBounds","create","prepareWebMapOptions","select","_createWebMap","container","getContainer","classList","add","_whiteLabel","controlDef","onMapLoad","deprecatedWarn","adapterOpts","getLayerId","_ngwLayers","getActiveBaseLayer","resId","error","zoom","setCenter","setZoom","fitBounds","_addPromise","n","mem","getIdentificationIds","some","dependLayers","dependFit","layerDef","ngwLayer","getExtent","fitLayer","event","getLayer","$$selectFromNgwRaster","listenerCount","_selectFromNgwRaster","$$selectFromNgwVector","_selectFromNgwVector","cancelPromises","args","_promises","group","groupName","removeFromGroup","index","catch","_initMapState","qmsId","addQmsBaseLayer","osm","addOsmBaseLayer","layerFitAllowed","_isFitFromResource","webmapId","_emitStatusEvent","enableSelection","qmsLayerName","qmsLayerOptions","featureCount","_prepareToIdentify","sourceType","values","identFunc","selectable","isLayerVisible","call","getIdsPromise","getIds","getCenter","getZoom","metresPerPixel","abs","pow","selectPromise","companyLogoOptions","logo","WebMap","getIcon"],"sourceRoot":""}