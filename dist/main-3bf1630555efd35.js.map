{"version":3,"sources":["webpack://clear_horizon/./@nextgis/packages/paint/src/typeHelpers.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/fromPaintExpression.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/preparePaint.ts","webpack://clear_horizon/./@nextgis/packages/properties-filter/src/propertiesFilter.ts"],"names":["isPaint","paint","Object","prototype","toString","call","isPaintCallback","expressions","get","feature","args","field","properties","match","lookup","cases","property","Array","isArray","featureExpression","defValue","splice","length","fry","expression","name","expressionFun","createPropertyExpressionCb","excludeExpressionList","preparePaint","defaultPaint","getPaintFunctions","Error","newPaint","getPaintFunction","getPaint","type","isPropertiesPaint","mask","paintsFilters","forEach","x","push","find","featureFilter","from","options","updatePaintOptionFromCallback","expressionCallback","value","withExpression","p","indexOf","p_","val","fromCb","createExpressionCallback","fill","undefined","stroke","strokeColor","strokeOpacity","color","fillColor","opacity","fillOpacity","like","b","a","iLike","String","toUpperCase","re","reEscape","replace","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","ilike","checkIfPropertyFilter","filter","pf","filters","$id","id","propertiesFilter","logic","filterFunction","operation","operationExec","prop","value_","cleanField","filters_","some","every"],"mappings":"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","file":"main-3bf1630555efd35.js","sourcesContent":["import type {\n  Expression,\n  Paint,\n  PropertiesPaint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintCallback,\n  IconPaint,\n} from './interfaces';\n\nexport function isExpression(value: unknown): value is Expression {\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { isExpression } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  Expression,\n  ExpressionName,\n} from './interfaces';\n\ntype ExpressionFun = (feature: Feature, args: any[]) => SimpleType;\n\nfunction get(feature: Feature, args: any[]) {\n  const field = args[0];\n  return feature.properties && feature.properties[field];\n}\n\nfunction match(feature: Feature, args: any[]) {\n  const [lookup, ...cases] = args;\n  let property = lookup;\n  if (Array.isArray(lookup)) {\n    property = featureExpression(feature, lookup as Expression);\n  }\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry];\n    if (key === property) {\n      return cases[fry + 1];\n    }\n  }\n  return defValue;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFun } = {\n  get,\n  match,\n};\n\ntype SimpleType = string | number | boolean | undefined;\n\ntype PropertyExpressionCb = (feature: Feature) => SimpleType;\n\nfunction featureExpression(feature: Feature, expression: Expression) {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(feature, args);\n  }\n  return undefined;\n}\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    return featureExpression(feature, expression);\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: VectorAdapterLayerPaint,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  Paint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintFunction,\n  GetCustomPaintOptions,\n  PropertiesPaint,\n  PropertyPaint,\n  GetPaintCallback,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  propertiesPaint.forEach((x) => {\n    if (x) {\n      if (Array.isArray(x)) {\n        paintsFilters.push(x);\n      } else {\n        mask = x as VectorAdapterLayerPaint;\n      }\n    }\n  });\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint?: GeometryPaint,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint(\n        paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    const expressionCallback = createExpressionCallback(paint);\n    if (expressionCallback) {\n      return (feature: Feature) => {\n        return preparePaint(\n          expressionCallback(feature),\n          defaultPaint,\n          getPaintFunctions,\n        ) as VectorAdapterLayerPaint;\n      };\n    }\n\n    newPaint = { ...newPaint, ...paint };\n    newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n    newPaint.stroke =\n      newPaint.stroke !== undefined\n        ? newPaint.stroke\n        : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import { reEscape } from '@nextgis/utils';\n\nimport type { Feature, GeoJsonProperties } from 'geojson';\n/**\n * gt - greater (\\>)\n * lt - lower (\\<)\n * ge - greater or equal (\\>=)\n * le - lower or equal (\\<=)\n * eq - equal (=)\n * ne - not equal (!=)\n * like - LIKE SQL statement (for strings compare)\n * ilike - ILIKE SQL statement (for strings compare)\n */\nexport type Operations =\n  | 'gt'\n  | 'lt'\n  | 'ge'\n  | 'le'\n  | 'eq'\n  | 'ne'\n  | 'in'\n  | 'notin'\n  | 'like'\n  | 'ilike';\n\ntype Properties = GeoJsonProperties;\n\n/**\n * field, operation, value\n * ['foo', 'eq', 'bar']\n * ['count', 'ge', 20]\n */\nexport type PropertyFilter<T extends Properties = Properties> = [\n  T extends null ? string : keyof T,\n  Operations,\n  any,\n];\n\nexport type PropertiesFilter<T extends Properties = Properties> = (\n  | 'all'\n  | 'any'\n  | PropertyFilter<T>\n  | PropertiesFilter<T>\n)[];\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operations]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter,\n): boolean {\n  const properties: GeoJsonProperties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter(\n  properties: { [field: string]: any },\n  filters: PropertiesFilter,\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (checkIfPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n"],"sourceRoot":""}