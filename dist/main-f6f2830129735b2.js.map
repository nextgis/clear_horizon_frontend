{"version":3,"file":"main-f6f2830129735b2.js","mappings":"myEAcO,IAAMA,EAAb,WAKE,WAAmBC,GACjB,G,4FADyC,cAAxBA,QAAAA,EAAwB,wEACrCC,KAAKD,QAAQE,UACfD,KAAKE,IAAMF,KAAKD,QAAQE,UAAUF,QAAQI,SAAW,GACrDH,KAAKC,UAAYD,KAAKD,QAAQE,cACzB,CACL,IAAID,KAAKD,QAAQI,QAGf,MAAM,IAAIC,MAAM,sBAFhBJ,KAAKE,IAAMF,KAAKD,QAAQI,QAI1BH,KAAKC,UAAY,IAAII,EAAAA,EAAa,CAChCF,QAASH,KAAKE,IACdI,KAAMN,KAAKD,QAAQO,Q,YAjB3B,S,EAAA,E,EAAA,0B,EAAA,yBA0BE,WAAiBC,GAAjB,oGACMP,KAAKD,QAAQS,aAAcR,KAAKE,IADtC,sBAGUO,EAAc,CAACT,KAAKD,QAAQS,aAElBE,OALpB,qBAMsBD,GANtB,gEAMiBE,EANjB,QAOcZ,EAA4C,CAChDS,WAAYG,EACZV,UAAWD,KAAKC,UAChBM,OAAAA,GAVV,UAY6BA,EAAOK,SAASC,EAAAA,EAAhB,GACnBC,YAAY,EACZC,KAAK,EACLC,YAAahB,KAAKD,QAAQiB,aACvBjB,IAhBb,eAYckB,EAZd,yBAkBeA,GAlBf,sMA1BF,E,8KAAA,4EAkDE,WACE,OAAOC,QAAQC,QAAQ,CAACnB,KAAKoB,uBAnDjC,8BAsDE,WAA2B,WACzB,MAAO,CACLC,KAAM,SACNC,cAAe,SAACC,GAAD,OACbL,QAAQC,QAAQ,EAAKK,eAAeD,QA1D5C,4BA8DE,SAAuBhB,GACrB,IAAMN,EAAYD,KAAKC,UACjBE,EAAUH,KAAKE,IACrB,OAAOuB,EAAAA,EAAAA,IAA4B,CACjClB,OAAAA,EACAN,UAAAA,EACAE,QAAAA,O,EApEN,+BAsBE,SAAwBuB,EAAaC,GACnCC,EAAAA,EAAcF,GAAOC,K,8BAvBzB,M,y5CCRO,IAAME,EAAb,a,kOAAA,U,QAAA,G,EAAA,E,+YAAA,6D,EAAA,G,EAAA,0BAGE,WACE,IAAMZ,EAAQjB,KAAK8B,KAAKb,MACxB,OAAIA,GACKA,GAASA,EAAMlB,cAAqCgC,IAA1Bd,EAAMlB,QAAQiC,QAC3Cf,EAAMlB,QAAQiC,QAGb,IAVX,oBAaE,SAAOC,EAAUlC,GAA8C,WAG7D,GAFAA,EAAUA,GAAW,GAEjBC,KAAKkC,UAAW,CAClBlC,KAAKmC,OAASnC,KAAKoC,cAAcH,EAAOlC,GACxC,IAFkB,I,25BAAA,CAEDC,KAAKqC,eAFJ,IAGlB,2BAA8B,KACtBC,EADsB,QACLC,WAAWD,SAAStC,KAAKqB,MAC5CiB,IACEvC,EAAQyC,YACVF,EAASG,IAAIR,EAAOlC,GAEpBuC,EAASI,OAAOJ,EAASK,MAAO5C,KATpB,+BAcpB,IAAMkB,EAAQjB,KAAK8B,KAAKb,MACxB,GAAIA,EAAO,CACT,IAMM2B,EAAMX,EANIjC,KAAK6C,aACAC,QAAO,SAACC,EAAGC,GAC9B,IAAMC,EAAOD,EAAET,WAAWD,SAAS,EAAKjB,MAExC,OAAO0B,GADYE,EAAOA,EAAKC,WAAa,KAE3C,GAEHlD,KAAK8B,KAAKvB,OAAO4C,gBAAgBlC,EAAOjB,KAAKoC,cAAcQ,OAvCjE,2BA2CE,SACEX,EACAlC,GAEA,OAAIA,GAAWA,EAAQyC,aAAexC,KAAKkC,UAClC,EAIFkB,OAAOnB,Q,iBApDlB,GAEUoB,EAAAA,I,4jGCWH,IAAMC,EAAb,a,kOAAA,U,QAAA,E,IAAA,G,EAAA,E,+YAkEE,WACS/C,EACPuB,EACA/B,EACAE,EACAsD,EACAC,GACA,MASA,G,4FATA,UACA,qBAAWF,EAAcvD,SAAYA,KAP9BQ,OAAAA,EAMP,yFAXiB,IAAIkD,EAAAA,cAWrB,+BATgC,GAW5BxD,IACF,EAAKA,UAAYA,GAEfsD,GACF,EAAKG,KAAKC,UAAUJ,GAEtB,EAAKzB,KAAOA,EACgB,SAAxB,EAAKA,KAAK8B,UACZ,EAAKC,sBAAwB,EAAKC,OAAO,EAAKhC,KAAKiC,cAC9C,CACL,IAAMC,EAAO,EAAKN,KAAKO,UACnBD,IACF,EAAKH,sBAAwBG,EAAKH,uBAdtC,OAiBA,EAAKK,iBACAV,GACH,EAAKW,MAAMrC,GAnBb,EAzEJ,O,EAAA,E,EAAA,uBAmHE,SAASA,GAA4C,IAgC7CH,EAhC6C,OAC7CyC,EAAItC,EACJ/B,EAAwCC,KAAKqE,eAAevC,GAC5DwC,EAAc,SAACC,GACnBH,EAAEI,OAASD,EACX,EAAKtD,MAAQsD,EACG,EAAKhC,WAAWI,IAAI,eAElC,EAAKJ,WAAWE,IAAI,cAAc,QAGZV,IAApBhC,EAAQiC,SACV,EAAKzB,OAAO4C,gBAAgBoB,EAAGxE,EAAQiC,UAI3C,GAAuB,UAAnBF,EAAK8B,WAA4C,SAAnB9B,EAAK8B,UAAsB,CAC3D,GAAI9B,EAAKiC,UAAYjC,EAAKiC,SAASrD,OAAQ,CACzC,IADyC,MACxBV,KAAKqC,YAAYP,IADO,IAEzC,2BAA0B,KAAfkB,EAAe,QAClBe,EAAW,IAAK/D,KAAKyE,YACzBzE,KAAKO,OACLyC,EACAhD,KAAKD,QACLC,KAAKC,UACLD,MAEFA,KAAK0D,KAAKgB,SAASX,IAVoB,+BAa3C,OAAO7C,QAAQC,UAUf,MAPuB,UAAnBW,EAAK8B,UACPjC,EAAUG,EAAKH,SAAWG,EAAK6C,cAAcC,cACpCtB,EAAcuB,wBAAwB/C,EAAK8B,aAGpDjC,GAAUmD,EADRxB,EAAcuB,wBAAwB/C,EAAK8B,YACxB9B,EAAM/B,EAASC,KAAKO,OAAQP,KAAKC,YAEpD0B,EACK3B,KAAKO,OAAOK,SAASe,EAAS5B,GAASgF,MAAK,SAACC,GAClDV,EAAYU,MAIdlD,EAAK0C,OACAtD,QAAQC,QAAQmD,EAAYxC,EAAK0C,SAEnCtD,QAAQ+D,OAAO,oBApK1B,0BAuKE,cAvKF,iBA2KE,WACMjF,KAAK8B,KAAK8B,YA5KlB,sBAiLE,WACE,OAAO5D,KAAKiB,QAlLhB,4BAqLE,SAAyBa,GACvB,IAAMoD,EAAkC,UAAnBpD,EAAK8B,WAAyB9B,EAAKqD,mBAClDnD,EACoB,iBAAjBkD,GAA6B,IAAMA,GAAgB,SAAMnD,EAC5DhC,EACyC,CAC7Ce,YAAY,EACZsE,QAASpF,KAAKD,QAAQqF,QACtBC,YAAarF,KAAKD,QAAQsF,YAC1BC,aAActF,KAAKD,QAAQuF,aAC3BC,OAAQ,CAAEC,SAAUxF,KAAK8B,KAAKtB,WAAYsB,KAAM9B,KAAK8B,OAEvD,GAAI9B,KAAKD,QAAQ0F,MAAO,CACtB,IAAMC,EACJ1F,KAAKD,QAAQ4F,kBAAoB,wBAAyB7D,EACtD9B,KAAK6D,sBAAwB/B,EAAK8D,oBAClC5F,KAAK6F,GAILC,EAAWC,OAAOL,GAAUM,SAAS,EAAG,KAC9CjG,EAAQ0F,MAAQrC,QAA6B,EAArBpD,KAAKD,QAAQ0F,OAAa,IAAMK,GAK1D,GAHI9F,KAAKD,QAAQkG,eACflG,EAAQkG,aAAejG,KAAKD,QAAQkG,cAEf,UAAnBnE,EAAK8B,UAAuB,CAC9B,MAA6B5D,KAAKkG,cAAcpE,GAAxCqE,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,SAEjBC,EAAAA,EAAAA,GAAatG,EAAS,CACpBuG,gBAAiBxE,EAAKwE,gBACtBpG,IAAK4B,EAAK5B,IACVkF,QAASpF,KAAKD,QAAQqF,QACtBmB,MAAOvG,KAAKD,QAAQwG,MACpBJ,QAAAA,EACAC,QAAAA,EACAI,SAAU1E,EAAK2E,sBACfC,SAAU5E,EAAK6E,wBAMnB,YAHgB5E,IAAZC,IACFjC,EAAQiC,QAAUA,GAEbjC,IAhOX,yBAmOE,SAAsB+B,GACpB,OAAO,EAAIA,EAAKiC,UAAU6C,YApO9B,kCAuOE,SAA6BC,GAC3B,OAAOC,EAAAA,EAAAA,IAAcD,KAxOzB,2BA2OE,SAAsB/E,GACpB,IAAMiF,EAAgB/G,KAAKD,QAAQqG,QAC7BY,EAAgBhH,KAAKD,QAAQoG,QAE7Bc,EAAenF,EAAK2E,sBACtBzG,KAAKkH,qBAAqBpF,EAAK2E,4BAC/B1E,EACEoF,EAAerF,EAAK6E,sBACtB3G,KAAKkH,qBAAqBpF,EAAK6E,4BAC/B5E,EAEEqF,EAAW,CAACL,EAAeE,GAAcI,OAAOC,SAChDC,EAAW,CAACP,EAAeG,GAAcE,OAAOC,SAGtD,MAAO,CAAElB,QAFOgB,EAAS1G,OAAS8G,KAAKC,IAAL,MAAAD,KAAI,EAAQJ,SAAYrF,EAExCoE,QADFoB,EAAS7G,OAAS8G,KAAKE,IAAL,MAAAF,KAAI,EAAQD,SAAYxF,KAzP9D,mBA6PE,SAAcD,GAA6B,WACzC9B,KAAK2H,SAAS7F,GAAMiD,MAAK,WACvB,EAAK6C,QAAQC,KAAK,aA/PxB,oBAmQE,SAAe9D,GAAwD,MAAhB+D,EAAgB,uDAAH,EAAG,IACjD/D,GADiD,IACrE,2BAA8B,KAAnBgE,EAAmB,QACJ,UAApBA,EAAMnE,WACRkE,GAAc,EACdC,EAAMnC,oBAAsBmC,EAAMnC,qBAAuBkC,GAC5B,UAApBC,EAAMnE,YACfkE,EAAa9H,KAAK8D,OAAOiE,EAAMhE,SAAU+D,KANwB,8BASrE,OAAOA,K,EA5QX,sB,EAAA,yBAgGE,WACEvH,EACAuB,EACA/B,EACAE,EACAsD,GALF,6FAOQyE,EAAgB,IAAI1E,EACxB/C,EACAuB,EACA/B,EACAE,EACAsD,GACA,GAbJ,SAeQyE,EAAc7D,MAAMrC,GAf5B,gCAgBSkG,GAhBT,0CAhGF,E,8KAAA,uD,8BAAA,GAAmCC,EAAAA,I,EAAtB3E,EAAAA,0BAQP,I,EAROA,EAAAA,UAUmB,CAC5Bf,WAAY,CACV,CACE2F,KAAM,UACN7G,KAAM,aACN8G,YAHF,SAGcrG,GACV,GAAIA,EAAM,CACR,GAC0B,UAAxBA,EAAKA,KAAK8B,WACc,SAAxB9B,EAAKA,KAAK8B,UAEV,OAAOwE,EAAAA,EAAAA,IACLtG,EAAKA,MACL,SAACsC,GAAD,MAAQ,kBAAmBA,GAAIA,EAAEiE,iBACjC,SAACjE,GAAD,OAAQA,EAAgBL,YAErB,GAA4B,UAAxBjC,EAAKA,KAAK8B,UACnB,OAAO9B,EAAKA,KAAKuG,cAMrB,OAAO,GAETC,MAvBF,SAwBIrG,EACAlC,EACA+B,GAEIA,GAAgC,UAAxBA,EAAKA,KAAK8B,YAChB9B,EAAKb,QACHgB,EACFH,EAAKvB,OAAOgI,UAAUzG,EAAKb,OAE3Ba,EAAKvB,OAAOiI,UAAU1G,EAAKb,QAG/Ba,EAAKA,KAAL,cAA6BG,KAInC,CACEZ,KAAM,UACNoH,QAAS5G,M,q0ECtDV,SAAe6G,EAAtB,kC,iDAAO,qHACLnI,EADK,EACLA,OADK,IAELoI,eAAAA,OAFK,MAEY,GAFZ,EAGLC,EAHK,EAGLA,aACAtH,EAJK,EAILA,cAEMuH,EAND,mDAOuB,IAPvB,eAQyB,IARzB,mBASQ,GATR,8BAUmB,GAVnB,4CAYH,WACE,OAAO7I,KAAKiB,QAbX,yBAgBH,WACEjB,KAAK8I,UAAW,EADJ,UAEI9I,KAAKiB,OAFT,IAEZ,2BAA4B,KAAjBsD,EAAiB,QAC1BhE,EAAOwI,YAAYxE,IAHT,iCAhBX,uBAuBH,WACE,OAAOvE,KAAK8I,WAxBX,qDA2BH,0GACE9I,KAAKD,QAAQe,YAAa,GACtBd,KAAKiB,MAAMP,OAFjB,qBAGoBV,KAAKiB,OAHzB,gEAGe+B,EAHf,iBAIYzC,EAAOgI,UAAUvF,GAJ7B,uLAOUhD,KAAKgJ,YAPf,gEA3BG,kGAsCH,0GACEhJ,KAAKD,QAAQe,YAAa,GACtBd,KAAKiB,MAFX,qBAGoBjB,KAAKiB,OAHzB,gEAGe+B,EAHf,iBAIYzC,EAAOiI,UAAUxF,GAJ7B,sMAtCG,kGA+CH,0GACOhD,KAAKiB,MAAMP,QAAWV,KAAKiJ,oBADlC,wBAEIjJ,KAAKiJ,qBAAsB,EAF/B,SAG0B3H,EAActB,MAHxC,YAGUkJ,EAHV,gCAKYvH,EAAU,IAAIuH,EAAQ3I,EAAO4I,WAAWC,IAA9B,KACXT,IANX,SAQgDhH,EAAQf,SAAS,CACzD6E,MAAOzF,KAAKD,QAAQ0F,MACpBL,QAASpF,KAAKD,QAAQqF,QACtBiE,UAAWrJ,KAAKD,QAAQsJ,YAXhC,UAQYC,EARZ,OAaUV,GACFA,EAAajH,GAEf4H,OAAOC,OAAO7H,EAAQ5B,QAAS4I,GAC/BhH,EAAQV,MAAQqI,EACZtJ,KAAK8I,UACPvI,EAAOwI,YAAYpH,GAErB3B,KAAKiB,MAAMwI,KAAK9H,IACZ3B,KAAKD,QAAQe,WAtBvB,kCAuBcP,EAAOgI,UAAU5G,GAvB/B,QAyBM3B,KAAKiJ,qBAAsB,EAzBjC,iCA4BSjJ,KAAKiB,OA5Bd,iDA/CG,sEA8EE4H,GA9EF,2C,qYCLA,yHACLtI,EADK,EACLA,OACAN,EAFK,EAELA,UACA6B,EAHK,EAGLA,KAHK,IAIL6G,eAAAA,OAJK,MAIY,GAJZ,MAKLe,SAAAA,OALK,MAKM,qBALN,EAyBCC,EAAwBjB,EAAyB,CACrDnI,OAAAA,EACAoI,eAAAA,EACAC,aARmB,SAACjH,GACpBA,EAAQ5B,QAAQsJ,WAAY,EAC5B1H,EAAQkE,GAAK6D,EAAW,IAAM5H,EAAK8H,aAOnCtI,cAtBoB,WACpB,OAAOuI,EAAAA,EAAAA,GACL,CACErE,SAAU1D,EAAK8H,YACfjB,eAAgB,CACdtH,KAAMS,EAAKgI,aACX9H,QAASF,EAAKE,UAGlBzB,EACAN,MAjBC,kBAgCE0J,GAhCF,4C,oXCCA,IAAMI,GAAb,WAOE,WAAoBhK,I,4FAA8B,cAA9BA,QAAAA,EAA8B,qGAChDC,KAAKQ,WAAaT,EAAQS,WAC1B,IAAMsB,EAAO/B,EAAQ+B,KACrB9B,KAAK8B,KAAOA,EACR/B,EAAQiK,YAAclI,EAAKmI,OAC7BjK,KAAKqB,KAAOS,EAAKmI,OAAOlK,EAAQiK,YAEhChK,KAAKqB,KAAO0E,OAAOjE,EAAK+D,I,QAd9B,O,EAAA,G,EAAA,qBAkBE,WAA+C,WAC7C,OAAI7F,KAAKkK,QACAC,EAAAA,EAAAA,QAA0BnK,KAAKkK,SAEjClK,KAAKD,QAAQE,UACjB0C,IAAI,oCAAqC,KAAM,CAC9CkD,GAAI7F,KAAKQ,WACT4J,IAAKpK,KAAK8B,KAAK+D,KAEhBd,MAAK,SAACsF,GACL,MAA2CA,EAAKC,OAAxCC,EAAR,EAAQA,OAAQC,EAAhB,EAAgBA,OAAQC,EAAxB,EAAwBA,OAClBC,EAAS,CAACF,EAAQD,EADxB,EAAgCI,OACQF,GAExC,OADA,EAAKP,QAAUQ,EACRA,OA/Bf,qBAmCE,WAAkD,WAChD,OAAI1K,KAAK8B,KAAK8I,KACLT,EAAAA,EAAAA,SAA0BU,EAAAA,EAAAA,IAAqB7K,KAAK8B,QAEpDgJ,EAAAA,EAAAA,GAAkB,CACvBtK,WAAYR,KAAKQ,WACjBuK,UAAW/K,KAAK8B,KAAK+D,GACrB5F,UAAWD,KAAKD,QAAQE,UACxB2K,MAAM,EACNX,OAAQ,KACRe,WAAY,OACXjG,MAAK,SAACkG,GACP,IAAML,EAAOK,EAAaL,KAE1B,OADA,EAAK9I,KAAK8I,KAAOA,GACVC,EAAAA,EAAAA,IAAqB,EAAK/I,c,kBAjDzC,K,+qECmBO,IAAMjB,GAAb,WAqBE,WAAmBuI,EAAerJ,I,4FAAkC,cAAjDqJ,IAAAA,EAAiD,KAAlCrJ,QAAAA,EAAkC,gDAlB/BuD,GAkB+B,sBAdtD,IAcsD,uDAZlD,UAYkD,kBARhE,IAAIG,EAAAA,cAQ4D,uHAH3B,IAG2B,uCAClE,IAAM9C,EAAIZ,EAAQS,WASlB,GAPI0K,MAAMC,QAAQxK,IAChBX,KAAKQ,WAAaG,EAAE,GACpBX,KAAKD,QAAQ8F,GAAKlF,EAAE,IAEpBX,KAAKQ,WAAaG,GAGfX,KAAKQ,WACR,MAAM,IAAIJ,MAAM,mC,QAhCtB,uB,EAAA,E,EAAA,sDAoCE,WAAeL,GAAf,iGACEC,KAAKD,QAAL,SAAoBC,KAAKD,SAAYA,GADvC,SAEqBC,KAAKoL,sBAF1B,cAEEpL,KAAKiB,MAFP,OAGQoK,EAHR,UAG4BrL,KAAKsL,gBAHjC,iBAG4B,EAAe/J,cAH3C,aAG4B,EAAuBgK,mBAE/CvL,KAAKD,QAAQyL,sBACbxL,KAAKkK,SACLmB,GAEArL,KAAKD,QAAQQ,OAAOkL,QAAQ,CAAEC,UAAW1L,KAAKkK,UATlD,kBAWSlK,KAAKiB,OAXd,gDApCF,uEAkDE,WACE,IAAMkI,EAAanJ,KAAKD,QAAQQ,OAAO4I,WAQvC,GANAnJ,KAAK2L,kBAAkBC,SAAQ,SAAC5I,GACxB,UAAWA,GAEjBmG,EAAWJ,YAAY/F,EAAE/B,MAAMA,UAG7BjB,KAAK6L,qBAAqBnL,OAAQ,YACpBV,KAAK6L,sBADe,IACpC,2BAA2C,KAAhCC,EAAgC,QACzC9L,KAAKD,QAAQQ,OAAOwI,YAAY+C,IAFE,8BAIhC9L,KAAK+L,sBACP/L,KAAKD,QAAQQ,OAAOgI,UAAUvI,KAAK+L,sBAInC/L,KAAKD,QAAQyL,sBAAwBxL,KAAKkK,SAC5ClK,KAAKD,QAAQQ,OAAOkL,QAAQ,CAAEC,UAAW,cAGpC1L,KAAKiB,aACLjB,KAAKsL,gBACLtL,KAAKgM,mBA1EhB,sDA6EE,iGACMhM,KAAKiB,QAASjB,KAAKiB,MAAMsB,WAD/B,yCAEWvC,KAAKiB,MAAMsB,WAAWD,SAAS,cAAcG,KAAI,IAF5D,gDA7EF,mGAmFE,iGACMzC,KAAKiB,QAASjB,KAAKiB,MAAMsB,WAD/B,yCAEWvC,KAAKiB,MAAMsB,WAAWD,SAAS,cAAcG,KAAI,IAF5D,gDAnFF,oGAyFE,WAAiBG,GAAjB,oFACM5C,KAAKiB,QAASjB,KAAKiB,MAAMsB,WAD/B,yCAEWvC,KAAKiB,MAAMsB,WAAWD,SAAS,WAAWG,IAAIG,IAFzD,gDAzFF,qEAgGE,WACE,OAAO5C,KAAKiM,cAjGhB,uBAoGE,WACE,IAAM1K,EAASvB,KAAKsL,UAAYtL,KAAKsL,SAAS/J,OAC9C,GAAIA,EACF,OAAO2K,EAAAA,EAAAA,IAAmB3K,KAvGhC,6BA2GE,WACE,OAAQvB,KAAKiB,OAASjB,KAAKiB,MAAMyC,KAAKyI,kBAAqB,KA5G/D,oCA+GE,WACE,IAAM5K,EAASvB,KAAKsL,UAAYtL,KAAKsL,SAAS/J,OAC9C,GAAIA,EACF,OAAOA,EAAO6K,kBAAkBvG,KAlHtC,4BAsHE,WACE,IAAMwG,EAAgBrM,KAAKsM,yBACrBrM,EAAYD,KAAKD,QAAQE,UAC/B,GAAIoM,EACF,OAAOpM,EAAUsM,kBAAkBF,GAAetH,MAAK,SAACjD,GAAS,MACzDkI,EAAU,UAAGlI,EAAK0K,qBAAR,aAAG,EAAoBvC,OAAOwC,MAC5C,SAACzJ,GAAD,OAAOA,EAAE0J,eAELC,EAAU3C,GAAcA,EAAW2C,QACzC,OAAOC,EAAAA,EAAAA,GAAmB,CACxB3M,UAAAA,EACAO,WAAY6L,EACZzB,MAAM,EACNX,OAAQ0C,EAAU,CAACA,QAAW5K,IAC7BgD,MAAK,SAAC8H,GACP,IADiB,EACXC,EAA4B,GADjB,KAEDD,GAFC,IAEjB,2BAAuB,KAAZzI,EAAY,QACf2I,EAAW,IAAIhD,GAAa,CAChCjI,KAAMsC,EACN5D,WAAY6L,EACZrC,WAAY2C,EACZ1M,UAAAA,IAEF6M,EAAUrD,KAAKsD,IATA,8BAWjB,OAAOD,QAIb,MAAM,IAAI1M,MACR,4EApJN,iEAwJE,wGACQ4M,EAA0B,GAC5BC,EAAMjN,KAAKgM,iBAFjB,gCAIgBhM,KAAKkN,gBAJrB,OAIID,EAJJ,OAKIjN,KAAKgM,iBAAmBiB,EAL5B,cAOMA,GAAOA,EAAIvM,QACFV,KAAK2L,kBACJwB,MAAK,SAACC,EAAGtB,GAAJ,OAAUA,EAAEjG,GAAKuH,EAAEvH,MAC/B+F,SAAQ,SAAC5I,GACZ,IAAMlB,EAAOkB,EAAElB,KACTuL,EAAWvL,EAAKuL,SACtB,QAAiBtL,IAAbsL,GAA6C,UAAnBvL,EAAK8B,UAAuB,CACxD,IAAM0J,EAAUtK,EAAET,WAAWD,SAAS,cACpBgL,EAAQ3K,QAAU2K,EAAQC,aAE1CP,EAAcvD,KAAK4D,OAjB7B,kBAsBSL,GAtBT,gDAxJF,6GAiLE,8GACMhN,KAAKQ,WADX,gCAEyBR,KAAKwN,gBAAgBxN,KAAKQ,YAFnD,YAEUe,EAFV,UAGkBA,EAAOkM,UAHzB,yCAIa,IAAIvM,SAAuB,SAACC,GACjC,IAAMpB,EAAuB,GAC7B,GAAI,EAAKA,QAAQE,WAAa,EAAKF,QAAQE,UAAUF,QAAQO,KAAM,CACjE,IAAM8E,EAAU,EAAKrF,QAAQE,UAAUyN,0BACnCtI,IACFrF,EAAQqF,QAAUA,GAGtBrF,EAAQuF,aAAe,EAAKvF,QAAQuF,aACpCvF,EAAQ0F,MAAQ,EAAK1F,QAAQ0F,MAC7B1F,EAAQwG,MAAQ,EAAKxG,QAAQwG,MAC7BxG,EAAQsF,YAAc,EAAKtF,QAAQsF,YACnCtF,EAAQqG,QAAU,EAAKrG,QAAQqG,QAC/BrG,EAAQoG,QAAU,EAAKpG,QAAQoG,QAC/BpG,EAAQ4F,iBAAmBpE,EAAOoM,mBAClC5N,EAAQkG,aAAe,EAAKlG,QAAQkG,aACpC,IAAMhF,EAAQ,IAAI,EAAKqC,cACrB,EAAKvD,QAAQQ,OACbgB,EAAOkM,UACP1N,EACA,EAAKA,QAAQE,WAEfgB,EAAM2G,QAAQgG,GAAG,QAAQ,kBAAMzM,EAAQF,UA1B/C,gDAjLF,yGAiNE,WAA8B4E,GAA9B,wGACqB7F,KAAKD,QAAQE,UAAU4N,YAAYhI,GADxD,YACQiI,EADR,4BAGI9N,KAAKsL,SAAWwC,EACVvM,EAASuM,EACb9N,KAAK+N,iBAEP/N,KAAKgO,iBAAiBF,IAClBvM,EARR,wBASMvB,KAAKkK,QAAU,CACb3I,EAAO0M,YACP1M,EAAO2M,cACP3M,EAAO4M,aACP5M,EAAO6M,YAETpO,KAAKqO,mBAAmB9M,EAAOkM,UAAWzN,KAAKD,QAAQQ,OAAQuN,GAfrE,kBAgBavM,GAhBb,iDAjNF,4EAwOE,SAAyBuM,GAAoB,MACrCvN,EAASP,KAAKD,QAAQQ,OAE5B,GADa,UAAGP,KAAKD,QAAQuO,kBAAhB,SAEX,GAAIR,EAAKS,gBAAkBT,EAAKS,eAAeC,SAAS9N,OAAQ,CAC9D,IAAM+N,EAAkBlO,EAAOmO,qBAC/B1O,KAAK+L,qBAAuB0C,EACxBA,EAAgB5I,QAChB9D,EACJ/B,KAAK2O,aAAab,EAAKS,qBACdvO,KAAKD,QAAQ6O,gBACtBrO,EAAOsO,aAAa,MAAO,CACzBhJ,GAAI,2BACJxE,KAAM,oBArPhB,0BA2PE,SAAqByN,GAA2B,aACxCvO,EAASP,KAAKD,QAAQQ,OAExBwO,GAAoB,EAHsB,KAI9BD,EAAWN,UAJmB,yBAInCxL,EAJmC,SF/Q3C,SAAP,mCEoRMgM,CAA4B,CAC1BzO,OAAAA,EACAN,UAAW,EAAKF,QAAQE,UACxB6B,KAAMkB,EACN2F,eAAgB,CAAEtD,YAAa,EAAKtF,QAAQsF,eAC3CN,MAAK,SAACpD,GACP,IAAMb,GAAaiO,GAA4B/L,EAAEiM,QAIjD,OAHIjM,EAAEiM,UACJF,GAAoB,GAEfxO,EACJsO,aAAalN,EAAS,CACrBkE,GC9S8B,mBD8SG7C,EAAE4G,YACnCvI,KAAM2B,EAAE8G,aACR9H,QAASgB,EAAEhB,QACXlB,WAAAA,IAEDiE,MAAK,SAACR,GACLA,EAAEsB,IAAM,EAAKgG,qBAAqBpC,KAAKlF,EAAEsB,WAnBjD,2BAAqC,IAJS,iCA3PlD,gCAwRE,SACE/D,EACAvB,EACAuN,GACA,WACA,GAAIhM,EACF,GAAuB,UAAnBA,EAAK8B,WAA4C,SAAnB9B,EAAK8B,UACjC9B,EAAKiC,WACPjC,EAAKiC,SAAWjC,EAAKiC,SAASqF,KAAI,SAACpG,GAAD,OAChC,EAAKqL,mBAAmBrL,EAAGzC,EAAQuN,OAGhB,SAAnBhM,EAAK8B,YACP9B,EAAKgI,aAAegE,EAAKtI,SAASsE,mBAE/B,GAAuB,UAAnBhI,EAAK8B,UAAuB,CACrC,IAAM1D,GAAMgP,EAAAA,EAAAA,GACVlP,KAAKD,QAAQE,UAAUF,QAAQI,QAC7B,+BAEEK,EAAasB,EAAKqN,eACxBrN,EAAK5B,IAAMA,EACX4B,EAAKtB,WAAaA,EAClBsB,EAAKwE,gBAAkB,SAACf,GAAD,OACrB6J,EAAAA,EAAAA,IAAkB7J,EAAQ/E,IAC5B,IAAMmB,EAAUG,EAAK6C,cAAcC,cAC7ByK,GAAsBC,EAAAA,EAAAA,IAAuB,CACjDvP,QAAS,CACP4B,QAAAA,EACA6D,SAAUhF,GAEZD,OAAAA,EACAJ,QAASH,KAAKD,QAAQE,UAAUF,QAAQI,SAAW,KAErD2B,EAAO,SACFA,GACAuN,GAIT,OAAOvN,IAhUX,0DAmUE,2HACQyN,EAAavP,KAAKiB,QACwB,SAA9BsO,EAAWzN,KAAK8B,UAFpC,iBAGU4L,EAASD,EAAW7L,KAAKyI,iBACzBsD,EAA0C,GAJpD,KAKoBD,GALpB,IAKI,IALJ,iBAMY1N,EANZ,QAMqBA,KACf,GAAuB,UAAnBA,EAAK8B,UAAuB,CAC9B,IAAMiC,EAAK/D,EAAKqN,eACVO,EAAU,EAAK3P,QAAQE,UAAU4N,YAAYhI,GAAId,MAAK,SAAC4K,GAC3D,GAAIA,EAAG,CACL,IAAMtC,EAAWjK,OAAOuM,EAAEnK,SAASjC,OAAOsC,IAE1C,OADA/D,EAAKuL,SAAWA,EACTA,MAGXoC,EAAShG,KAAKiG,KAXlB,uBAAwB,IAL5B,8CAmBsBxO,QAAQ0O,IAAIH,GAnBlC,cAmBUxC,EAnBV,yBAoBWA,EAAI5F,QAAO,SAACrE,GAAD,YAAajB,IAANiB,MApB7B,iDAnUF,8C,qBAAA,M,ixBE5BO,IAAM6M,EAAb,yB,4FAAA,mF,QAAA,W,EAAA,E,EAAA,sDAOE,sHACS7P,KAAKiM,aADd,gDAPF,kGAWE,WACElM,GADF,oFAGMC,KAAKkK,QAHX,yCAIWlK,KAAKkK,SAJhB,WAMMlK,KAAK8B,KANX,iCAOyBgO,EAAAA,EAAAA,IACnB9P,KAAK8B,KACL9B,KAAKC,UACLF,GAVN,cAOIC,KAAKkK,QAPT,yBAYWlK,KAAKkK,SAZhB,gDAXF,+C,oBAAA,K,+ICHO,SAAS6F,EACdC,EACAlO,GAIE,IAAMmO,EAAUC,SAASC,cAAc,OACvC,GAAIrO,GAAQA,EAAK0K,cACf1K,EAAK0K,cAAcvC,OAAO2B,SAAQ,SAAC5I,GACjC,GAAIA,EAAEoN,gBAAiB,CACrB,IAAMnO,EAAQ+N,EAAQzN,YAAcyN,EAAQzN,WAAWS,EAAE2J,SACzD,GAAI1K,EAAO,CACT,IAAMoO,EAAWH,SAASC,cAAc,OACxCF,EAAQK,YAAYD,GACpBA,EAASE,UAAT,gBAA8BvN,EAAE8G,aAAhC,oBAAwD7H,EAAxD,2BAID,GAAI+N,EAAQzN,WACjB,IAAK,IAAMiO,KAAKR,EAAQzN,WAAY,CAClC,IAAM8N,EAAWH,SAASC,cAAc,OACxCF,EAAQK,YAAYD,GACpBA,EAASE,UAAT,gBAA8BC,EAA9B,oBAA2CR,EAAQzN,WAAWiO,GAA9D,iBAGJ,OAAOP,EC1BX,IAAMQ,EAA6C,CACjD,SACA,aACA,QACA,UACA,YAGK,SAASC,EACd3Q,GAEA,IAAM4Q,EAAqC,GAO3C,OANAF,EAAkB7E,SAAQ,SAAC5I,GACzB,IAAM4N,EAAM7Q,EAAQiD,QACRjB,IAAR6O,IACFD,EAAc3N,GAAK4N,MAGhBD,E,4TCjBF,SAAeE,EAAtB,oC,iDAAO,WACL9Q,EACAE,GAFK,iGAICuF,EAAWzF,EAAQyF,SACnB1D,EAAO0D,EAGPmH,EAAwB5M,EAAxB4M,QAASnM,EAAeT,EAAfS,YAEXgF,EAVC,oBAWqB,iBAAbA,EAXR,gBAYDmH,EAAUnH,EAZT,0BAa4B,iBAAbA,EAbf,iBAcDhF,EAAagF,EAdZ,4BAgBD1D,EAAK0D,eACazD,IAAlBD,EAAK0D,YACL,aAAc1D,GAlBb,iBAoBDtB,EAAcgF,EAA0BA,SAASK,GApBhD,yCAuBkBgL,EAA2BrL,EAAiBvF,GAvB9D,QAuBDO,EAvBC,kBA0BAA,IAAcmM,EA1Bd,kCA2BwB1M,EAAU4N,YAAYlB,GA3B9C,SA2BGmE,EA3BH,UA6BDtQ,EAAasQ,EAAatL,SAASK,IA7BlC,iCAgCErF,GAhCF,6C,6CCCA,SAASuQ,EAAT,GAIkD,IAHvD9Q,EAGuD,EAHvDA,UACAO,EAEuD,EAFvDA,WAEuD,IADvDwQ,MAAAA,OACuD,SACvD,OAAO/Q,EACJ0C,IACC,8BACA,CAAEqO,MAAAA,GACF,CACEnL,GAAIrF,IAGPuE,MAAK,SAACsF,GACL,OAAOA,EAAK4G,e,6rICgBX,SAAeC,EAAtB,kC,iDAAO,WACLC,GADK,mIAIHrP,EAMEqP,EANFrP,KACAvB,EAKE4Q,EALF5Q,OACA2I,EAIEiI,EAJFjI,QACAjJ,EAGEkR,EAHFlR,UACAmR,EAEED,EAFFC,aACyBC,EACvBF,EADFG,wBAEIA,EAA0BD,MAAAA,GAAAA,EAC1BtR,EAAUqR,EACVG,EACJrI,GAAW3I,EAAO4I,WAAWqI,cAAcC,QAEvCC,EAAuB,GACzBC,GAAgB,EAjBf,SAqBoBd,EAA2B9Q,EAASE,GArBxD,cAqBCO,EArBD,OAuBL,UAAIT,EAAQ4I,sBAAZ,iBAAI,EAAwB1C,oBAA5B,OAAI,EAAsC2L,iBACxC7R,EAAQ4I,eAAe1C,aAAa8J,mBAAqB,YAAiB,IAAdC,EAAc,EAAdA,QAC1D,OAAOA,GAAWD,EAAmBC,EAASlO,KAI5C+P,EA7BD,4CA6BW,WACdC,EACAC,GAFc,uFAIdC,IACAC,EAAkB,CAAEH,QAAAA,EAAS/R,QAASgS,GACtCG,GAAeC,EAAAA,EAAAA,GAA+B,EAAD,CAC3C3R,WAAAA,EACAsR,QAAAA,EACA7R,UAAAA,EACA+Q,OAAO,GACJe,IAXS,SAaDG,EAbC,mFA7BX,wDA4CDE,GAAU,EACRJ,EAAQ,WACRE,IACFA,EAAaG,SACbH,OAAenQ,IAIbuQ,EApDD,oMAqDO,IAAI7O,EAAAA,cArDX,oNA2DH,WAAemN,GAAf,iGACM2B,GAAc3B,EAAI9C,KAChB0E,OACiBzQ,IAArB6O,EAAI4B,cAA6B5B,EAAI4B,kBACpBzQ,IAAfhC,EAAQ8F,KACV+K,EAAI/K,GAAK9F,EAAQ8F,IAEf/D,GAAQA,EAAK2Q,eACf7B,EAAI1I,KACFwK,EAAAA,GAAgC5Q,EAAK2Q,aAAaE,gBAElD5S,EAAQ4I,iBAKRiI,EADEU,EACI,EAAH,KACEvR,EAAQ4I,gBACRiI,GAGC,EAAH,KACEA,GACA7Q,EAAQ4I,iBAIbiI,EAAI9C,MAAyC,IAAjCvE,OAAOqJ,KAAKhC,EAAI9C,MAAMpN,SACpCkQ,EAAI9C,UAAO/L,EACXwQ,GAAa,GAETM,EAAWjC,EAAIiC,eAAY9Q,EACjC/B,KAAKD,QAAQ8S,SAAWA,EAElB5R,EAlCR,4CAkC+B2P,GAC7BqB,EAAkB,CAChBH,QAASlB,EAAIkC,iBACb/S,QAAS2Q,EAAsBE,IAG7B2B,IACFQ,EAAgB/S,KAAKgT,gBAEnBR,IAAgBO,EA3CtB,kCA4CUA,EA5CV,eA8CMF,GAAYA,EAASI,WAAW,UAAYtB,GAC9C3R,KAAKkT,wBA/CT,kBAiDSjS,GAjDT,iDA3DG,qEAgHH,WACE,OAAOjB,KAAKiM,cAjHX,qDAoHH,wGACQkH,EAAUnT,KAAKoT,WAAapT,KAAKoT,YAAY1S,SAE/CmS,OADEA,EAAW7S,KAAKD,QAAQ8S,WAC1BA,EAAUI,WAAW,SAAWE,GAHtC,0CAIWE,EAAAA,EAAAA,IAAe,CAAEpT,UAAAA,EAAWO,WAAYsB,EAAK0D,SAASK,MAJjE,sLApHG,uEAgIH,WACEuM,GAAU,EACVpS,KAAKsT,2BACLtT,KAAKuT,2BACLvT,KAAKwT,8BAA2BzR,EAChC/B,KAAKyT,6BAA0B1R,EAC/B/B,KAAK0T,iBAAc3R,EACnB/B,KAAK2T,sBAAmB5R,EACxBiQ,MAxIC,sBA2IH,WACE,OAAOjB,EAAmB,CAAE9Q,UAAAA,EAAWO,WAAAA,EAAYwQ,OAAO,MA5IzD,uDA+IH,WAAkB4C,GAAlB,6GACEA,EAAaA,GAAc3B,GAAmB,GADhD,UAEMjS,KAAKD,QAAQ8S,gBAFnB,QAEM,EAAuBI,WAAW,QAFxC,iCAGU1S,EAAOsT,OAAO,UAHxB,UAIID,EAAW7T,QAAU6T,EAAW7T,SAAW,GAC3C6T,EAAW7T,QAAQ+T,WAAavT,EAAO0L,YAL3C,EAMiCjM,KAAKD,QAA1BqG,EANZ,EAMYA,QAASD,EANrB,EAMqBA,aAEJpE,KADPgS,EAAOxT,EAAOyT,WAPxB,2BASsBjS,IAAZqE,GAAyB2N,EAAO3N,GAT1C,6DAYsBrE,IAAZoE,GAAyB4N,EAAO5N,GAZ1C,uDAeUwL,EAfV,uDAoBMS,EApBN,oEAwBIpS,KAAK4H,QAAQC,KAAK,YAAa+L,GAC/BrT,EAAO0T,gBAAgB,kBAAmBlU,EAAQ8F,IAAM,GAAI+N,GAzBhE,UA2BuB/B,EAAQ+B,EAAW9B,QAAZ,OACrB8B,EAAW7T,SADU,IAExBmU,IAAKlU,KAAKD,QAAQmU,OA7BxB,eA2BUpG,EA3BV,OA+BQqG,EAA6BrG,EA/BrC,UAgCwB9N,KAAKoU,WAhC7B,WAgCUC,EAhCV,OAkCkC,UAA1BrU,KAAKD,QAAQ8S,SAlCrB,iBAmCMsB,EAAU,CACRjM,KAAM,oBACNoM,SAAU,IArClB,IAuCsBxG,EAAKwG,UAvC3B,IAuCM,2BAAWC,EAAoB,SACa,IAAtC7C,EAAW8C,QAAQzO,OAAOwO,EAAE1O,OAC9B6L,EAAWjI,KAAK1D,OAAOwO,EAAE1O,KACzBsO,EAAQG,SAAS7K,KAAK8K,IA1ChC,qCA6CM5C,OAA0B5P,IAAVsS,GAAuB3C,EAAWhR,QAAU2T,EA7ClE,UA8CY9T,EAAOkU,aAAazU,KAAMmU,GA9CtC,uCAgDMxC,OAA0B5P,IAAVsS,GAAuBvG,EAAKwG,SAAS5T,QAAU2T,EAhDrE,UAiDY9T,EAAOmU,aAAa1U,KAAM8N,GAjDtC,QAmDI9N,KAAK4H,QAAQC,KAAK,UAAWiG,GAC7BvN,EAAO0T,gBAAgB,gBAAiBlU,EAAQ8F,IAAM,GAAI,CACxDiI,KAAAA,EACAqG,QAAAA,EACAQ,OAAQhD,IAvDd,wDA0DQ,gBAAcvR,OAAqB,gBAAZ,KAAGiB,MA1DlC,oCA8DE,sCACE,gDA/DJ,2DA/IG,0GAkNH,WAAuByQ,EAA2BlB,GAAlD,yFACEoB,KACIhS,KAAKqH,SAAUsK,EAFrB,gBAGI3R,KAAKqH,QAAO,SAACuN,GACX,IAAMC,EACJD,EAAE5E,SACF4E,EAAE5E,QAAQzN,aACVuS,EAAAA,EAAAA,GAAmC,EAAD,GAAMF,EAAE5E,QAAQzN,aACpD,OAAIsS,IACK/B,EAAAA,EAAAA,IAAiB+B,EAAQ/C,MATxC,2BAaa9R,KAAK+U,QAblB,wBAcQ/U,KAAKgV,YACPhV,KAAKgV,aAfX,SAiBuBnD,EAAQC,EAAD,OACrBlB,GADqB,IAExBsD,IAAKlU,KAAKD,QAAQmU,OAnBxB,OAiBUpG,EAjBV,OAqBI9N,KAAK+U,QAAQjH,GArBjB,iDAlNG,0EA2OH,WACEmE,OAAkBlQ,EAClB/B,KAAK8S,iBAAiB,IAClB9S,KAAKqH,QACPrH,KAAKqH,QAAO,WACV,OAAO,OAhPV,mCAqPH,WAAgC,WAC9BrH,KAAKyT,wBAA0B,SAACmB,GAC1BA,IAAM,IACR,EAAKtB,2BACL,EAAKN,cACL,EAAKiC,0BAGTjV,KAAKwT,yBAA2B,SAACoB,GAC3BA,IAAM,GACR,EAAKtB,4BAGT/S,EAAOqH,QAAQgG,GAAG,aAAc5N,KAAKyT,yBACrClT,EAAOqH,QAAQgG,GAAG,aAAc5N,KAAKwT,0BACrCxT,KAAKyT,wBAAwBzT,QApQ5B,sCAuQH,WACMA,KAAKyT,yBACPlT,EAAOqH,QAAQgG,GAAG,aAAc5N,KAAKyT,yBAEnCzT,KAAKwT,0BACPjT,EAAOqH,QAAQgG,GAAG,aAAc5N,KAAKwT,4BA5QtC,mCAgRH,WAAgC,WAC9BxT,KAAK0T,aAAcwB,EAAAA,EAAAA,IAAS,kBAAM,EAAKlC,iBACvChT,KAAK2T,iBAAmB3B,EACxBzR,EAAOqH,QAAQgG,GAAG,YAAa5N,KAAK2T,kBACpCpT,EAAOqH,QAAQgG,GAAG,UAAW5N,KAAK0T,eApRjC,sCAuRH,WACM1T,KAAK0T,aACPnT,EAAOqH,QAAQuN,eAAe,UAAWnV,KAAK0T,aAE5C1T,KAAK2T,kBACPpT,EAAOqH,QAAQuN,eAAe,YAAanV,KAAK2T,sBA5RjD,GAoD2BpC,GApD3B,kBAiSEe,GAjSF,4C,iiGCpBA,SAAe8C,GAAtB,mC,oDAAO,yHACLhE,EADK,EACLA,aACA7Q,EAFK,EAELA,OACAN,EAHK,EAGLA,UACA6B,EAJK,EAILA,KAEMuT,EAAcvT,EAAK0D,SAAS9D,IAC5B4T,EAAkE,CACtEC,kBAAmB,MACnBC,gBAAiB,cAMHzT,KAJZJ,EACFyP,EAAazP,SACZ0T,GAAeC,EAAgBD,IAChC,WAEAjE,EAAazP,QAAUA,GAET,UAAZA,MACI6P,EAAgBjR,EAAOkV,qBACUjE,EAAckE,QAEnD/T,EAAU,WAIRgU,EAAepV,EAAO4I,WAAWqI,cACrC7P,IA3BG,kCA8BsBkP,EACvBO,EACAnR,GAhCC,eA8BGO,EA9BH,0DAuCD,WAAmB4I,EAAUwM,GAAe,iBAC1C,cAAMxM,EAAKwM,IADMxM,IAAAA,EAAyB,gBAHtBtH,GAGsB,sBAF/BtB,GAIX,IAAMoQ,GAAMtB,EAAAA,EAAAA,IAAuB,CACjCvP,QAASqR,EACT7Q,OAAAA,EACAJ,QAASF,EAAUF,QAAQI,SAAW,KAExC,GAAIyQ,EAAK,CACP,IAAMvB,EAA2C,SAC5CuB,GACAQ,EAAazI,gBAF4B,IAG5CpD,OAAQ,CAAEC,SAAUhF,GACpBgP,OAAQoB,EAAIpB,QAAUzJ,OAAOvF,GAC7BA,WAAYA,IAGZ4Q,EAAazI,iBACbkN,EAAAA,EAAAA,GAAQzE,EAAazI,eAAerD,gBAEpC+J,EAAoB/J,aAClB8L,EAAazI,eAAerD,cAEhC,EAAKvF,QAAL,OAAoB,EAAKA,SAAYsP,GAtBG,SAvC3C,kCAgED,SAASyG,GACP,2DAA2B9V,KAAKD,SAAY+V,MAjE7C,iEAoED,uGACM9V,KAAK8B,KADX,mBAEoB,QAAZH,EAFR,yCAGa,CAAC3B,KAAK8B,KAAK0D,SAASK,KAHjC,UAKUA,EAAK7F,KAAK8B,KAAK0D,SAASjC,OAAOsC,KACjCgQ,EAAAA,EAAAA,GAAQhQ,GANhB,yCAOa,CAACA,IAPd,gCAUS,IAVT,gDApEC,kDAkCgC8P,IAlChC,cAqFG,IAAIvV,MAAMuB,EAAU,iCArFvB,4C,i1DCRA,SAAeoU,GAAtB,mC,oDAAO,iHACShW,EADT,EACLqR,aACA7Q,EAFK,EAELA,OACAN,EAHK,EAGLA,UAHK,SAKoB4Q,EAA2B9Q,EAASE,GALxD,cAKCO,EALD,yDAOH,WAAY4I,GAAU,8BACdA,EAAK,CACTlJ,IAAK,GACLK,OAAAA,EACAC,WAAAA,EACAP,UAAAA,IAZD,UAMsC+V,GAAAA,IANtC,2C,6hGCAA,SAAeC,GAAtB,mC,oDAAO,qHACL1V,EADK,EACLA,SACAuB,EAFK,EAELA,MAESoU,cAJJ,oBAKGC,EAAMrU,EAAKoU,cAAcC,IACzBjW,EAAM4B,EAAKoU,cAAchW,KAC3BiW,EAPD,wBAQKC,EAAOC,KAAKC,MAAMH,GAClBxU,EAAUT,QAAQC,QACtBoV,GAAAA,GAAAA,MAAAA,iBAA8BhW,OAAQwB,EAAW,CAC/CoU,IAAKC,EACL/M,WAAW,KAZd,kBAeM1H,GAfN,YAgBQzB,EAhBR,sBAiBKsW,EAAcjW,EAAO4I,WAAWqI,cAAciF,MAjBnD,wBAqBOC,EArBP,2JAsBG,WAAe9F,GAAf,gKAC6BA,GAD7B,IACkC1Q,IAAAA,MADlC,gDAtBH,mDAqBkCsW,GArBlC,kBA0BQE,GA1BR,4C,shCCmBA,IAAM9U,GAAiD,GAExD+U,GAA4B,CAChC,kBACA,oBACA,oBACA,oBACA,eACA,gBACA,eACA,eACA,gBACA,SAEA,mB,SAGaC,GAA4B,G,oFAA3C,uHACExF,EADF,EACEA,aACA7Q,EAFF,EAEEA,OACAN,EAHF,EAGEA,UACA6B,EAJF,EAIEA,KAEMyB,EAASzB,EAAK0D,SAASK,GAN/B,SAO+B5F,EAAU4W,oBAAoBtT,GAP7D,UAOQuT,EAPR,SAQQC,EAAaD,GAAkBA,EAAe,IARtD,yCAUWjN,GAAmB,SACnBuH,GADkB,IACJ5L,SAAUuR,EAAWvR,SAASK,KACjDtF,EACAN,IAbN,4C,sBAkBO,SAAe4J,GAAtB,uC,oDAAO,WACL9J,EACAQ,EACAN,GAHK,uHAOC+W,EAAcjX,EAAQ4B,QAPvB,SAQoBkP,EAA2B9Q,EAASE,GARxD,YAQCO,EARD,8BAWGyW,EADkBlX,EACeyF,YAGrCyR,EAAezR,eACgBzD,IAA/BkV,EAAezR,SAASK,GAfvB,iBAiBD/D,EAAOmV,EAjBN,yCAmBYhX,EAAU4N,YAAYrN,GAnBlC,QAmBDsB,EAnBC,mBAqBCA,EArBD,oBAsBKJ,EAAMI,EAAK0D,SAAS9D,IACpB0P,EAvBL,SAwBIrR,GAxBJ,IAyBCyF,SAAUhF,IAGNmI,EAAyC,CAC7CyI,aAAAA,EACA7Q,OAAAA,EACAN,UAAAA,EACA6B,KAAAA,IAG+B,IAA7B6U,GAAWnC,QAAQ9S,GAnCtB,oBAoCa,WAARA,EApCL,iBAqCGC,EAAUoU,GAAoBpN,GArCjC,2BAsCoB,iBAARjH,GAAkC,kBAARA,EAtCtC,oBAuCSwG,EACJpG,EAAK2Q,cACLC,EAAAA,GAAgC5Q,EAAK2Q,aAAaE,gBAC9CuE,EACJvO,EAAeyI,aAAazI,gBAAkB,IAChCT,KAAOgP,EAAgBhP,MAAQA,EAC/CS,EAAeyI,aAAazI,eAAiBuO,EAC7CnX,EAAQ4I,eAAiBA,OACL5G,IAAhBiV,GAA6C,YAAhBA,EA/CpC,oBAgDyB,QAAhBA,EAhDT,iBAiDOrV,EAAUyT,GAAoBzM,GAjDrC,iDAmDciO,GAA4BjO,IAnD1C,gCAsDKhH,EAAUuP,EAAqBvI,GAtDpC,mCAwDoB,iBAARjH,EAxDZ,0CAyDUkV,GAA4BjO,IAzDtC,WA0DoB,kBAARjH,EA1DZ,iBA2DGC,EAAUsU,GAA0BtN,GA3DvC,2BA6DuB,YAAhBqO,EA7DP,kCA8D8B/W,EAAU4N,YACjC/L,EAAK0D,SAASjC,OAAOsC,IA/D5B,SA8DWsR,EA9DX,UAkEaC,EADQ,SAETrX,GAFS,IAGZyF,SAAU1D,EAAK0D,SAASjC,OAAOsC,KAEjClE,EAAUuP,EAAqB,SAC1BvI,GADyB,IAE5B7G,KAAMqV,EACN/F,aAAcgG,MAzEvB,wBA6EKzV,EAAUyT,GAAoBzM,GA7EnC,oCAgFU/G,GAAcF,GAhFxB,iBAiFO2V,EAAkBzV,GAAcF,IAGpC4V,EADEN,GAAuC,mBAAjBM,EACRD,EACdL,GAGaK,KAGf1V,EAAU2V,EAAa3O,IA3F1B,uDA8F0BjH,EA9F1B,6DAiGK,6BAjGL,YAqGDC,EArGC,0CAsGIA,EAAQoD,MAAK,SAAC/B,GACnB,GAAIA,EAAG,CACL,IAAMuU,EAAkBvU,EAQxB,OAPIlB,IACFyV,EAAgBC,UAAU1V,KAAOA,EACjCyV,EAAgBC,UAAUhX,WAAasB,EAAK0D,SAASK,GACrD0R,EAAgBC,UAAUvX,UAAYA,IAGxCwX,EAAAA,EAAAA,IAAYF,EAAiB,CAAC1H,GAAc,CAAE6H,SAAS,IAChDH,OAhHR,6C,0hGClCA,IAAMI,EAA+C,CAC1DzD,IAAK,KACL0D,YAAa,WAGR,SAAS/M,EAGd/I,GAQA,MAN+B,CAC7B+V,SAFe/V,EAAK8I,KAGpB/E,GAAI/D,EAAK+D,GACTqC,KAAM,UACN3F,WAAYT,EAAKmI,QAKd,SAAS6N,EAEdvS,EAA8BxF,GAC9B,IAAQiL,EAAkCjL,EAAlCiL,WAAYJ,EAAsB7K,EAAtB6K,KAAMX,EAAgBlK,EAAhBkK,OAAQiK,EAAQnU,EAARmU,IAClC3O,EAAOyF,WAAaA,EAAaA,EAAW+M,KAAK,KAAO,QACzChW,IAAXkI,IACF1E,EAAO0E,OAASiB,MAAMC,QAAQlB,GAAUA,EAAO8N,KAAK,KAAO,SAEhDhW,IAAT6I,IACFrF,EAAOqF,KAAOA,EAAO,MAAQ,KACxBA,WACIrF,EAAO2O,WACP3O,EAAOqS,eAGd/B,EAAAA,EAAAA,GAAQ3B,KACV3O,EAAO2O,IAAMA,GAMV,SAAS8D,EAIdpH,GAGA,IAAMqH,EAAoDC,EACxDtH,GAGF,OAAOzG,EAAAA,EAAAA,IAAsB8N,GAASlT,MAAK,SAACoT,GAE1C,IAFyD,EAEnDlL,EAAgB,GAChBJ,EAA6B,GAHsB,IAItCsL,GAJsC,IAIzD,2BAA+B,wBAC7B,2BAAyB,KAAdrW,EAAc,QAClBmL,EAAImL,SAAStW,EAAK+D,MACrBgH,EAAMpD,KAAK3H,GACXmL,EAAIxD,KAAK3H,EAAK+D,MAJW,gCAJ0B,8BAYzD,IAAMwS,OAAwBtW,IAAf6O,EAAIyH,OAAuBzH,EAAIyH,OAAS,EACjDC,OAAsBvW,IAAd6O,EAAI0H,MAAsB1H,EAAI0H,MAAQzL,EAAMnM,OAC1D,OAAIkQ,EAAIyH,QAAUzH,EAAI0H,MACbzL,EAAM0L,OAAOF,EAAQC,GAEvBzL,KAIX,SAAS2L,EAAYC,GACnB,QAAkCA,EAAlC,GAAOC,EAAP,KAAcC,EAAd,KAAyB1W,EAAzB,KACM2W,EAAqB,OAAVF,EAAiB,OAAS,GACvCG,EAAS,GACTC,EAAO,GACLC,EAAShT,OAAO2S,GACnBM,OACAtB,QAAQ,mBAAmB,SAACuB,EAAG7L,EAAGtB,EAAGoN,GAGpC,OAFAL,EAASzL,EACT0L,EAAOI,EACApN,KAELqN,EAAIN,EAAS5W,EAAQ6W,EAC3B,MAAO,CAAC,GAAD,OAAIF,GAAJ,OAAeG,EAAf,aAA0BJ,GAAaQ,GAGhD,SAASjB,EAIPtH,GAI0C,IAF1CwI,EAE0C,uDAFW,GACrDC,EAC0C,uDADN,GAE5BvH,EAAYlB,EAAZkB,QAEFwH,EAA8B,iBAAfxH,EAAQ,GAAkBA,EAAQ,GAAK,MAEtDyH,EAAWzH,EAAQzK,QAAO,SAACrE,GAAD,OAAOkI,MAAMC,QAAQnI,MAErD,GAAc,QAAVsW,EAAiB,WACHC,GADG,IACnB,2BAA0B,KAAfhF,EAAe,SACpBiF,EAAAA,EAAAA,IAAiBjF,GACnB6E,EAAS3P,KACPgQ,EAAyB,OACpB7I,GADoB,IAEvB8I,UAAW,GAAF,SAAML,GAAN,CAAwBb,EAAYjE,SAIjD2D,EAAW,EAAD,KAEHtH,GAFG,IAGNkB,QAASyC,IAEX6E,EALQ,EAMJC,KAhBS,oCAoBd,GAAc,QAAVC,EAAiB,CAC1B,IAD0B,EACpBxH,EAA2B,GAC3B6H,EAA2C,GAFvB,IAGVJ,GAHU,IAG1B,2BAA0B,KAAfhF,EAAe,SACpBiF,EAAAA,EAAAA,IAAiBjF,GACnBzC,EAAQrI,KAAK+O,EAAYjE,IAEzBoF,EAAqBlQ,KAAK8K,IAPJ,8BAW1B,GAAIoF,EAAqBjZ,OAAQ,WACfiZ,GADe,IAC/B,2BAAsC,KAA3B3W,EAA2B,QACpCkV,EAAW,EAAD,KAEHtH,GAFG,IAGNkB,QAAS9O,IAEXoW,EALQ,YAMJC,GAAqBvH,KARE,oCAY/BsH,EAAS3P,KACPgQ,EAAyB,OACpB7I,GADoB,IAEvB8I,UAAW,GAAF,SAAML,GAAqBvH,OAK5C,OAAOsH,EAWF,SAASK,EAGd1Z,GACA,IAXM6Z,EAWArU,EAA6D,EAAH,GAC3DoS,GAGHW,EAUEvY,EAVFuY,MACAtH,EASEjR,EATFiR,MACA6I,EAQE9Z,EARF8Z,OACAxB,EAOEtY,EAPFsY,OACAyB,EAME/Z,EANF+Z,QACAJ,EAKE3Z,EALF2Z,UACAzZ,EAIEF,EAJFE,UACA8Z,EAGEha,EAHFga,WACAjG,EAEE/T,EAFF+T,WACAtT,EACET,EADFS,WAqBF,GAnBI8X,EACEA,IAAUlV,OAAO4W,oBACnBzU,EAAO+S,MAAQA,GAIjB/S,EAAO+S,MAAQ,IAEbD,IACF9S,EAAO8S,OAASA,GAEd0B,IACFxU,EAAOqS,YAAcmC,GAEvBjC,EAAuBvS,EAAQxF,GAE3B+Z,IACFvU,EAAO0U,SAAWH,EAAQ/B,KAAK,MAE7B7M,MAAMC,QAAQ2I,GAAa,CAC7B,IAAMoG,GAAcC,EAAAA,EAAAA,GAAoBrG,IACpCsG,EAAAA,EAAAA,IAAqBtG,GACrBA,EAEJvO,EAAOuO,YAlDH8F,EAkDwCM,EAlDxB9Q,KAAI,YAAgB,aAAdiR,EAAc,KAATC,EAAS,KACxC,KAAeC,EAAAA,EAAAA,IAAeF,EAAKC,GAAKlR,KAAI,SAAC8P,GAAD,OAAOsB,EAAAA,EAAAA,GAAMtB,MAAzD,GACA,OADA,KACW,IADX,QAGF,mBAAmBU,EAAQ7B,KAAK,MAAhC,WA+CiC,iBAAfjE,IAChBvO,EAAOuO,WAAaA,GAGlB4F,IACFnU,EAAOmU,UAAYA,GAErB,IAAMe,EAAY,EAAH,CACb5U,GAAIrF,GACD+E,GAGL,OAAOtF,EAAU0C,IACf,mCACA,CAAEqO,MAAAA,EAAO6I,OAAAA,GACTY,K,m3BCjPG,SAASvO,EACd3K,GAEA,IAAMmZ,EAASnZ,EAAM,cACfoZ,EAAOpZ,EAAM,YACbqZ,EAAMrZ,EAAM,WACZsZ,EAAQtZ,EAAM,aACpB,GAAImZ,GAAUC,GAAQC,GAAOC,EAAO,CAClC,IAAMvQ,EAA4B,CAACqQ,EAAMD,EAAQG,EAAOD,GAOxD,OANItQ,EAAO,GAAK,KACdA,EAAO,GAAK,IAEVA,EAAO,IAAM,KACfA,EAAO,IAAM,IAERA,GAIJ,SAASwQ,EAAT,GAML,IALAta,EAKA,EALAA,WACAP,EAIA,EAJAA,UAIA,IAHA+Q,MAAAA,OAGA,SACA,OAAO/Q,EACJ0C,IAAI,eAAgB,CAAEqO,MAAAA,GAAS,CAAEnL,GAAIrF,IACrCuE,MAAK,SAACsF,GACL,GAAIA,EAAM,CACR,MAA2CA,EAAKC,OAAxCG,EAAR,EAAQA,OAAQE,EAAhB,EAAgBA,OAAQJ,EAAxB,EAAwBA,OAExB,MADuC,CADvC,EAAgCC,OACgBD,EAAQI,EAAQF,OAMjE,SAASsQ,EAAT,GAOL,IANAva,EAMA,EANAA,WACAuK,EAKA,EALAA,UACA9K,EAIA,EAJAA,UAIA,IAHA+Q,MAAAA,OAGA,SACA,OAAO/Q,EACJ0C,IACC,oCACA,CAAEqO,MAAAA,GACF,CAAEnL,GAAIrF,EAAY4J,IAAKW,IAExBhG,MAAK,SAACsF,GACL,GAAIA,EAAM,CACR,MAA2CA,EAAKC,OAAxCG,EAAR,EAAQA,OAAQE,EAAhB,EAAgBA,OAAQJ,EAAxB,EAAwBA,OAExB,MADuC,CADvC,EAAgCC,OACgBD,EAAQI,EAAQF,OAMjE,SAAS4I,EACdtT,GAEA,OAAOA,EAAQE,UAAU4N,YAAY9N,EAAQS,YAAYuE,MAAK,SAACS,GAC7D,GAAIA,EACF,OAAOsK,EAAuBtK,EAAUzF,EAAQE,UAAWF,MAM1D,SAAS+P,EACdhO,EACA7B,EACAF,GAEA,GAAI+B,EAAKP,OACP,OAAO4I,EAAAA,EAAAA,QAA0B+B,EAAmBpK,EAAKP,SAEzD,IAAMiE,EAAW1D,EAAK0D,SACtB,OAAIA,EAAS9D,MAA0C,IAAnC8D,EAAS9D,IAAI8S,QAAQ,SAChCvU,EAAU4N,YAAYrI,EAASjC,OAAOsC,IAAId,MAAK,SAACiW,GACrD,GAAIA,EACF,OAAOF,EAAoB,EAAD,KACrB/a,GADqB,IAExBS,WAAYwa,EAAIxV,SAASK,GACzB5F,UAAAA,QAKC6a,EAAoB,EAAD,KACrB/a,GADqB,IAExBS,WAAYgF,EAASK,GACrB5F,UAAAA,O,6ECjGD,SAASgb,EAGdlb,GACA,OAAO+K,EAAAA,EAAAA,GAAwB/K,GAASgF,MAAK,SAACjD,GAC5C,OAAO+I,EAAAA,EAAAA,IAA2B/I,Q,oFCL/B,SAASqQ,EAIdpS,GAEA,OCJK,SAGLA,GACA,OAAO6M,EAAAA,EAAAA,GAAmB7M,GAASgF,MAAK,SAAC/B,GACvC,IAAMsR,EAAiC,GAKvC,OAJAtR,EAAE4I,SAAQ,SAAC+D,GACT2E,EAAS7K,MAAKoB,EAAAA,EAAAA,IAAqB8E,OAG9B2E,KDNF4G,CAA4Bnb,GAASgF,MAAK,SAACuP,GAKhD,MAJmD,CACjDpM,KAAM,oBACNoM,SAAAA,Q,ozBEAC,SAASxJ,EAId/K,GAEA,IAAMwF,EAAyD,EAAH,GACvDoS,EAAAA,KAELG,EAAAA,EAAAA,IAAuBvS,EAAQxF,GAC/B,IAAMob,EAAc,EAAH,CACftV,GAAI9F,EAAQS,WACZ4J,IAAKrK,EAAQgL,WACVxF,GAECyL,EAAQjR,EAAQiR,QAAS,EAC/B,OAAOjR,EAAQE,UACZ0C,IAAI,6BAA8B,CAAEqO,MAAAA,GAASmK,GAC7CpW,MAAK,SAACsF,GACL,cACKA,GADL,IAEE+Q,UAAW,WACT,OAAI/Q,EAAKO,KACAT,EAAAA,EAAAA,SAA0BU,EAAAA,EAAAA,IAA2BR,IAErDS,EAAkB,EAAD,KACnB/K,GADmB,IAEtB6K,MAAM,EACNX,OAAQ,KACRe,WAAY,QACXjG,MAAK,SAACkG,GACP,IAAML,EAAOK,EAAaL,KAC1B,OAAOC,EAAAA,EAAAA,IAAoB,OAAYR,GAAZ,IAAkBO,KAAAA,gB,w0BClCpD,SAASgC,EAGd7M,GACA,IAAM+R,EAAU/R,EAAQ+R,QACxB,OAAIA,GACKkG,EAAAA,EAAAA,IAAgC,EAAD,KACjCjY,GADiC,IAEpC+R,QAAAA,KACC/M,MAAK,SAAC+I,GAAS,MAchB,OAb0B,UACxB/N,EAAQsb,4BADgB,QACQC,EAAoBxJ,MAGpDhE,EAAOA,EAAKzG,QAAO,SAACsI,GAClB,IAAM1F,GAAS6K,EAAAA,EAAAA,GAAmC,EAAD,KAC5CnF,EAAE1F,QAD0C,IAE/CpE,GAAI8J,EAAE9J,MAGR,OADeiN,EAAAA,EAAAA,IAAiB7I,EAAQ6H,OAIrChE,MAGF2L,EAAAA,EAAAA,IAAgC1Z,GAI3C,SAASub,EAAoBxJ,GAC3B,GAAmB,QAAfA,EAAQ,GACV,OAAO,EAET,IAAK,IAAI1N,EAAI,EAAGA,EAAI0N,EAAQpR,OAAQ0D,IAAK,CACvC,IAAMoM,EAAIsB,EAAQ1N,GAClB,IAAI+G,EAAAA,EAAAA,IAAQqF,IACG8K,EAAoB9K,GAE/B,OAAO,EAIb,OAAO,I,iVCtDF,SAAe+K,EAAtB,oC,iDAAO,WACLtb,EACAF,GAFK,kHAIkBE,EAAU0C,IAAI,mBAAoB,KAAM,CAC7D6Y,UAAW,YALR,aAICC,EAJD,SAOWA,EAASC,cAAgBD,EAASC,aAAazM,SAP1D,wBAQG0M,EAASzL,SAASC,cAAc,MAC/ByL,MAAMC,SAAW,WACxBF,EAAOC,MAAMlB,OAAS,IACtBiB,EAAOC,MAAMf,MAAQ,IACrBc,EAAOC,MAAME,QAAb,UAAuB/b,MAAAA,OAAvB,EAAuBA,EAAS+b,eAAhC,QAA2C,OAC3CH,EAAOI,UAAY,eACfhc,GAAWA,EAAQic,WACrBL,EAAOI,WAAa,IAAMhc,EAAQic,WAE9BC,EAAM,IAAIC,OACZN,MAAMO,UAAY,QACtBF,EAAIL,MAAMQ,SAAW,QACrBH,EAAII,IAAM,GApBP,oBAsBiBpc,EAAU0C,IAAI,uBAAwB,CACtD2Z,aAAc,SAvBf,QAsBKD,EAtBL,OAyBKE,EAAaC,OAAOC,KAAOD,OAAOE,UAClCC,EAAWJ,EAAWK,gBAAgBP,GAC5CJ,EAAII,IAAMM,EA3BT,mDA6BDE,QAAQC,KAAR,MA7BC,eAiC8B,OAA/BrB,EAASC,aAAaqB,MACgB,KAAtCtB,EAASC,aAAaqB,KAAK/D,SAE3B2C,EAAOqB,KAAOvB,EAASC,aAAaqB,KACpCpB,EAAOsB,OAAS,UAC2C,IAAvDxB,EAASC,aAAaqB,KAAKG,OAAO,kBACpCjB,EAAIkB,IAAM,wCAGdxB,EAAOrL,YAAY2L,GA1ChB,kBA2CIN,GA3CJ,4D,g2CCgBA,IAAMyB,EAAb,WAiBE,WAAYrd,I,4FAA8B,+SACxC,IAAMwU,EAAIxU,EAAQiQ,QAClBhQ,KAAK6F,GAAK0O,EAAE1O,GACZ7F,KAAK4K,KAAO2J,EAAE3J,KACd5K,KAAKqd,MAAQ9I,EAAE8I,MACfrd,KAAKuD,OAASgR,EAAEhR,OAChBvD,KAAKiK,OAASsK,EAAEtK,OAChBjK,KAAKsd,QAAU/I,EAAE+I,QACjBtd,KAAKC,UAAYF,EAAQE,U,QAzB7B,O,EAAA,E,EAAA,uBA4BE,WAEmD,WADjDF,EACiD,uDADN,GAE3C,OAAIC,KAAKud,MACApT,EAAAA,EAAAA,QAA0BnK,KAAKud,QAEjCzS,EAAAA,EAAAA,GAAiB,GACtB7K,UAAWD,KAAKC,UAChB8K,UAAW/K,KAAK6F,GAChBrF,WAAYR,KAAKsd,QACjBrT,OAAQ,KACRe,WAAY,CAAC,aAAc,gBACxBjL,IACFgF,MAAK,SAACsF,GAIP,OAHA,EAAKkT,MAAQlT,EACb,EAAKO,KAAOP,EAAKO,KACjB,EAAKI,WAAaX,EAAKW,WAChBX,OA7Cb,sBAiDE,WAA+C,WAC7C,OAAIrK,KAAKwd,UACArT,EAAAA,EAAAA,QAA0BnK,KAAKwd,UAAUhR,eAE3CxM,KAAKC,UAAU4N,YAAY7N,KAAKsd,SAASvY,MAAK,SAACsF,GAEpD,OADA,EAAKmT,UAAYnT,EACV,EAAKmT,UAAUhR,mBAvD5B,uBA2DE,WACE,OAAIxM,KAAKkK,QACAC,EAAAA,EAAAA,QAA0BnK,KAAKkK,UAEjC6Q,EAAAA,EAAAA,IAAwB,CAC7B9a,UAAWD,KAAKC,UAChB8K,UAAW/K,KAAK6F,GAChBrF,WAAYR,KAAKsd,YAlEvB,qBAsEE,WAA4C,WAC1C,OAAItd,KAAKyd,SACAtT,EAAAA,EAAAA,QAA0BnK,KAAKyd,UAEjCzd,KAAK0d,WAAW3Y,MAAK,SAACsF,GAC3B,OAAOA,EAAK+Q,YAAYrW,MAAK,SAAC4Y,GAE5B,OADA,EAAKF,SAAWE,EACTA,W,oBA7Ef,K,ynFCUO,SAASC,EACdF,GAEmB,IADnBG,EACmB,wDACbC,EAAY,GACZC,EAAa,GACnB,IAAK,IAAMxZ,KAAKmZ,EAAU,CACxB,IAAM7X,EAAKzC,OAAOmB,GACbyZ,MAAMnY,IACTiY,EAAUrU,KAAK5D,GAGnB,IAAMoY,EAAaP,EAASI,UACxBG,GACFH,EAAU3Q,MAAK,SAACC,EAAGtB,GACjB,OAAOmS,EAAWzJ,QAAQpH,GAAK6Q,EAAWzJ,QAAQ1I,MAItD,IAAK,IAAIoS,EAAM,EAAGA,EAAMJ,EAAUpd,OAAQwd,IAAO,CAC/C,IAAM3Z,EAAIuZ,EAAUI,GACdC,EAAeT,EAASnZ,GAC9B,GAAI,aAAc4Z,EAAc,CAC9B,IAAMC,EAAgBD,EAAa7J,SAC7B9T,EAAa4C,OAAOmB,GACpB8Z,EAAmCC,EACvCF,EACA5d,EACAqd,GAEF,GAAIQ,EAAc3d,SAChBqd,EAAWtU,KAAX,MAAAsU,EAAU,EAASM,KACdR,GACH,OAKR,OAAOE,EAGT,SAASO,EACPhK,EACA9T,EACAqd,GAEA,IADmB,EACbQ,EAAmC,GADtB,IAEG/J,GAFH,IAEnB,2BAAgC,KAArBtE,EAAqB,QACxBzK,EAAS,CACbwF,UAAWiF,EAAQnK,GACnBrF,WAAAA,EACAwP,QAAAA,GAGF,GADAqO,EAAc5U,KAAKlE,IACdsY,EACH,OAVe,8BAanB,OAAOQ,EAGF,SAASE,EAIdxe,GAEA,IAAQE,EAAwCF,EAAxCE,UAAWyd,EAA6B3d,EAA7B2d,SAAUc,EAAmBze,EAAnBye,eAC7B,IAAK,IAAMja,KAAKmZ,EAAU,CACxB,IAAM7X,EAAKzC,OAAOmB,GAClB,IAAKyZ,MAAMnY,GAAK,CACd,IAAM/D,EAAO4b,EAASnZ,GACtB,GAAI,aAAczC,EAAM,CACtB,IAAM2c,EAAW3c,EAAKwS,SAAS7H,MAAK,SAACzJ,GAAD,OAAOA,EAAE4H,QAE7C,GAAI6T,GAAYA,EAAS7T,KAAM,CAC7B,IAAMA,EAAO6T,EAAS7T,KACtB,OAAOT,EAAAA,EAAAA,SACLU,EAAAA,EAAAA,IAAqB,OAChB4T,GADe,IAElB7T,KAAAA,SAQZ,IAAMrF,EAASqY,EAAiBF,GAChC,OAAInY,GAAUA,EAAO7E,QACZua,EAAAA,EAAAA,GAAqB,OAAKuD,GAAN,IAAsBve,UAAAA,GAAcsF,EAAO,KAEjE4E,EAAAA,EAAAA,aAA0BpI,GAG5B,SAAS2c,EAId3e,GAEA,IAAQE,EAAwBF,EAAxBE,UAEFsF,EAASqY,EAFiB7d,EAAb2d,UAGnB,OAAInY,GAAUA,EAAO7E,QACZoK,EAAAA,EAAAA,GAAiB,KACtB7K,UAAAA,GACGF,EAAQye,gBACRjZ,EAAO,KAGP4E,EAAAA,EAAAA,aAA0BpI,GA8D5B,SAAS4c,EACdC,EACA7e,IAEA8e,EAAAA,EAAAA,GAAmBD,GACnB,QAAmBA,EAAGE,OAAtB,GAAOzE,EAAP,KAAYC,EAAZ,KACQ1P,EAAgC7K,EAAhC6K,KAAMmU,EAA0Bhf,EAA1Bgf,OAAQlF,EAAkB9Z,EAAlB8Z,OAAQ7I,EAAUjR,EAAViR,MACxBgO,EAAQpU,MAAAA,EAAAA,GAAQqU,EAAAA,EAAAA,GAA4B5E,EAAKC,EAAKyE,GAE5D,OAxDK,SACLhf,GAEA,IAAQ6K,EAAwB7K,EAAxB6K,KAAMiP,EAAkB9Z,EAAlB8Z,OAAQ7I,EAAUjR,EAAViR,MAClBgO,EAAoB,GACxB,GAAI9T,MAAMC,QAAQP,GAChBoU,EAAQpU,MACH,CACL,IAAMgP,EACU,YAAdhP,EAAK1C,KACD0C,EAAKiN,SACS,YAAdjN,EAAK1C,MACL0C,EAEFgP,IACFoF,EAAQpF,EAAQM,YAAY,IAGhC,GAAI8E,EAAO,CAET,IAFS,EAEHE,EAAuB,GAFpB,IAIgBF,GAJhB,IAIT,2BAAgC,oBAApB3E,EAAoB,KAAfC,EAAe,KAC9B,KAAeC,EAAAA,EAAAA,IAAeF,EAAKC,GAAnC,GAAOtX,EAAP,KAAU2M,EAAV,KACAuP,EAAWzV,KAAKzG,EAAI,IAAM2M,IANnB,8BAST,IAIM7B,EAAsC,CAC1ClD,KALU,YAAH,OAAesU,EAAWnH,KAAK,MAA/B,MAMP7D,IAAK,KACL1E,OALuBzP,EAAQyP,QAQjC,OAAOzP,EAAQE,UAAUkf,KAAK,yBAA0B,CACtDrR,KAAAA,EACA+L,OAAAA,EACA7I,MAAAA,IAGF,MAAM,IAAI5Q,MAAM,kDAaXgf,CAAqB,OAAKrf,GAAN,IAAe6K,KAAMoU,EAAOnF,OAAAA,EAAQ7I,MAAAA,KAG1D,SAASqO,EAGdzO,GACA,OAAO,IAAIwM,EAAmBxM,K,yWCzKzB,SAAStB,EAAT,GAQO,IAERpP,EATJH,EAOY,EAPZA,QACAQ,EAMY,EANZA,OACAJ,EAKY,EALZA,QAMIwB,EAAU5B,EAAQ4B,SAAW,QAE3B6P,EAAgBjR,GAAUA,EAAOkV,mBACjC6J,GAAiB9N,GAAgBA,EAAckE,MAE/ClV,EAAaT,EAAQyF,SACrB+Z,EAAiBxf,EAAQyf,WAAazf,EAAQyf,WAAa,IAEjE,GAA0B,iBAAfhf,EAAyB,CAClC,GAAgB,UAAZmB,EAAqB,CACvB,GAAI2d,EACF,OA7CD,YAK+C,IAJpD9e,EAIoD,EAJpDA,WAEA+e,EAEoD,EAFpDA,GACAna,EACoD,EADpDA,QAEMlF,EAD8C,EAHpDC,QAIsB,8BAChBoF,EAA8B,CAAEC,SAAUhF,GAIhD,OAHI+e,IACFha,EAAOga,GAAKA,GAEP,CACLrf,IAAAA,EACAM,WAAAA,EACA4E,QAAAA,EACAG,OAAAA,EACAe,gBAAiB,SAACmZ,GAIhB,OAHIF,IACFE,EAAQF,GAAKA,IAERnQ,EAAAA,EAAAA,IAAkBqQ,EAASjf,KAyBzBkf,CAAuB,CAC5Blf,WAAAA,EACA4E,QAASrF,EAAQqF,QACjBma,GAAAA,EACApf,QAAAA,IAGFwB,EAAU,OAGd,GAAgB,QAAZA,EAAmB,CACrBzB,EAAM,GAAH,OAAMC,EAAN,yBAA8BK,EAA9B,QACH,IAAMmI,EAAiB5I,EAAQ4I,eAC/B,MAAO,CACLzI,IAAAA,EACAyf,OAAQ,YACRC,QAAS,QACTpQ,OAAQ7G,GAAkBA,EAAe6G,OACzCpK,QAASrF,EAAQqF,SAGE,MAAvB,GAAgB,QAAZzD,EASF,MAAO,CACLzB,IATFA,EACEC,EAAAA,+DAGAK,EACA,oBAJA,UAKCT,EAAQ8f,sBALT,QAK2B,GAI3BC,YAAa,OAAStf,EACtBuf,cAAe,OAGnB,GAAgB,YAAZpe,EAGF,MAAO,CAAEzB,IAFTA,EAAMC,EAAU,iBAAH,OAAoBK,EAApB,qBAECmB,QAAAA,GAEhB,GAAgB,aAAZA,EAEF,MAAO,CAAEzB,IADTA,EAAMC,EAAU,2BAAH,OAA8BK,EAA9B,cAGf,GAAgB,SAAZmB,EAOF,MAAO,CAAEzB,IANTA,EACEC,EACA,yDACAK,EACA,OACA+e,EACY5d,QAAAA,OAEX,SAAmBI,IAAfvB,EACT,MAAM,IAAIJ,MACR,yCAA2C,EAAOI,IAGpDqc,QAAQmD,IAAI,gC,kpBC7HT,SAASlL,EACd7K,GAEA,IAAIsK,EACJ,IAAKA,KAAKtK,EAAQ,CAChB,IAAMyO,EAAQzO,EAAOsK,GACrB,IAAI0L,EAAAA,EAAAA,IAASvH,GAAQ,CACnB,IAAMwH,EAAOxH,GACT7C,EAAAA,EAAAA,GAAQqK,EAAKC,QAAStK,EAAAA,EAAAA,GAAQqK,EAAKE,SAAUvK,EAAAA,EAAAA,GAAQqK,EAAKG,MAAM,WAClE,IAAMC,EAA0D,CAC9DJ,EAAKC,KACLD,EAAKE,MAAQ,EACbF,EAAKG,KAEH,SAAUH,GACZ,CAACA,EAAKK,KAAML,EAAKM,OAAQN,EAAKO,QAAQ7U,SAAQ,SAAC5I,GAC7Csd,EAAG7W,KAAKzG,MAGZiH,EAAOsK,GAAK,EAAImM,KAAQJ,GAAIK,cAXsC,OAarD,OAANpM,GAA+B,iBAAVmE,IAC9BzO,EAAOsK,GAAKmE,EAAMkI,MAAM,KAAKxX,IAAIhG,SAGrC,OAAO6G,I,ysDChBF,SAASmF,EACd7J,EACA/E,GAEA,IAAQqgB,EAA4Btb,EAA5Bsb,KAAMC,EAAsBvb,EAAtBub,MAAOC,EAAexb,EAAfwb,OAAQxB,EAAOha,EAAPga,GAC7B,MAAO,CACL/Z,SAAU0F,MAAMC,QAAQ3K,GAAcA,EAAWuX,KAAK,KAAOvX,EAC7D8J,OAAQuW,EACRG,KAAMF,EAAQ,IAAMC,EACpBE,UAAWP,KAAKQ,MAChB3B,GAAIA,MAAAA,EAAAA,EAAM,KAIP,IA0DH4B,EA1DSzO,EAGT,CACF0O,MAAO,QACPC,WAAY,OACZC,QAAS,UACTC,WAAY,QACZC,gBAAiB,OACjBC,aAAc,UACdC,OAAQ,QACRC,YAAa,OACbC,SAAU,UACVC,YAAa,QACbC,iBAAkB,OAClBC,cAAe,WAGV,SAASC,EACdjiB,EACAQ,EACAN,GAEA,IAAMmF,EAAUnF,EAAUyN,0BAK1B,OAJItI,IACFrF,EAAQqF,QAAUA,IAGbyE,EAAAA,EAAAA,GAAmB9J,EAASQ,EAAQN,GAkBtC,SAASwB,EACdmP,GAQA,OAP6B,a,kOAAA,U,IAAA,G,EAAA,E,+YAE3B,WAAYxH,EAAUrJ,GAAkC,O,4FAAA,SACtDA,EAAU,EAAH,KAAQ6Q,GAAQ7Q,GAD+B,YAEhDqJ,EAAKrJ,GAJc,UACbc,EAAAA,GAWX,SAASohB,IACd,QAAuBlgB,IAAnBof,EAA8B,CAChC,IAAMe,EAAMhS,SAASC,cAAc,OACnC+R,EAAItG,MAAMuG,QACR,gEACFjS,SAASkS,KAAK9R,YAAY4R,GAC1B,IAAMG,EAAKH,EAAII,YACfpS,SAASkS,KAAKG,YAAYL,GAC1Bf,EAAiBkB,EAEnB,OAAOlB,EAIF,SAASqB,EAA0BlI,GACxC,OAAO,SAAc9S,KAAKib,GAAKjb,KAAKkb,IAAKpI,EAAM9S,KAAKib,GAAM,KAGrD,SAASE,EAAiB9b,GAC/B,OAAOW,KAAKwY,IAAInZ,EAAQ,KAAOW,KAAKob,IAG/B,SAAS9b,EAAcD,GAAgC,IAAjByT,EAAiB,uDAAX,EAK3CuI,EAAYvI,EACZwI,EACHb,IAAuBO,EAA0BK,GAAchc,EAC5DkN,EAAO4O,EAAiBG,GAC9B,OAAO/O","sources":["webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/WebmapLayerOpacityPropertyHandler.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowNgwAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/BookmarkItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/constants.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwResource.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/createPopupContent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerCount.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createGeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createRasterAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createNgwWebmapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createBasemapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createAsyncAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwExtent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeature.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatureCollection.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatures.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItems.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getCompanyLogo.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/IdentifyItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/identifyUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/ngwApiToAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/prepareNgwFieldsToPropertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/utils.ts"],"sourcesContent":["import NgwConnector from '@nextgis/ngw-connector';\n\nimport { extendNgwWebmapLayerAdapter } from './utils/utils';\nimport { NgwWebmapLayerAdapter } from './NgwWebmapLayerAdapter';\nimport { classAdapters } from './adapters/createAsyncAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, StarterKit, LayerAdapterCreators } from '@nextgis/webmap';\nimport type {\n  NgwKitOptions,\n  GetClassAdapter,\n  NgwWebmapAdapterOptions,\n} from './interfaces';\n\nexport class NgwKit implements StarterKit {\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl || '';\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth,\n      });\n    }\n  }\n\n  static addClassAdapters(cls: string, adapter: GetClassAdapter): void {\n    classAdapters[cls] = adapter;\n  }\n\n  async onLoadSync(webMap: WebMap): Promise<NgwWebmapLayerAdapter | undefined> {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: Partial<NgwWebmapAdapterOptions> = {\n            resourceId: r,\n            connector: this.connector,\n            webMap,\n          };\n          const layer = (await webMap.addLayer(NgwWebmapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            pixelRadius: this.options.pixelRadius,\n            ...options,\n          })) as NgwWebmapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap)),\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<NgwWebmapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendNgwWebmapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl,\n    });\n  }\n}\n","import { BaseProperty } from '@nextgis/item';\nimport type { ItemBasePropertyOptions } from '../../../item/src/interfaces';\nimport type { NgwWebmapItem } from '../NgwWebmapItem';\n\ntype VAL = number;\n\nexport class WebmapLayerOpacityPropertyHandler<\n  V extends VAL = VAL,\n> extends BaseProperty<VAL, ItemBasePropertyOptions<VAL>, NgwWebmapItem> {\n  getProperty(): number {\n    const layer = this.item.layer;\n    if (layer) {\n      return layer && layer.options && layer.options.opacity !== undefined\n        ? layer.options.opacity\n        : 1;\n    }\n    return 1;\n  }\n\n  update(value: V, options?: ItemBasePropertyOptions<VAL>): void {\n    options = options || {};\n\n    if (this.isGroup()) {\n      this._value = this._prepareValue(value, options);\n      const children = this.getChildren();\n      for (const child of children) {\n        const property = child.properties.property(this.name);\n        if (property) {\n          if (options.propagation) {\n            property.set(value, options);\n          } else {\n            property.update(property.get(), options);\n          }\n        }\n      }\n    }\n    const layer = this.item.layer;\n    if (layer) {\n      const parents = this.getParents();\n      const coef = parents.reduce((s, x) => {\n        const prop = x.properties.property(this.name);\n        const multiplier = prop ? prop.getValue() : 1;\n        return s * multiplier;\n      }, 1);\n      const val = value * coef;\n      this.item.webMap.setLayerOpacity(layer, this._prepareValue(val));\n    }\n  }\n\n  protected _prepareValue(\n    value: number,\n    options?: ItemBasePropertyOptions<VAL>,\n  ): number {\n    if (options && options.propagation && this.isGroup()) {\n      return 1;\n    }\n    // value = Number(value);\n    // return value < 0.1 ? 0.1 : value;\n    return Number(value);\n  }\n}\n","import { EventEmitter } from 'events';\nimport { Item } from '@nextgis/item';\nimport { treeSome } from '@nextgis/tree';\nimport {\n  WebMap,\n  LayerAdapter,\n  ImageAdapterOptions,\n  LayerAdapterDefinition,\n  VectorAdapterOptions,\n} from '@nextgis/webmap';\nimport { objectAssign } from '@nextgis/utils';\n\nimport { setScaleRatio } from './utils/utils';\nimport { WebmapLayerOpacityPropertyHandler } from './utils/WebmapLayerOpacityPropertyHandler';\n\nimport type { ItemOptions } from '@nextgis/item';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { TreeGroup, TreeLayer, TreeItem } from './interfaces';\n\nexport class NgwWebmapItem extends Item<ItemOptions> {\n  static GetAdapterFromLayerType: {\n    [layerType: string]: (\n      item: TreeItem,\n      options: any,\n      webMap: WebMap,\n      connector?: NgwConnector,\n    ) => LayerAdapterDefinition;\n  } = {};\n\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: NgwWebmapItem): boolean {\n          if (item) {\n            if (\n              item.item.item_type === 'group' ||\n              item.item.item_type === 'root'\n            ) {\n              return treeSome<TreeGroup | TreeLayer>(\n                item.item,\n                (i) => ('layer_enabled' in i ? i.layer_enabled : false),\n                (i) => (i as TreeGroup).children,\n              );\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            }\n            // else if (item.item.item_type === 'root') {\n            //   return true;\n            // }\n          }\n          return false;\n        },\n        onSet(\n          value: boolean,\n          options?: Record<string, any>,\n          item?: NgwWebmapItem,\n        ): void {\n          if (item && item.item.item_type === 'layer') {\n            if (item.layer) {\n              if (value) {\n                item.webMap.showLayer(item.layer);\n              } else {\n                item.webMap.hideLayer(item.layer);\n              }\n            }\n            item.item['layer_enabled'] = value;\n          }\n        },\n      },\n      {\n        name: 'opacity',\n        handler: WebmapLayerOpacityPropertyHandler,\n      },\n    ],\n  };\n\n  item: TreeGroup | TreeLayer;\n  connector?: NgwConnector;\n  layer?: LayerAdapter;\n  readonly emitter = new EventEmitter();\n\n  protected _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n    noInit?: boolean,\n  ) {\n    super({ ...NgwWebmapItem.options, ...options });\n    if (connector) {\n      this.connector = connector;\n    }\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n    this.initProperties();\n    if (!noInit) {\n      this._init(item);\n    }\n  }\n\n  static async create(\n    webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n  ): Promise<NgwWebmapItem> {\n    const ngwWebmapItem = new NgwWebmapItem(\n      webMap,\n      item,\n      options,\n      connector,\n      parent,\n      true,\n    );\n    await ngwWebmapItem._init(item);\n    return ngwWebmapItem;\n  }\n\n  initItem(item: TreeGroup | TreeLayer): Promise<void> {\n    const i = item;\n    const options: Partial<ImageAdapterOptions> = this.getItemOptions(item);\n    const setNewLayer = (l: LayerAdapter) => {\n      i._layer = l;\n      this.layer = l;\n      const enabled = this.properties.get('visibility');\n      if (enabled) {\n        this.properties.set('visibility', true);\n      }\n\n      if (options.opacity !== undefined) {\n        this.webMap.setLayerOpacity(l, options.opacity);\n      }\n    };\n\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        const children = this.getChildren(item);\n        for (const x of children) {\n          const children = new (this.constructor as typeof NgwWebmapItem)(\n            this.webMap,\n            x,\n            this.options,\n            this.connector,\n            this,\n          );\n          this.tree.addChild(children);\n        }\n      }\n      return Promise.resolve();\n    } else {\n      let adapter: LayerAdapterDefinition | undefined;\n      if (item.item_type === 'layer') {\n        adapter = item.adapter || item.layer_adapter.toUpperCase();\n      } else if (NgwWebmapItem.GetAdapterFromLayerType[item.item_type]) {\n        const getAdapter =\n          NgwWebmapItem.GetAdapterFromLayerType[item.item_type];\n        adapter = getAdapter(item, options, this.webMap, this.connector);\n      }\n      if (adapter) {\n        return this.webMap.addLayer(adapter, options).then((newLayer) => {\n          setNewLayer(newLayer);\n        });\n      }\n    }\n    if (item._layer) {\n      return Promise.resolve(setNewLayer(item._layer));\n    }\n    return Promise.reject('No layer added');\n  }\n\n  bringToFront(): void {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      // console.log(this.item);\n    }\n  }\n\n  getLayer() {\n    return this.layer;\n  }\n\n  protected getItemOptions(item: TreeGroup | TreeLayer): Record<string, any> {\n    const transparency = item.item_type === 'layer' && item.layer_transparency;\n    const opacity =\n      typeof transparency === 'number' ? (100 - transparency) / 100 : undefined;\n    const options: Partial<ImageAdapterOptions> &\n      Pick<VectorAdapterOptions, 'popupOptions'> = {\n      visibility: false,\n      headers: this.options.headers,\n      crossOrigin: this.options.crossOrigin,\n      setViewDelay: this.options.setViewDelay,\n      params: { resource: this.item.resourceId, item: this.item },\n    };\n    if (this.options.order) {\n      const subOrder =\n        this.options.drawOrderEnabled && 'draw_order_position' in item\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n\n      // 9 > 0009, 11 > 0011\n      // TODO: find better way to set order in sub level, not limit by 1000 layer in group\n      const subLevel = String(subOrder).padStart(4, '0');\n      options.order = Number((this.options.order | 0) + '.' + subLevel);\n    }\n    if (this.options.popupOptions) {\n      options.popupOptions = this.options.popupOptions;\n    }\n    if (item.item_type === 'layer') {\n      const { maxZoom, minZoom } = this._getZoomRange(item);\n\n      objectAssign(options, {\n        updateWmsParams: item.updateWmsParams,\n        url: item.url,\n        headers: this.options.headers,\n        ratio: this.options.ratio,\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n      });\n    }\n    if (opacity !== undefined) {\n      options.opacity = opacity;\n    }\n    return options;\n  }\n\n  protected getChildren(item: TreeGroup): (TreeGroup | TreeLayer)[] {\n    return [...item.children].reverse();\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private _getZoomRange(item: TreeLayer) {\n    const minZoomWebmap = this.options.minZoom;\n    const maxZoomWebmap = this.options.maxZoom;\n\n    const minZoomLayer = item.layer_min_scale_denom\n      ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n      : undefined;\n    const maxZoomLayer = item.layer_max_scale_denom\n      ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n      : undefined;\n\n    const minZooms = [minZoomWebmap, minZoomLayer].filter(Boolean) as number[];\n    const maxZooms = [maxZoomWebmap, maxZoomLayer].filter(Boolean) as number[];\n    const minZoom = minZooms.length ? Math.max(...minZooms) : undefined;\n    const maxZoom = maxZooms.length ? Math.min(...maxZooms) : undefined;\n    return { minZoom, maxZoom };\n  }\n\n  private _init(item: TreeGroup | TreeLayer) {\n    this.initItem(item).then(() => {\n      this.emitter.emit('init');\n    });\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import type { WebMap, MainLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport type { Type } from '@nextgis/utils';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  adapterOptions?: Record<string, any>;\n  onLayerAdded?: <L extends MainLayerAdapter = MainLayerAdapter>(\n    layer: L,\n  ) => void;\n  createAdapter: (\n    firstShowAdapter: FirstShowAdapter,\n  ) => Promise<Type<MainLayerAdapter> | undefined>;\n}\n\ninterface FirstShowAdapter extends MainLayerAdapter {\n  loadLayer: () => Promise<MainLayerAdapter[]>;\n  destroyed: () => boolean;\n}\n\nexport async function createOnFirstShowAdapter({\n  webMap,\n  adapterOptions = {},\n  onLayerAdded,\n  createAdapter,\n}: CreateOnFirstShowAdapterOptions): Promise<Type<FirstShowAdapter>> {\n  class OnFirstShowAdapter implements MainLayerAdapter {\n    options: AdapterOptions = {};\n    layer: MainLayerAdapter[] = [];\n    _removed = false;\n    _creatingInProgress = false;\n\n    addLayer() {\n      return this.layer;\n    }\n\n    removeLayer() {\n      this._removed = true;\n      for (const l of this.layer) {\n        webMap.removeLayer(l);\n      }\n    }\n\n    destroyed() {\n      return this._removed;\n    }\n\n    async showLayer() {\n      this.options.visibility = true;\n      if (this.layer.length) {\n        for (const x of this.layer) {\n          await webMap.showLayer(x);\n        }\n      } else {\n        await this.loadLayer();\n      }\n    }\n\n    async hideLayer() {\n      this.options.visibility = false;\n      if (this.layer) {\n        for (const x of this.layer) {\n          await webMap.hideLayer(x);\n        }\n      }\n    }\n\n    async loadLayer() {\n      if (!this.layer.length && !this._creatingInProgress) {\n        this._creatingInProgress = true;\n        const Adapter = await createAdapter(this);\n        if (Adapter) {\n          const adapter = new Adapter(webMap.mapAdapter.map, {\n            ...adapterOptions,\n          });\n          const realLayer: MainLayerAdapter = await adapter.addLayer({\n            order: this.options.order,\n            headers: this.options.headers,\n            baselayer: this.options.baselayer,\n          });\n          if (onLayerAdded) {\n            onLayerAdded(adapter);\n          }\n          Object.assign(adapter.options, adapterOptions);\n          adapter.layer = realLayer;\n          if (this._removed) {\n            webMap.removeLayer(adapter);\n          }\n          this.layer.push(adapter);\n          if (this.options.visibility) {\n            await webMap.showLayer(adapter);\n          }\n          this._creatingInProgress = false;\n        }\n      }\n      return this.layer;\n    }\n  }\n  return OnFirstShowAdapter;\n}\n","import { Type } from '@nextgis/utils';\nimport { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport NgwConnector, { BasemapWebmapItem } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from './createAsyncAdapter';\nimport { createOnFirstShowAdapter } from './createOnFirstShowAdapter';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  item: BasemapWebmapItem;\n  adapterOptions?: Record<string, any>;\n  idPrefix?: string;\n}\n\nexport async function createOnFirstShowNgwAdapter({\n  webMap,\n  connector,\n  item,\n  adapterOptions = {},\n  idPrefix = 'first-show-adapter',\n}: CreateOnFirstShowAdapterOptions): Promise<Type<MainLayerAdapter>> {\n  const createAdapter = () => {\n    return createAsyncAdapter(\n      {\n        resource: item.resource_id,\n        adapterOptions: {\n          name: item.display_name,\n          opacity: item.opacity,\n        },\n      },\n      webMap,\n      connector,\n    );\n  };\n  const onLayerAdded = (adapter: MainLayerAdapter) => {\n    adapter.options.baselayer = false;\n    adapter.id = idPrefix + '-' + item.resource_id;\n  };\n\n  const OnFirstNgwShowAdapter = createOnFirstShowAdapter({\n    webMap,\n    adapterOptions,\n    onLayerAdded,\n    createAdapter,\n  });\n\n  return OnFirstNgwShowAdapter;\n}\n","import { Feature, Point } from 'geojson';\nimport { createGeoJsonFeature, fetchNgwLayerItem } from '@nextgis/ngw-kit';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\ninterface BookmarkItemOptions {\n  connector: NgwConnector;\n  resourceId: number;\n  item: FeatureItem;\n  labelField?: string;\n}\n\nexport class BookmarkItem {\n  readonly name: string;\n  readonly resourceId: number;\n  readonly item: FeatureItem;\n\n  private _extent?: LngLatBoundsArray;\n\n  constructor(private options: BookmarkItemOptions) {\n    this.resourceId = options.resourceId;\n    const item = options.item;\n    this.item = item;\n    if (options.labelField && item.fields) {\n      this.name = item.fields[options.labelField];\n    } else {\n      this.name = String(item.id);\n    }\n  }\n\n  extent(): CancelablePromise<LngLatBoundsArray> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return this.options.connector\n      .get('feature_layer.feature.item_extent', null, {\n        id: this.resourceId,\n        fid: this.item.id,\n      })\n      .then((resp) => {\n        const { minLat, minLon, maxLat, maxLon } = resp.extent;\n        const lonLat = [minLon, minLat, maxLon, maxLat];\n        this._extent = lonLat;\n        return lonLat;\n      });\n  }\n\n  geoJson(): CancelablePromise<Feature<Point, any>> {\n    if (this.item.geom) {\n      return CancelablePromise.resolve(createGeoJsonFeature(this.item));\n    } else {\n      return fetchNgwLayerItem({\n        resourceId: this.resourceId,\n        featureId: this.item.id,\n        connector: this.options.connector,\n        geom: true,\n        fields: null,\n        extensions: null,\n      }).then((onlyGeomItem) => {\n        const geom = onlyGeomItem.geom;\n        this.item.geom = geom;\n        return createGeoJsonFeature(this.item);\n      });\n    }\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  fetchNgwLayerItems,\n  WEBMAP_BASELAYER_ID_PREFIX,\n} from '@nextgis/ngw-kit';\n\nimport { NgwWebmapItem } from './NgwWebmapItem';\nimport { createOnFirstShowNgwAdapter } from './adapters/createOnFirstShowNgwAdapter';\nimport { ngwApiToAdapterOptions } from './utils/ngwApiToAdapterOptions';\nimport { getNgwWebmapExtent } from './utils/fetchNgwExtent';\nimport { updateImageParams } from './utils/utils';\nimport { BookmarkItem } from './BookmarkItem';\n\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type { Type, LngLatBoundsArray } from '@nextgis/utils';\nimport type { ItemOptions } from '@nextgis/item';\nimport type {\n  WebmapResource,\n  BasemapWebmap,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport type { WebMap, RasterAdapterOptions } from '@nextgis/webmap';\nimport type {\n  TreeGroup,\n  TreeLayer,\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  NgwWebmapAdapterOptions,\n  NgwWebmapLayerAdapterEvents,\n} from './interfaces';\n\nexport class NgwWebmapLayerAdapter<M = any> implements ResourceAdapter<M> {\n  layer?: NgwWebmapItem;\n\n  NgwWebmapItem: Type<NgwWebmapItem> = NgwWebmapItem;\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  webmapClassName = 'webmap';\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwWebmapLayerAdapterEvents\n  > = new EventEmitter();\n  protected _extent?: LngLatBoundsArray;\n\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n  private _webmapBaselayersIds: string[] = [];\n  private _lastActiveBaselayer?: string;\n\n  constructor(public map: M, public options: NgwWebmapAdapterOptions) {\n    const r = options.resourceId;\n\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: NgwWebmapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n    this.layer = await this._getWebMapLayerItem();\n    const extentConstrained = this.response?.webmap?.extent_constrained;\n    if (\n      this.options.useExtentConstrained &&\n      this._extent &&\n      extentConstrained\n    ) {\n      this.options.webMap.setView({ maxBounds: this._extent });\n    }\n    return this.layer;\n  }\n\n  removeLayer(): void {\n    const mapAdapter = this.options.webMap.mapAdapter;\n\n    this.getDependLayers().forEach((x) => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n\n    if (this._webmapBaselayersIds.length) {\n      for (const b of this._webmapBaselayersIds) {\n        this.options.webMap.removeLayer(b);\n      }\n      if (this._lastActiveBaselayer) {\n        this.options.webMap.showLayer(this._lastActiveBaselayer);\n      }\n    }\n\n    if (this.options.useExtentConstrained && this._extent) {\n      this.options.webMap.setView({ maxBounds: null });\n    }\n\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  async showLayer(): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  async hideLayer(): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  async setOpacity(val: number): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('opacity').set(val);\n    }\n  }\n\n  /** @deprecated use {@link NgwWebmapLayerAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getNgwWebmapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<NgwWebmapItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  getBookmarksResourceId(): number | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return webmap.bookmark_resource.id;\n    }\n  }\n\n  fetchBookmarks(): CancelablePromise<BookmarkItem[]> {\n    const bookmarkResId = this.getBookmarksResourceId();\n    const connector = this.options.connector;\n    if (bookmarkResId) {\n      return connector.getResourceOrFail(bookmarkResId).then((item) => {\n        const labelField = item.feature_layer?.fields.find(\n          (x) => x.label_field,\n        );\n        const keyname = labelField && labelField.keyname;\n        return fetchNgwLayerItems({\n          connector,\n          resourceId: bookmarkResId,\n          geom: false,\n          fields: keyname ? [keyname] : undefined,\n        }).then((items) => {\n          const bookmarks: BookmarkItem[] = [];\n          for (const i of items) {\n            const bookmark = new BookmarkItem({\n              item: i,\n              resourceId: bookmarkResId,\n              labelField: keyname,\n              connector,\n            });\n            bookmarks.push(bookmark);\n          }\n          return bookmarks;\n        });\n      });\n    }\n    throw new Error(\n      'Webmap was not loaded correctly, it is impossible to extract bookmarks',\n    );\n  }\n\n  async getIdentificationIds(): Promise<number[]> {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => b.id - a.id);\n      deps.forEach((x) => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  protected async _getWebMapLayerItem(): Promise<NgwWebmapItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<NgwWebmapItem>((resolve) => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.setViewDelay = this.options.setViewDelay;\n          options.order = this.options.order;\n          options.ratio = this.options.ratio;\n          options.crossOrigin = this.options.crossOrigin;\n          options.minZoom = this.options.minZoom;\n          options.maxZoom = this.options.maxZoom;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          options.popupOptions = this.options.popupOptions;\n          const layer = new this.NgwWebmapItem(\n            this.options.webMap,\n            webmap.root_item,\n            options,\n            this.options.connector,\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    const data = await this.options.connector.getResource(id);\n    if (data) {\n      this.response = data;\n      const webmap = data[\n        this.webmapClassName as keyof ResourceItem\n      ] as WebmapResource;\n      this._setupBaselayers(data);\n      if (webmap) {\n        this._extent = [\n          webmap.extent_left,\n          webmap.extent_bottom,\n          webmap.extent_right,\n          webmap.extent_top,\n        ];\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    }\n  }\n\n  private _setupBaselayers(data: ResourceItem) {\n    const webMap = this.options.webMap;\n    const basemap = this.options.useBasemap ?? true;\n    if (basemap) {\n      if (data.basemap_webmap && data.basemap_webmap.basemaps.length) {\n        const activeBaselayer = webMap.getActiveBaseLayer();\n        this._lastActiveBaselayer = activeBaselayer\n          ? activeBaselayer.id\n          : undefined;\n        this._setBasemaps(data.basemap_webmap);\n      } else if (this.options.defaultBasemap) {\n        webMap.addBaseLayer('OSM', {\n          id: 'webmap-default-baselayer',\n          name: 'OpenStreetMap',\n        });\n      }\n    }\n  }\n\n  private _setBasemaps(baseWebmap: BasemapWebmap) {\n    const webMap = this.options.webMap;\n    // to avoid set many basemaps on init\n    let enabledAlreadySet = false;\n    for (const x of baseWebmap.basemaps) {\n      createOnFirstShowNgwAdapter({\n        webMap,\n        connector: this.options.connector,\n        item: x,\n        adapterOptions: { crossOrigin: this.options.crossOrigin },\n      }).then((adapter) => {\n        const visibility = enabledAlreadySet ? false : x.enabled;\n        if (x.enabled) {\n          enabledAlreadySet = true;\n        }\n        return webMap\n          .addBaseLayer(adapter, {\n            id: WEBMAP_BASELAYER_ID_PREFIX + x.resource_id,\n            name: x.display_name,\n            opacity: x.opacity,\n            visibility,\n          })\n          .then((l) => {\n            l.id && this._webmapBaselayersIds.push(l.id);\n          });\n      });\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem,\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map((x) =>\n            this._updateItemsParams(x, webMap, data),\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.connector.options.baseUrl +\n            '/api/component/render/image',\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = (params) =>\n          updateImageParams(params, resourceId);\n        const adapter = item.layer_adapter.toUpperCase() as NgwLayerAdapterType;\n        const layerAdapterOptions = ngwApiToAdapterOptions({\n          options: {\n            adapter,\n            resource: resourceId,\n          },\n          webMap,\n          baseUrl: this.options.connector.options.baseUrl || '',\n        }) as RasterAdapterOptions;\n        item = {\n          ...item,\n          ...layerAdapterOptions,\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      for (const x of layers) {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector.getResource(id).then((y) => {\n            if (y) {\n              const parentId = Number(y.resource.parent.id);\n              item.parentId = parentId;\n              return parentId;\n            }\n          });\n          promises.push(promise);\n        }\n      }\n      const ids = await Promise.all(promises);\n      return ids.filter((x) => x !== undefined);\n    }\n  }\n}\n","export const WEBMAP_BASELAYER_ID_PREFIX = 'webmap-baselayer';\n","import { fetchNgwResourceExtent } from './utils/fetchNgwExtent';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { ResourceItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport { FetchNgwLayerExtentOptions } from './interfaces';\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  protected _extent?: LngLatBoundsArray;\n\n  /** @deprecated use {@link NgwResource.getBounds} instead */\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    return this.getBounds();\n  }\n\n  async getBounds(\n    options?: FetchNgwLayerExtentOptions,\n  ): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await fetchNgwResourceExtent(\n        this.item,\n        this.connector,\n        options,\n      );\n      return this._extent;\n    }\n  }\n}\n","import { Feature } from 'geojson';\nimport { ResourceItem } from '@nextgis/ngw-connector';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem,\n): HTMLElement | string {\n  // @ts-ignore\n  if (__BROWSER__) {\n    const element = document.createElement('div');\n    if (item && item.feature_layer) {\n      item.feature_layer.fields.forEach((x) => {\n        if (x.grid_visibility) {\n          const value = feature.properties && feature.properties[x.keyname];\n          if (value) {\n            const propElem = document.createElement('div');\n            element.appendChild(propElem);\n            propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n          }\n        }\n      });\n    } else if (feature.properties) {\n      for (const p in feature.properties) {\n        const propElem = document.createElement('div');\n        element.appendChild(propElem);\n        propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n      }\n    }\n    return element;\n  } else {\n    return '';\n  }\n}\n","import { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy',\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions,\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach((x) => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport type { NgwLayerOptions } from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector,\n): Promise<number> {\n  const resource = options.resource;\n  const item = resource as ResourceItem;\n\n  // @ts-ignore @deprecated\n  let { keyname, resourceId } = options;\n\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else if (\n      item.resource &&\n      item.resource !== undefined &&\n      'resource' in item\n    ) {\n      resourceId = (resource as ResourceItem).resource.id;\n    } else {\n      // TODO: safe remove this case\n      resourceId = await resourceIdFromLayerOptions(resource as any, connector);\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResource(keyname);\n    if (resourceItem) {\n      resourceId = resourceItem.resource.id;\n    }\n  }\n  return resourceId;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { FetchNgwLayerCountOptions } from '../interfaces';\n\nexport function fetchNgwLayerCount({\n  connector,\n  resourceId,\n  cache = true,\n}: FetchNgwLayerCountOptions): CancelablePromise<number> {\n  return connector\n    .get(\n      'feature_layer.feature.count',\n      { cache },\n      {\n        id: resourceId,\n      },\n    )\n    .then((resp) => {\n      return resp.total_count;\n    });\n}\n","import { EventEmitter } from 'events';\nimport { debounce, LngLatBoundsArray } from '@nextgis/utils';\nimport { propertiesFilter } from '@nextgis/properties-filter';\n\nimport { createPopupContent } from '../utils/createPopupContent';\nimport { getLayerFilterOptions } from '../utils/getLayerFilterOptions';\nimport { fetchNgwExtent } from '../utils/fetchNgwExtent';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\nimport { fetchNgwLayerFeatureCollection } from '../utils/fetchNgwLayerFeatureCollection';\nimport { prepareNgwFieldsToPropertiesFilter } from '../utils/prepareNgwFieldsToPropertiesFilter';\n\nimport type { FeatureCollection } from 'geojson';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { Type } from '@nextgis/utils';\nimport type {\n  GeoJsonAdapterOptions,\n  VectorLayerAdapter,\n  FilterOptions,\n  LayerAdapter,\n} from '@nextgis/webmap';\nimport type {\n  NgwLayerOptions,\n  GetClassAdapterOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\nimport { fetchNgwLayerCount } from '../utils/fetchNgwLayerCount';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  props: GetClassAdapterOptions,\n): Promise<Type<VectorLayerAdapter>> {\n  const {\n    item,\n    webMap,\n    Adapter,\n    connector,\n    layerOptions,\n    addLayerOptionsPriority: alop,\n  } = props;\n  const addLayerOptionsPriority = alop ?? true;\n  const options = layerOptions as NgwLayerOptions<'GEOJSON'>;\n  const GeoJsonAdapter: Type<VectorLayerAdapter> =\n    Adapter || webMap.mapAdapter.layerAdapters.GEOJSON;\n\n  const _loadedIds: string[] = [];\n  let _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n  let _dataPromise: CancelablePromise<FeatureCollection> | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (options.adapterOptions?.popupOptions?.fromProperties) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const getData = async (\n    filters?: PropertiesFilter,\n    filterOpt?: NgwFeatureRequestOptions,\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: filterOpt };\n    _dataPromise = fetchNgwLayerFeatureCollection({\n      resourceId,\n      filters,\n      connector,\n      cache: true,\n      ...filterOpt,\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  class NgwGeoJsonAdapter extends GeoJsonAdapter {\n    emitter = new EventEmitter();\n    __onMapMove?: () => void;\n    __onMapMoveStart?: () => void;\n    __enableMapMoveListener?: (e: LayerAdapter) => void;\n    __disableMapMoveListener?: (e: LayerAdapter) => void;\n\n    async addLayer(opt: GeoJsonAdapterOptions) {\n      let needUpdate = !opt.data;\n      const waitFullLoad =\n        opt.waitFullLoad !== undefined ? opt.waitFullLoad : true;\n      if (options.id !== undefined) {\n        opt.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (options.adapterOptions) {\n        // TODO: remove addLayerOptionsPriority options/\n        // in some cases, addLayer options must be used,\n        // but in others factory method options needs first\n        if (addLayerOptionsPriority) {\n          opt = {\n            ...options.adapterOptions,\n            ...opt,\n          };\n        } else {\n          opt = {\n            ...opt,\n            ...options.adapterOptions,\n          };\n        }\n      }\n      if (opt.data && Object.keys(opt.data).length === 0) {\n        opt.data = undefined;\n        needUpdate = false;\n      }\n      const strategy = opt.strategy || undefined;\n      this.options.strategy = strategy;\n\n      const layer = super.addLayer(opt);\n      _lastFilterArgs = {\n        filters: opt.propertiesFilter,\n        options: getLayerFilterOptions(opt),\n      };\n      let updatePromise: Promise<any> | undefined;\n      if (needUpdate) {\n        updatePromise = this.updateLayer();\n      }\n      if (waitFullLoad && updatePromise) {\n        await updatePromise;\n      }\n      if (strategy && strategy.startsWith('BBOX') && !_fullDataLoad) {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    /** @deprecated use {@link NgwGeoJsonAdapter.getBounds} instead */\n    getExtent(): Promise<LngLatBoundsArray | undefined> {\n      return this.getBounds();\n    }\n\n    async getBounds(): Promise<LngLatBoundsArray | undefined> {\n      const hasData = this.getLayers && this.getLayers().length;\n      const strategy = this.options.strategy;\n      if (strategy?.startsWith('BBOX') || hasData) {\n        return fetchNgwExtent({ connector, resourceId: item.resource.id });\n      } else {\n        if (super.getBounds) {\n          return super.getBounds();\n        }\n      }\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      this.__onMapMoveStart = undefined;\n      abort();\n    }\n\n    getCount() {\n      return fetchNgwLayerCount({ connector, resourceId, cache: true });\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy?.startsWith('BBOX')) {\n        await webMap.onLoad('create');\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = webMap.getBounds();\n        const { minZoom, maxZoom } = this.options;\n        const zoom = webMap.getZoom();\n        if (zoom !== undefined) {\n          if (minZoom !== undefined && zoom < minZoom) {\n            return;\n          }\n          if (maxZoom !== undefined && zoom > maxZoom) {\n            return;\n          }\n          if (_fullDataLoad) {\n            return;\n          }\n        }\n      }\n      if (removed) {\n        return;\n      }\n      try {\n        this.emitter.emit('preupdate', filterArgs);\n        webMap._emitLayerEvent('layer:preupdate', options.id || '', filterArgs);\n\n        const data = await getData(filterArgs.filters, {\n          ...filterArgs.options,\n          srs: this.options.srs,\n        });\n        let newData: FeatureCollection = data;\n        const count = await this.getCount();\n\n        if (this.options.strategy === 'BBOX+') {\n          newData = {\n            type: 'FeatureCollection',\n            features: [],\n          };\n          for (const f of data.features) {\n            if (_loadedIds.indexOf(String(f.id)) === -1) {\n              _loadedIds.push(String(f.id));\n              newData.features.push(f);\n            }\n          }\n          _fullDataLoad = count !== undefined && _loadedIds.length >= count;\n          await webMap.addLayerData(this, newData);\n        } else {\n          _fullDataLoad = count !== undefined && data.features.length >= count;\n          await webMap.setLayerData(this, data);\n        }\n        this.emitter.emit('updated', data);\n        webMap._emitLayerEvent('layer:updated', options.id || '', {\n          data,\n          newData,\n          isFull: _fullDataLoad,\n        });\n      } catch (er) {\n        if (er instanceof Error && er.name !== 'CancelError') {\n          throw er;\n        }\n      }\n      if (super.updateLayer) {\n        super.updateLayer();\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions): Promise<void> {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter((e) => {\n          const props_ =\n            e.feature &&\n            e.feature.properties &&\n            prepareNgwFieldsToPropertiesFilter({ ...e.feature.properties });\n          if (props_) {\n            return propertiesFilter(props_, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await getData(filters, {\n          ...opt,\n          srs: this.options.srs,\n        });\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    private _addBboxEventListener() {\n      this.__enableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener(this);\n    }\n\n    private _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    private _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      this.__onMapMoveStart = abort;\n      webMap.emitter.on('movestart', this.__onMapMoveStart);\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    private _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.removeListener('moveend', this.__onMapMove);\n      }\n      if (this.__onMapMoveStart) {\n        webMap.emitter.removeListener('movestart', this.__onMapMoveStart);\n      }\n    }\n  }\n\n  return NgwGeoJsonAdapter;\n}\n","import { defined } from '@nextgis/utils';\n\nimport { ngwApiToAdapterOptions } from '../utils/ngwApiToAdapterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { Type } from '@nextgis/utils';\nimport type { ResourceItem, ResourceCls } from '@nextgis/ngw-connector';\nimport type { MainLayerAdapter, ImageAdapterOptions } from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  GetClassAdapterOptions,\n} from '../interfaces';\n\nexport async function createRasterAdapter({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  const resourceCls = item.resource.cls;\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    tmsclient_layer: 'IMAGE',\n  };\n  let adapter =\n    layerOptions.adapter ||\n    (resourceCls && clsAdapterAlias[resourceCls]) ||\n    'IMAGE';\n  if (adapter !== undefined) {\n    layerOptions.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const AdapterClass = webMap.mapAdapter.layerAdapters[\n    adapter\n  ] as Type<MainLayerAdapter>;\n  if (AdapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(\n      layerOptions,\n      connector,\n    );\n    return class RasterAdapter extends AdapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem = item;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = ngwApiToAdapterOptions({\n          options: layerOptions,\n          webMap,\n          baseUrl: connector.options.baseUrl || '',\n        });\n        if (opt) {\n          const layerAdapterOptions: ImageAdapterOptions = {\n            ...opt,\n            ...layerOptions.adapterOptions,\n            params: { resource: resourceId },\n            layers: opt.layers || String(resourceId),\n            resourceId: resourceId,\n          };\n          if (\n            layerOptions.adapterOptions &&\n            defined(layerOptions.adapterOptions.setViewDelay)\n          ) {\n            layerAdapterOptions.setViewDelay =\n              layerOptions.adapterOptions.setViewDelay;\n          }\n          this.options = { ...this.options, ...layerAdapterOptions };\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds(): Promise<number[]> {\n        if (this.item) {\n          if (adapter === 'MVT') {\n            return [this.item.resource.id];\n          }\n          const id = this.item.resource.parent.id;\n          if (defined(id)) {\n            return [id];\n          }\n        }\n        return [];\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","import { NgwWebmapLayerAdapter as NWLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { Type } from '@nextgis/utils';\nimport type { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createWebMapAdapter({\n  layerOptions: options,\n  webMap,\n  connector,\n}: GetClassAdapterOptions): Promise<Type<NWLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class NgwWebmapLayerAdapter extends NWLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        url: '',\n        webMap,\n        resourceId,\n        connector,\n      });\n    }\n  };\n}\n","import { QmsKit } from '@nextgis/qms-kit';\n\nimport type { Type } from '@nextgis/utils';\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createBasemapLayerAdapter({\n  webMap,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  if (item.basemap_layer) {\n    const qms = item.basemap_layer.qms;\n    const url = item.basemap_layer.url;\n    if (qms) {\n      const qms_ = JSON.parse(qms);\n      const adapter = Promise.resolve(\n        QmsKit.utils.createQmsAdapter(webMap, undefined, {\n          qms: qms_,\n          baselayer: true,\n        }),\n      );\n      return adapter;\n    } else if (url) {\n      const TileAdapter = webMap.mapAdapter.layerAdapters.TILE as Type<\n        MainLayerAdapter<any, any, TileAdapterOptions>\n      >;\n      if (TileAdapter) {\n        class BasemapTileAdapter extends TileAdapter {\n          async addLayer(opt: TileAdapterOptions) {\n            return super.addLayer({ ...opt, url });\n          }\n        }\n        return BasemapTileAdapter;\n      }\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport { WebMap } from '@nextgis/webmap';\nimport { Type, applyMixins } from '@nextgis/utils';\n\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\nimport { NgwResource } from '../NgwResource';\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createNgwWebmapAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { createBasemapLayerAdapter } from './createBasemapLayerAdapter';\n\nimport type {\n  GetClassAdapterCallback,\n  GetClassAdapterOptions,\n  GetClassAdapterByType,\n  ResourceAdapter,\n  NgwLayerOptions,\n  GetClassAdapter,\n  ClassAdapter,\n} from '../interfaces';\n\nexport const classAdapters: Record<string, GetClassAdapter> = {};\n\nconst supportCls: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'basemap_layer',\n  'vector_layer',\n  'raster_layer',\n  'postgis_layer',\n  'webmap',\n  // in tms branch\n  'tmsclient_layer',\n];\n\nasync function createAdapterFromFirstStyle({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions) {\n  const parent = item.resource.id;\n  const childrenStyles = await connector.getResourceChildren(parent);\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    return createAsyncAdapter(\n      { ...layerOptions, resource: firstStyle.resource.id },\n      webMap,\n      connector,\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: ClassAdapter | undefined;\n  let item: ResourceItem | undefined;\n  const adapterType = options.adapter;\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  if (resourceId) {\n    const resourceOptions = options as NgwLayerOptions;\n    const itemFromResOpt = resourceOptions.resource as ResourceItem;\n    if (\n      itemFromResOpt &&\n      itemFromResOpt.resource &&\n      itemFromResOpt.resource.id !== undefined\n    ) {\n      item = itemFromResOpt;\n    } else {\n      item = await connector.getResource(resourceId);\n    }\n    if (item) {\n      const cls = item.resource.cls;\n      const layerOptions: NgwLayerOptions = {\n        ...options,\n        resource: resourceId,\n      };\n\n      const adapterOptions: GetClassAdapterOptions = {\n        layerOptions,\n        webMap,\n        connector,\n        item,\n      };\n\n      if (supportCls.indexOf(cls) !== -1) {\n        if (cls === 'webmap') {\n          adapter = createWebMapAdapter(adapterOptions);\n        } else if (cls === 'vector_layer' || cls === 'postgis_layer') {\n          const type =\n            item.vector_layer &&\n            vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n          const adapterOptions_ =\n            adapterOptions.layerOptions.adapterOptions || {};\n          adapterOptions_.type = adapterOptions_.type || type;\n          adapterOptions.layerOptions.adapterOptions = adapterOptions_;\n          options.adapterOptions = adapterOptions;\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(adapterOptions);\n            } else {\n              return createAdapterFromFirstStyle(adapterOptions);\n            }\n          } else {\n            adapter = createGeoJsonAdapter(adapterOptions);\n          }\n        } else if (cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(adapterOptions);\n        } else if (cls === 'basemap_layer') {\n          adapter = createBasemapLayerAdapter(adapterOptions);\n        } else {\n          if (adapterType === 'GEOJSON') {\n            const parentItem = await connector.getResource(\n              item.resource.parent.id,\n            );\n            if (parentItem) {\n              const parentOptions: NgwLayerOptions = {\n                ...options,\n                resource: item.resource.parent.id,\n              };\n              adapter = createGeoJsonAdapter({\n                ...adapterOptions,\n                item: parentItem,\n                layerOptions: parentOptions,\n              });\n            }\n          } else {\n            adapter = createRasterAdapter(adapterOptions);\n          }\n        }\n      } else if (classAdapters[cls]) {\n        const getClassAdapter = classAdapters[cls];\n        let classAdapter: GetClassAdapterCallback | undefined;\n        if (adapterType && typeof classAdapter !== 'function') {\n          classAdapter = (getClassAdapter as GetClassAdapterByType)[\n            adapterType\n          ];\n        } else {\n          classAdapter = getClassAdapter as GetClassAdapterCallback;\n        }\n        if (classAdapter) {\n          adapter = classAdapter(adapterOptions);\n        }\n      } else {\n        throw `Resource class '${cls}' not yet supported.`;\n      }\n    } else {\n      throw 'Resource item is not found';\n    }\n  }\n\n  if (adapter) {\n    return adapter.then((x) => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        if (item) {\n          resourceAdapter.prototype.item = item;\n          resourceAdapter.prototype.resourceId = item.resource.id;\n          resourceAdapter.prototype.connector = connector;\n        }\n\n        applyMixins(resourceAdapter, [NgwResource], { replace: false });\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  isPropertyFilter,\n  PropertiesFilter,\n  PropertyFilter,\n} from '@nextgis/properties-filter';\nimport {\n  round,\n  defined,\n  degrees2meters,\n  isLngLatBoundsArray,\n  getBoundsCoordinates,\n} from '@nextgis/utils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type {\n  RequestItemAdditionalParams,\n  FeatureItem,\n} from '@nextgis/ngw-connector';\nimport type { LngLatArray, FeatureProperties } from '@nextgis/utils';\nimport type {\n  NgwFeatureRequestOptions,\n  FeatureRequestParams,\n  FetchNgwItemsOptions,\n} from '../interfaces';\n\nexport const FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson',\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    geometry,\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n  };\n  return feature;\n}\n\nexport function updateItemRequestParam<\n  P extends FeatureProperties = FeatureProperties,\n>(params: FeatureRequestParams, options: NgwFeatureRequestOptions<P>): void {\n  const { extensions, geom, fields, srs } = options;\n  params.extensions = extensions ? extensions.join(',') : '';\n  if (fields !== undefined) {\n    params.fields = Array.isArray(fields) ? fields.join(',') : '';\n  }\n  if (geom !== undefined) {\n    params.geom = geom ? 'yes' : 'no';\n    if (!geom) {\n      delete params.srs;\n      delete params.geom_format;\n    }\n  }\n  if (defined(srs)) {\n    params.srs = srs;\n  }\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nexport function createFeatureFieldFilterQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const queries: CancelablePromise<FeatureItem<P, G>[]>[] = getQueries<G, P>(\n    opt,\n  );\n\n  return CancelablePromise.all(queries).then((itemsParts) => {\n    // this list of ids used for optimization\n    const ids: number[] = [];\n    const items: FeatureItem<P, G>[] = [];\n    for (const part of itemsParts) {\n      for (const item of part) {\n        if (!ids.includes(item.id)) {\n          items.push(item);\n          ids.push(item.id);\n        }\n      }\n    }\n    const offset = opt.offset !== undefined ? opt.offset : 0;\n    const limit = opt.limit !== undefined ? opt.limit : items.length;\n    if (opt.offset || opt.limit) {\n      return items.splice(offset, limit);\n    }\n    return items;\n  });\n}\n\nfunction createParam(pf: PropertyFilter): [string, any] {\n  const [field, operation, value] = pf;\n  const isFldStr = field !== 'id' ? 'fld_' : '';\n  let vStart = '';\n  let vEnd = '';\n  const field_ = String(field)\n    .trim()\n    .replace(/^(%?)(.+?)(%?)$/, (m, a, b, c) => {\n      vStart = a;\n      vEnd = c;\n      return b;\n    });\n  const v = vStart + value + vEnd;\n  return [`${isFldStr}${field_}__${operation}`, v];\n}\n\nfunction getQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n  _queries: CancelablePromise<FeatureItem<P, G>[]>[] = [],\n  _parentAllParams: [string, any][] = [],\n): CancelablePromise<FeatureItem<P, G>[]>[] {\n  const { filters } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter((x) => Array.isArray(x)) as PropertyFilter[];\n\n  if (logic === 'any') {\n    for (const f of filters_) {\n      if (isPropertyFilter(f)) {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)],\n          }),\n        );\n      } else {\n        getQueries(\n          {\n            ...opt,\n            filters: f,\n          },\n          _queries,\n          [..._parentAllParams],\n        );\n      }\n    }\n  } else if (logic === 'all') {\n    const filters: [string, any][] = [];\n    const propertiesFilterList: PropertiesFilter[] = [];\n    for (const f of filters_) {\n      if (isPropertyFilter(f)) {\n        filters.push(createParam(f));\n      } else {\n        propertiesFilterList.push(f);\n      }\n    }\n\n    if (propertiesFilterList.length) {\n      for (const x of propertiesFilterList) {\n        getQueries(\n          {\n            ...opt,\n            filters: x,\n          },\n          _queries,\n          [..._parentAllParams, ...filters],\n        );\n      }\n    } else {\n      _queries.push(\n        fetchNgwLayerItemsRequest<G, P>({\n          ...opt,\n          paramList: [..._parentAllParams, ...filters],\n        }),\n      );\n    }\n  }\n  return _queries;\n}\n\nfunction createWktFromCoordArray(coord: LngLatArray[]): string {\n  const polygon = coord.map(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat).map((c) => round(c));\n    return x + ' ' + y;\n  });\n  return `POLYGON((${polygon.join(', ')}))`;\n}\n\nexport function fetchNgwLayerItemsRequest<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  const {\n    limit,\n    cache,\n    signal,\n    offset,\n    orderBy,\n    paramList,\n    connector,\n    geomFormat,\n    intersects,\n    resourceId,\n  } = options;\n  if (limit) {\n    if (limit !== Number.POSITIVE_INFINITY) {\n      params.limit = limit;\n    }\n  } else {\n    // Strict restriction on loading data from large layers\n    params.limit = 7000;\n  }\n  if (offset) {\n    params.offset = offset;\n  }\n  if (geomFormat) {\n    params.geom_format = geomFormat;\n  }\n  updateItemRequestParam(params, options);\n\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  if (Array.isArray(intersects)) {\n    const coordinates = isLngLatBoundsArray(intersects)\n      ? getBoundsCoordinates(intersects)\n      : intersects;\n\n    params.intersects = createWktFromCoordArray(coordinates);\n  } else if (typeof intersects === 'string') {\n    params.intersects = intersects;\n  }\n\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  const reqParams = {\n    id: resourceId,\n    ...params,\n  };\n\n  return connector.get(\n    'feature_layer.feature.collection',\n    { cache, signal },\n    reqParams,\n  ) as CancelablePromise<FeatureItem<P, G>[]>;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { WebmapResource, ResourceItem } from '@nextgis/ngw-connector';\nimport type {\n  FetchNgwLayerExtentOptions,\n  FetchNgwLayerItemExtentOptions,\n} from '../interfaces';\n\nexport function getNgwWebmapExtent(\n  webmap: WebmapResource,\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function fetchNgwLayerExtent({\n  resourceId,\n  connector,\n  cache = true,\n}: FetchNgwLayerExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get('layer.extent', { cache }, { id: resourceId })\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwLayerItemExtent({\n  resourceId,\n  featureId,\n  connector,\n  cache = true,\n}: FetchNgwLayerItemExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get(\n      'feature_layer.feature.item_extent',\n      { cache },\n      { id: resourceId, fid: featureId },\n    )\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwExtent(\n  options: FetchNgwLayerExtentOptions,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  return options.connector.getResource(options.resourceId).then((resource) => {\n    if (resource) {\n      return fetchNgwResourceExtent(resource, options.connector, options);\n    }\n  });\n}\n\n/** @deprecated use {@link fetchNgwExtent} instead */\nexport function fetchNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n  options?: FetchNgwLayerExtentOptions,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return CancelablePromise.resolve(getNgwWebmapExtent(item.webmap));\n  } else {\n    const resource = item.resource;\n    if (resource.cls && resource.cls.indexOf('style') !== -1) {\n      return connector.getResource(resource.parent.id).then((res) => {\n        if (res) {\n          return fetchNgwLayerExtent({\n            ...options,\n            resourceId: res.resource.id,\n            connector,\n          });\n        }\n      });\n    } else {\n      return fetchNgwLayerExtent({\n        ...options,\n        resourceId: resource.id,\n        connector,\n      });\n    }\n  }\n}\n","import { fetchNgwLayerItem } from './fetchNgwLayerItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FetchNgwItemOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>,\n>(options: FetchNgwItemOptions<P>): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerItem<G, P>(options).then((item) => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n","import { fetchNgwLayerFeatures } from './fetchNgwLayerFeatures';\n\nimport type { Geometry, FeatureCollection } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { FetchNgwItemsOptions } from '../interfaces';\n\nexport function fetchNgwLayerFeatureCollection<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemsOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatures<G, P>(options).then((features) => {\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features,\n    };\n    return featureCollection;\n  });\n}\n","import { fetchNgwLayerItems } from './fetchNgwLayerItems';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nimport type { Geometry, Feature } from 'geojson';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\n\nexport function fetchNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<Feature<G, P>[]> {\n  return fetchNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach((y) => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    return features;\n  });\n}\n","import { Geometry } from 'geojson';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createGeoJsonFeature,\n  FEATURE_REQUEST_PARAMS,\n  updateItemRequestParam,\n} from './featureLayerUtils';\n\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  NgwFeatureItemResponse,\n  FeatureRequestParams,\n  FetchNgwItemOptions,\n} from '../interfaces';\n\nexport function fetchNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G>> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  updateItemRequestParam(params, options);\n  const queryParams = {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params,\n  };\n  const cache = options.cache || true;\n  return options.connector\n    .get('feature_layer.feature.item', { cache }, queryParams)\n    .then((resp) => {\n      return {\n        ...resp,\n        toGeojson: () => {\n          if (resp.geom) {\n            return CancelablePromise.resolve(createGeoJsonFeature<G, P>(resp));\n          } else {\n            return fetchNgwLayerItem({\n              ...options,\n              geom: true,\n              fields: null,\n              extensions: null,\n            }).then((onlyGeomItem) => {\n              const geom = onlyGeomItem.geom;\n              return createGeoJsonFeature<G, P>({ ...resp, geom });\n            });\n          }\n        },\n      } as NgwFeatureItemResponse<P, G>;\n    });\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  createFeatureFieldFilterQueries,\n  fetchNgwLayerItemsRequest,\n} from './featureLayerUtils';\nimport { prepareNgwFieldsToPropertiesFilter } from './prepareNgwFieldsToPropertiesFilter';\n\nimport type { Geometry } from 'geojson';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport { FeatureProperties, isArray } from '@nextgis/utils';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { FetchNgwItemsOptions } from '../interfaces';\n\nexport function fetchNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({\n      ...options,\n      filters,\n    }).then((data) => {\n      const clientFilterValidate =\n        options.clientFilterValidate ?? isFilterWithAnyCase(filters);\n      // Additional client-side filter check\n      if (clientFilterValidate) {\n        data = data.filter((y) => {\n          const fields = prepareNgwFieldsToPropertiesFilter({\n            ...y.fields,\n            id: y.id,\n          });\n          const result = propertiesFilter(fields, filters);\n          return result;\n        });\n      }\n      return data;\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  } else {\n    return fetchNgwLayerItemsRequest<G, P>(options);\n  }\n}\n\nfunction isFilterWithAnyCase(filters: PropertiesFilter): boolean {\n  if (filters[0] === 'any') {\n    return true;\n  }\n  for (let i = 1; i < filters.length; i++) {\n    const p = filters[i];\n    if (isArray(p)) {\n      const deep = isFilterWithAnyCase(p);\n      if (deep) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport { CompanyLogoOptions } from '../interfaces';\n\nexport async function getCompanyLogo(\n  connector: NgwConnector,\n  options?: CompanyLogoOptions,\n): Promise<HTMLElement | undefined> {\n  const settings = await connector.get('pyramid.settings', null, {\n    component: 'pyramid',\n  });\n  if (settings && settings.company_logo && settings.company_logo.enabled) {\n    const anchor = document.createElement('a');\n    anchor.style.position = 'absolute';\n    anchor.style.bottom = '0';\n    anchor.style.right = '0';\n    anchor.style.padding = options?.padding ?? '10px';\n    anchor.className = 'ngw-map-logo';\n    if (options && options.cssClass) {\n      anchor.className += ' ' + options.cssClass;\n    }\n    const img = new Image();\n    img.style.maxHeight = '100px';\n    img.style.maxWidth = '100px';\n    img.src = '';\n    try {\n      const src = await connector.get('pyramid.company_logo', {\n        responseType: 'blob',\n      });\n      const urlCreator = window.URL || window.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(src as any);\n      img.src = imageUrl;\n    } catch (er) {\n      console.warn(er);\n    }\n\n    if (\n      settings.company_logo.link !== null &&\n      settings.company_logo.link.trim() !== ''\n    ) {\n      anchor.href = settings.company_logo.link;\n      anchor.target = '_blank';\n      if (settings.company_logo.link.search(/:\\/\\/nextgis/) !== -1) {\n        img.alt = 'Get your own Web GIS at nextgis.com';\n      }\n    }\n    anchor.appendChild(img);\n    return anchor;\n  }\n}\n","import {\n  fetchNgwLayerItem,\n  IdentifyItemOptions,\n  fetchNgwLayerItemExtent,\n} from '.';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { NgwFeatureItemResponse } from '.';\nimport type { GeoJsonObject, Geometry, Feature } from 'geojson';\nimport type {\n  VectorLayerResourceItem,\n  FeatureItemExtensions,\n  FeatureResource,\n  LayerFeature,\n} from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureProperties, LngLatBoundsArray } from '@nextgis/utils';\nimport type { FetchNgwItemOptions } from './interfaces';\n\nexport class IdentifyItem<F = FeatureProperties, G extends Geometry = Geometry>\n  implements LayerFeature\n{\n  readonly id: number;\n  readonly label: string;\n  readonly layerId: number;\n  readonly parent: string;\n  readonly fields: FeatureProperties;\n  geom?: GeoJsonObject;\n  extensions?: FeatureItemExtensions;\n\n  private connector: NgwConnector;\n  private _item?: NgwFeatureItemResponse<F, G>;\n  private _geojson?: Feature<G, F>;\n  private _resource?: VectorLayerResourceItem;\n  private _extent?: LngLatBoundsArray;\n\n  constructor(options: IdentifyItemOptions) {\n    const f = options.feature;\n    this.id = f.id;\n    this.geom = f.geom;\n    this.label = f.label;\n    this.parent = f.parent;\n    this.fields = f.fields;\n    this.layerId = f.layerId;\n    this.connector = options.connector;\n  }\n\n  identify(\n    options: Partial<FetchNgwItemOptions<F>> = {},\n  ): CancelablePromise<NgwFeatureItemResponse<F, G>> {\n    if (this._item) {\n      return CancelablePromise.resolve(this._item);\n    }\n    return fetchNgwLayerItem<G, F>({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n      fields: null,\n      extensions: ['attachment', 'description'],\n      ...options,\n    }).then((resp) => {\n      this._item = resp;\n      this.geom = resp.geom;\n      this.extensions = resp.extensions;\n      return resp;\n    });\n  }\n\n  resource(): CancelablePromise<FeatureResource> {\n    if (this._resource) {\n      return CancelablePromise.resolve(this._resource.feature_layer);\n    }\n    return this.connector.getResource(this.layerId).then((resp) => {\n      this._resource = resp as VectorLayerResourceItem;\n      return this._resource.feature_layer;\n    });\n  }\n\n  getBounds(): CancelablePromise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return fetchNgwLayerItemExtent({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n    });\n  }\n\n  geojson(): CancelablePromise<Feature<G, F>> {\n    if (this._geojson) {\n      return CancelablePromise.resolve(this._geojson);\n    }\n    return this.identify().then((resp) => {\n      return resp.toGeojson().then((geojson) => {\n        this._geojson = geojson;\n        return geojson;\n      });\n    });\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  JsonMap,\n  degrees2meters,\n  deprecatedMapClick,\n  getCirclePolygonCoordinates,\n} from '@nextgis/utils';\nimport { IdentifyItem } from '../IdentifyItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type { Geometry, Feature, Position } from 'geojson';\nimport type { MapClickEvent } from '@nextgis/webmap';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type {\n  LayerFeature,\n  FeatureLayersIdentify,\n} from '@nextgis/ngw-connector';\nimport type {\n  FeatureIdentifyRequestOptions,\n  FeatureLayerIdentifyOptions,\n  GetIdentifyGeoJsonOptions,\n  IdentifyRequestOptions,\n  NgwFeatureItemResponse,\n  IdentifyItemOptions,\n  NgwIdentifyItem,\n} from '../interfaces';\n\nexport function getIdentifyItems(\n  identify: FeatureLayersIdentify & { resources?: number[] },\n  multiple = false,\n): NgwIdentifyItem[] {\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort((a, b) => {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const identifyItem = identify[l];\n    if ('features' in identifyItem) {\n      const layerFeatures = identifyItem.features;\n      const resourceId = Number(l);\n      const featureParams: NgwIdentifyItem[] = createParamsFromFeatures(\n        layerFeatures,\n        resourceId,\n        multiple,\n      );\n      if (featureParams.length) {\n        paramsList.push(...featureParams);\n        if (!multiple) {\n          break;\n        }\n      }\n    }\n  }\n  return paramsList;\n}\n\nfunction createParamsFromFeatures(\n  features: LayerFeature[],\n  resourceId: number,\n  multiple: boolean,\n): NgwIdentifyItem[] {\n  const featureParams: NgwIdentifyItem[] = [];\n  for (const feature of features) {\n    const params = {\n      featureId: feature.id,\n      resourceId,\n      feature,\n    };\n    featureParams.push(params);\n    if (!multiple) {\n      break;\n    }\n  }\n  return featureParams;\n}\n\nexport function fetchIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  const { connector, identify, requestOptions } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      if ('features' in item) {\n        const withGeom = item.features.find((x) => x.geom);\n\n        if (withGeom && withGeom.geom) {\n          const geom = withGeom.geom as Geometry;\n          return CancelablePromise.resolve(\n            createGeoJsonFeature({\n              ...withGeom,\n              geom,\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerFeature({ ...requestOptions, connector, ...params[0] });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\nexport function fetchIdentifyItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: GetIdentifyGeoJsonOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n  const { connector, identify } = options;\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerItem<G, P>({\n      connector,\n      ...options.requestOptions,\n      ...params[0],\n    });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\n/**\n * @deprecated use {@link fetchIdentifyGeoJson} instead\n */\nexport function getIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  return fetchIdentifyGeoJson(options);\n}\n\nexport function featureLayerIdentify(\n  options: FeatureLayerIdentifyOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  const { geom, signal, cache } = options;\n  let geom_: Position[] = [];\n  if (Array.isArray(geom)) {\n    geom_ = geom;\n  } else {\n    const polygon =\n      geom.type === 'Feature'\n        ? geom.geometry\n        : geom.type === 'Polygon'\n        ? geom\n        : false;\n    if (polygon) {\n      geom_ = polygon.coordinates[0];\n    }\n  }\n  if (geom_) {\n    // create wkt string\n    const polygonStr: string[] = [];\n\n    for (const [lng, lat] of geom_) {\n      const [x, y] = degrees2meters(lng, lat);\n      polygonStr.push(x + ' ' + y);\n    }\n\n    const wkt = `POLYGON((${polygonStr.join(', ')}))`;\n\n    const layers: number[] = options.layers;\n\n    const data: FeatureIdentifyRequestOptions = {\n      geom: wkt,\n      srs: 3857,\n      layers,\n    };\n\n    return options.connector.post('feature_layer.identify', {\n      data,\n      signal,\n      cache,\n    });\n  } else {\n    throw new Error('Not valid geometry format to make intersection');\n  }\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  deprecatedMapClick(ev);\n  const [lng, lat] = ev.lngLat;\n  const { geom, radius, signal, cache } = options;\n  const geom_ = geom ?? getCirclePolygonCoordinates(lng, lat, radius);\n\n  return featureLayerIdentify({ ...options, geom: geom_, signal, cache });\n}\n\nexport function createIdentifyItem<\n  F = FeatureProperties,\n  G extends Geometry = Geometry,\n>(opt: IdentifyItemOptions): IdentifyItem<F, G> {\n  return new IdentifyItem<F, G>(opt);\n}\n","import { updateImageParams } from './utils';\n\nimport type {\n  RasterAdapterOptions,\n  ImageAdapterOptions,\n  WmsAdapterOptions,\n  MvtAdapterOptions,\n  WebMap,\n} from '@nextgis/webmap';\nimport type { NgwLayerOptions, TileNoData } from '../interfaces';\n\nexport interface GetLayerAdapterOptions {\n  options: NgwLayerOptions;\n  webMap?: WebMap;\n  baseUrl?: string;\n}\n\nexport interface GetImageAdapterOptionsParams {\n  resourceId: number | number[];\n  baseUrl?: string;\n  nd?: TileNoData;\n  headers: any;\n}\n\nexport function getImageAdapterOptions({\n  resourceId,\n  baseUrl,\n  nd,\n  headers,\n}: GetImageAdapterOptionsParams): ImageAdapterOptions {\n  const url = baseUrl + '/api/component/render/image';\n  const params: Record<string, any> = { resource: resourceId };\n  if (nd) {\n    params.nd = nd;\n  }\n  return {\n    url,\n    resourceId,\n    headers,\n    params,\n    updateWmsParams: (params_: Record<string, any>) => {\n      if (nd) {\n        params_.nd = nd;\n      }\n      return updateImageParams(params_, resourceId);\n    },\n  } as ImageAdapterOptions;\n}\n\nexport function ngwApiToAdapterOptions({\n  options,\n  webMap,\n  baseUrl,\n}: GetLayerAdapterOptions):\n  | MvtAdapterOptions\n  | RasterAdapterOptions\n  | ImageAdapterOptions\n  | undefined {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap && webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = options.resource;\n  const nd: TileNoData = options.tileNoData ? options.tileNoData : 200;\n\n  if (typeof resourceId === 'number') {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        return getImageAdapterOptions({\n          resourceId,\n          headers: options.headers,\n          nd,\n          baseUrl,\n        });\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      const adapterOptions = options.adapterOptions as WmsAdapterOptions;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: adapterOptions && adapterOptions.layers,\n        headers: options.headers,\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification ?? 6);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url,\n        sourceLayer: 'ngw:' + resourceId,\n        featureIdName: '$id',\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'MODEL_3D') {\n      url = baseUrl + `/api/component/model_3d/${resourceId}/data.glb`;\n      return { url };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId +\n        '&nd=' +\n        nd;\n      return { url, adapter };\n    }\n  } else if (resourceId !== undefined) {\n    throw new Error(\n      'Option `resource` must be number, not ' + typeof resourceId,\n    );\n  } else {\n    console.log('Option `resource` not set');\n  }\n}\n\n/** @deprecated use {@link ngwApiToAdapterOptions} instead */\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n): RasterAdapterOptions | ImageAdapterOptions | undefined {\n  return ngwApiToAdapterOptions({ options, webMap, baseUrl });\n}\n","import { isObject, defined } from '@nextgis/utils';\nimport type { NgwDateFormat, NgwDateTimeFormat } from '@nextgis/ngw-connector';\n\nexport function prepareNgwFieldsToPropertiesFilter(\n  fields: Record<string, any>,\n): Record<string, any> {\n  let f: keyof typeof fields;\n  for (f in fields) {\n    const field = fields[f];\n    if (isObject(field)) {\n      const date = field as NgwDateFormat | NgwDateTimeFormat;\n      if (defined(date.year) && defined(date.month) && defined(date.day)) {\n        const dt: [number, number, number, number?, number?, number?] = [\n          date.year,\n          date.month - 1,\n          date.day,\n        ];\n        if ('hour' in date) {\n          [date.hour, date.minute, date.second].forEach((x) => {\n            dt.push(x);\n          });\n        }\n        fields[f] = new Date(...dt).toISOString();\n      }\n    } else if (f === 'id' && typeof field === 'string') {\n      fields[f] = field.split(',').map(Number);\n    }\n  }\n  return fields;\n}\n","import NgwConnector, { GeometryType } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../adapters/createAsyncAdapter';\nimport { NgwWebmapLayerAdapter } from '../NgwWebmapLayerAdapter';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, VectorAdapterLayerType } from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwLayerOptions,\n  NgwWebmapAdapterOptions,\n} from '../interfaces';\n\nexport function updateImageParams(\n  params: Record<string, any>,\n  resourceId: number | number[],\n): Record<string, any> {\n  const { bbox, width, height, nd } = params;\n  return {\n    resource: Array.isArray(resourceId) ? resourceId.join(',') : resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now(),\n    nd: nd ?? 200,\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'point',\n  LINESTRING: 'line',\n  POLYGON: 'polygon',\n  MULTIPOINT: 'point',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'polygon',\n  POINTZ: 'point',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'polygon',\n  MULTIPOINTZ: 'point',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'polygon',\n};\n\nexport function createNgwLayerAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, connector);\n}\n\n/** @deprecated use {@link createNgwLayerAdapter} instead */\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  return createNgwLayerAdapter(options, webMap, connector);\n}\n\nexport interface ExtendNgwWebmapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendNgwWebmapLayerAdapter(\n  opt: ExtendNgwWebmapLayerAdapterOptions,\n): Type<NgwWebmapLayerAdapter> {\n  class A extends NgwWebmapLayerAdapter {\n    constructor(map: any, options: NgwWebmapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth(): number {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number): number {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 0): number {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n\n  const centerLat = lat;\n  const crsScale =\n    (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n  const zoom = getZoomFromScale(crsScale);\n  return zoom;\n\n  // return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n"],"names":["NgwKit","options","this","connector","url","baseUrl","Error","NgwConnector","auth","webMap","resourceId","resourceIds","length","r","addLayer","NgwWebmapLayerAdapter","visibility","fit","pixelRadius","layer","Promise","resolve","_getLayerAdapter","name","createAdapter","webmap","_createAdapter","extendNgwWebmapLayerAdapter","cls","adapter","classAdapters","WebmapLayerOpacityPropertyHandler","item","undefined","opacity","value","isGroup","_value","_prepareValue","getChildren","property","properties","propagation","set","update","get","val","getParents","reduce","s","x","prop","getValue","setLayerOpacity","Number","BaseProperty","NgwWebmapItem","parent","noInit","EventEmitter","tree","setParent","item_type","_rootDescendantsCount","_sumUp","children","root","getRoot","initProperties","_init","i","getItemOptions","setNewLayer","l","_layer","constructor","addChild","layer_adapter","toUpperCase","GetAdapterFromLayerType","getAdapter","then","newLayer","reject","transparency","layer_transparency","headers","crossOrigin","setViewDelay","params","resource","order","subOrder","drawOrderEnabled","draw_order_position","id","subLevel","String","padStart","popupOptions","_getZoomRange","maxZoom","minZoom","objectAssign","updateWmsParams","ratio","minScale","layer_min_scale_denom","maxScale","layer_max_scale_denom","reverse","scale","setScaleRatio","minZoomWebmap","maxZoomWebmap","minZoomLayer","_mapScaleToZoomLevel","maxZoomLayer","minZooms","filter","Boolean","maxZooms","Math","max","min","initItem","emitter","emit","totalValue","child","ngwWebmapItem","Item","type","getProperty","treeSome","layer_enabled","onSet","showLayer","hideLayer","handler","createOnFirstShowAdapter","adapterOptions","onLayerAdded","OnFirstShowAdapter","_removed","removeLayer","loadLayer","_creatingInProgress","Adapter","mapAdapter","map","baselayer","realLayer","Object","assign","push","idPrefix","OnFirstNgwShowAdapter","resource_id","createAsyncAdapter","display_name","BookmarkItem","labelField","fields","_extent","CancelablePromise","fid","resp","extent","minLat","minLon","maxLat","lonLat","maxLon","geom","createGeoJsonFeature","fetchNgwLayerItem","featureId","extensions","onlyGeomItem","Array","isArray","_getWebMapLayerItem","extentConstrained","response","extent_constrained","useExtentConstrained","setView","maxBounds","getDependLayers","forEach","_webmapBaselayersIds","b","_lastActiveBaselayer","_webmapLayersIds","getBounds","getNgwWebmapExtent","getDescendants","bookmark_resource","bookmarkResId","getBookmarksResourceId","getResourceOrFail","feature_layer","find","label_field","keyname","fetchNgwLayerItems","items","bookmarks","bookmark","visibleLayers","ids","_getWebMapIds","sort","a","parentId","visible","isBlocked","getWebMapConfig","root_item","getAuthorizationHeaders","draw_order_enabled","on","getResource","data","webmapClassName","_setupBaselayers","extent_left","extent_bottom","extent_right","extent_top","_updateItemsParams","useBasemap","basemap_webmap","basemaps","activeBaselayer","getActiveBaseLayer","_setBasemaps","defaultBasemap","addBaseLayer","baseWebmap","enabledAlreadySet","createOnFirstShowNgwAdapter","enabled","fixUrlStr","layer_style_id","updateImageParams","layerAdapterOptions","ngwApiToAdapterOptions","webMapItem","layers","promises","promise","y","all","NgwResource","fetchNgwResourceExtent","createPopupContent","feature","element","document","createElement","grid_visibility","propElem","appendChild","innerHTML","p","filterOptionsKeys","getLayerFilterOptions","filterOptions","opt","resourceIdFromLayerOptions","resourceItem","fetchNgwLayerCount","cache","total_count","createGeoJsonAdapter","props","layerOptions","alop","addLayerOptionsPriority","GeoJsonAdapter","layerAdapters","GEOJSON","_loadedIds","_fullDataLoad","fromProperties","getData","filters","filterOpt","abort","_lastFilterArgs","_dataPromise","fetchNgwLayerFeatureCollection","removed","cancel","NgwGeoJsonAdapter","needUpdate","waitFullLoad","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","keys","strategy","propertiesFilter","updatePromise","updateLayer","startsWith","_addBboxEventListener","hasData","getLayers","fetchNgwExtent","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","__onMapMoveStart","filterArgs","onLoad","intersects","zoom","getZoom","_emitLayerEvent","srs","newData","getCount","count","features","f","indexOf","addLayerData","setLayerData","isFull","e","props_","prepareNgwFieldsToPropertiesFilter","setData","clearLayer","_addMoveEventListener","debounce","removeListener","createRasterAdapter","resourceCls","clsAdapterAlias","wmsserver_service","tmsclient_layer","getLayerAdapters","IMAGE","AdapterClass","_options","defined","addOptions","createWebMapAdapter","NWLayerAdapter","createBasemapLayerAdapter","basemap_layer","qms","qms_","JSON","parse","QmsKit","TileAdapter","TILE","BasemapTileAdapter","supportCls","createAdapterFromFirstStyle","getResourceChildren","childrenStyles","firstStyle","adapterType","itemFromResOpt","adapterOptions_","parentItem","parentOptions","getClassAdapter","classAdapter","resourceAdapter","prototype","applyMixins","replace","FEATURE_REQUEST_PARAMS","geom_format","geometry","updateItemRequestParam","join","createFeatureFieldFilterQueries","queries","getQueries","itemsParts","includes","offset","limit","splice","createParam","pf","field","operation","isFldStr","vStart","vEnd","field_","trim","m","c","v","_queries","_parentAllParams","logic","filters_","isPropertyFilter","fetchNgwLayerItemsRequest","paramList","propertiesFilterList","polygon","signal","orderBy","geomFormat","POSITIVE_INFINITY","order_by","coordinates","isLngLatBoundsArray","getBoundsCoordinates","lng","lat","degrees2meters","round","reqParams","bottom","left","top","right","fetchNgwLayerExtent","fetchNgwLayerItemExtent","res","fetchNgwLayerFeature","fetchNgwLayerFeatures","queryParams","toGeojson","clientFilterValidate","isFilterWithAnyCase","getCompanyLogo","component","settings","company_logo","anchor","style","position","padding","className","cssClass","img","Image","maxHeight","maxWidth","src","responseType","urlCreator","window","URL","webkitURL","imageUrl","createObjectURL","console","warn","link","href","target","search","alt","IdentifyItem","label","layerId","_item","_resource","_geojson","identify","geojson","getIdentifyItems","multiple","resources","paramsList","isNaN","sortingArr","fry","identifyItem","layerFeatures","featureParams","createParamsFromFeatures","fetchIdentifyGeoJson","requestOptions","withGeom","fetchIdentifyItem","sendIdentifyRequest","ev","deprecatedMapClick","lngLat","radius","geom_","getCirclePolygonCoordinates","polygonStr","post","featureLayerIdentify","createIdentifyItem","isImageAllowed","nd","tileNoData","params_","getImageAdapterOptions","format","version","simplification","sourceLayer","featureIdName","log","isObject","date","year","month","day","dt","hour","minute","second","Date","toISOString","split","bbox","width","height","size","timestamp","now","_pixelsInMeter","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","createNgwLayerAdapter","pixelsInMeterWidth","div","cssText","body","px","offsetWidth","removeChild","getMapWidthForLanInMeters","PI","cos","getZoomFromScale","LN2","centerLat","crsScale"],"sourceRoot":""}