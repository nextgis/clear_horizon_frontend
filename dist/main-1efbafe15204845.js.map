{"version":3,"file":"main-1efbafe15204845.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/webmap/src/utils/geometryTypes.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/utils/updateGeoJsonAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/components/keys/KeysCodes.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/components/keys/Keys.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/components/mapStates/StateItem.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/components/mapStates/CenterState.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/components/mapStates/ZoomState.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/WebMapMain.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/utils/clearObject.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/WebMapLayers.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/components/controls/createToggleControl.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/WebMapControls.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/container.ts","webpack://clear_horizon/./@nextgis/packages/webmap/src/WebMap.ts"],"sourcesContent":["import type {\n  GeoJsonObject,\n  GeoJsonGeometryTypes,\n  FeatureCollection,\n  GeometryCollection,\n  Feature,\n} from 'geojson';\n\n/**\n * @internal\n */\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[],\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName;\n  for (const c in counts) {\n    const count = maxName !== undefined ? counts[maxName] : 0;\n    if (counts[c] > (count || 0)) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\n/**\n * @internal\n */\nexport function detectGeometryType(\n  geojson: GeoJsonObject,\n): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type,\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type,\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n","import { isPaint } from '@nextgis/paint';\nimport { detectGeometryType } from './geometryTypes';\n\nimport type {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n} from '../interfaces/LayerAdapter';\n\n/**\n * @internal\n */\nexport const paintTypeAlias: Record<VectorAdapterLayerType, any> = {\n  polygon: 'path',\n  line: 'path',\n  point: 'circle',\n};\n\n/**\n * @internal\n */\nexport const typeAlias: { [x: string]: VectorAdapterLayerType } = {\n  Point: 'point',\n  LineString: 'line',\n  MultiPoint: 'point',\n  Polygon: 'polygon',\n  MultiLineString: 'line',\n  MultiPolygon: 'polygon',\n};\n\n/**\n * @internal\n */\nexport function updateGeoJsonAdapterOptions<\n  O extends GeoJsonAdapterOptions = GeoJsonAdapterOptions,\n>(opt: O): O {\n  if (opt.data) {\n    const geomType = typeAlias[detectGeometryType(opt.data)];\n    const p = opt.paint;\n    if (p && isPaint(p)) {\n      // define parameter if not specified\n      p.type = p.type\n        ? p.type\n        : geomType === 'polygon' || geomType === 'line'\n        ? 'path'\n        : 'html' in p || 'className' in p\n        ? 'icon'\n        : paintTypeAlias[geomType];\n    }\n    opt.type = opt.type || geomType;\n  }\n  return opt;\n}\n","export class KeyCodes {\n  'backspace' = 8;\n  'tab' = 9;\n  'enter' = 13;\n  'shift' = 16;\n  'ctrl' = 17;\n  'alt' = 18;\n  'pause/break' = 19;\n  'caps_lock' = 20;\n  'escape' = 27;\n  'page_up' = 33;\n  'page_down' = 34;\n  'end' = 35;\n  'home' = 36;\n  'left_arrow' = 37;\n  'up_arrow' = 38;\n  'right_arrow' = 39;\n  'down_arrow' = 40;\n  'insert' = 45;\n  'delete' = 46;\n  'left_window_key' = 91;\n  'right_window_key' = 92;\n  'select_key' = 93;\n  'numpad_0' = 96;\n  'numpad_1' = 97;\n  'numpad_2' = 98;\n  'numpad_3' = 99;\n  'numpad_4' = 100;\n  'numpad_5' = 101;\n  'numpad_6' = 102;\n  'numpad_7' = 103;\n  'numpad_8' = 104;\n  'numpad_9' = 105;\n  'multiply' = 106;\n  'add' = 107;\n  'subtract' = 109;\n  'decimal_point' = 110;\n  'divide' = 111;\n  'f1' = 112;\n  'f2' = 113;\n  'f3' = 114;\n  'f4' = 115;\n  'f5' = 116;\n  'f6' = 117;\n  'f7' = 118;\n  'f8' = 119;\n  'f9' = 120;\n  'f10' = 121;\n  'f11' = 122;\n  'f12' = 123;\n  'num_lock' = 144;\n  'scroll_lock' = 145;\n  'semi-colon' = 186;\n  'equal_sign' = 187;\n  ',' = 188; // \"comma\";\n  '-' = 189; // \"dash\";\n  '.' = 190; // \"period\";\n  '/' = 191; // \"forward slash\";\n  '`' = 192; // \"grave accent\";\n  '[' = 219; // \"open bracket\";\n  '\\\\' = 220; // \"back slash\";\n  ']' = 221; // \"close braket\";\n  \"'\" = 222; // \"single quote\"\n}\n","import { KeyCodes } from './KeysCodes';\n\n/**\n * @param {string} key - key symbol\n * @param {string} func - action on key press\n * @param {number} [keyCode] - key code for special button like tab\n *\n * @export\n * @interface KeyControl\n */\nexport interface KeyControl {\n  key?: string;\n  keyCode?: number;\n  func: () => void;\n}\n\nexport class Keys {\n  keyCodeAlias = new KeyCodes();\n\n  keys: { [keyCode: number]: boolean } = {};\n\n  private _windowOnFocus: () => void;\n  private _keysPressed: (e: KeyboardEvent) => void;\n  private _keysReleased: (e: KeyboardEvent) => void;\n\n  constructor() {\n    this._windowOnFocus = this.windowOnFocus.bind(this);\n    this._keysPressed = this.keysPressed.bind(this);\n    this._keysReleased = this.keysReleased.bind(this);\n    this.addKeyboardEventsListener();\n  }\n\n  pressed(keyName: keyof KeyCodes): boolean {\n    const code = this.keyCodeAlias[keyName];\n    return !!code && this.keys[code];\n  }\n\n  addKeyboardEventsListener(): void {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('focus', this._windowOnFocus, false);\n      window.addEventListener('keydown', this._keysPressed, false);\n      window.addEventListener('keyup', this._keysReleased, false);\n    }\n  }\n\n  removeKeyboardEventsListener(): void {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('focus', this._windowOnFocus, false);\n      window.removeEventListener('keydown', this._keysPressed, false);\n      window.removeEventListener('keyup', this._keysReleased, false);\n    }\n  }\n\n  private keysPressed(e: KeyboardEvent) {\n    e.stopPropagation();\n    if (!this.keys[e.keyCode]) {\n      this.keys[e.keyCode] = true;\n    }\n  }\n\n  private keysReleased(e: KeyboardEvent) {\n    e.stopPropagation();\n    this.keys[e.keyCode] = false;\n  }\n\n  private windowOnFocus() {\n    this.keys = {};\n  }\n}\n","import type { WebMap } from '../../WebMap';\nimport type { MapStateItem } from '../../interfaces/MapState';\nimport type { WebMapEvents } from '../../interfaces/Events';\nimport type { MapOptions } from '../../interfaces/MapOptions';\n\nexport abstract class StateItem<V extends any | undefined = any | undefined>\n  implements MapStateItem<V | undefined>\n{\n  name!: keyof MapOptions;\n  event!: keyof WebMapEvents;\n  protected value?: V;\n\n  constructor(\n    protected webMap: WebMap,\n    opt?: { name?: keyof MapOptions; event?: keyof WebMapEvents; value?: V },\n  ) {\n    if (opt) {\n      if (opt.value) {\n        this.setValue(opt.value);\n      }\n      if (opt.name) {\n        this.name = opt.name;\n      }\n      if (opt.event) {\n        this.event = opt.event;\n      }\n    }\n  }\n\n  getValue(): V | undefined {\n    return this.value;\n  }\n\n  setValue(val: V): void {\n    this.value = val;\n  }\n\n  abstract toString(data: unknown): string;\n  abstract parse(str: string): V;\n}\n","import { StateItem } from './StateItem';\n\nimport type { LngLatArray } from '@nextgis/utils';\nimport type { WebMapEvents } from '../../interfaces/Events';\nimport type { MapOptions } from '../../interfaces/MapOptions';\n\nexport class CenterState extends StateItem<LngLatArray> {\n  name: keyof MapOptions = 'center';\n  event: keyof WebMapEvents = 'moveend';\n\n  getValue(): LngLatArray | undefined {\n    return this.webMap.getCenter();\n  }\n  setValue(val: LngLatArray): void {\n    this.webMap.setCenter(val);\n  }\n  toString(data: LngLatArray): string {\n    const d = data.map((x) => x.toFixed(5));\n    return d[0] + '_' + d[1];\n  }\n  parse(str: string): LngLatArray {\n    const lngLat = str.split('_').map(Number) as LngLatArray;\n    return lngLat;\n  }\n}\n","import { StateItem } from './StateItem';\nimport type { WebMapEvents } from '../../interfaces/Events';\nimport type { MapOptions } from '../../interfaces/MapOptions';\n\nexport class ZoomState extends StateItem<number> {\n  name: keyof MapOptions = 'zoom';\n  event: keyof WebMapEvents = 'zoomend';\n  getValue(): number | undefined {\n    const zoom = this.webMap.getZoom();\n    return zoom !== undefined ? Math.round(zoom) : undefined;\n  }\n  setValue(val: number): void {\n    this.webMap.setZoom(val);\n  }\n  toString(val: number): string {\n    return String(val);\n  }\n  parse(str: string): number {\n    return Number(str);\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport { deepmerge, defined, getBoundsFeature } from '@nextgis/utils';\nimport { GetPaintFunction } from '@nextgis/paint';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { deprecatedMapClick } from '@nextgis/utils';\n\nimport { Keys } from './components/keys/Keys';\nimport { CenterState } from './components/mapStates/CenterState';\nimport { StateItem } from './components/mapStates/StateItem';\nimport { ZoomState } from './components/mapStates/ZoomState';\nimport { clearObject } from './utils/clearObject';\n\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type { Feature, Polygon } from 'geojson';\nimport type {\n  Type,\n  TileJson,\n  LngLatArray,\n  LngLatBoundsArray,\n} from '@nextgis/utils';\nimport type { Cursor } from './interfaces/BaseTypes';\nimport type {\n  LocationEvents,\n  MapClickEvent,\n  LocateOptions,\n  FitOptions,\n  MapAdapter,\n  Locate,\n} from './interfaces/MapAdapter';\nimport type { StarterKit } from './interfaces/StarterKit';\nimport type { LayerAdapter } from './interfaces/LayerAdapter';\nimport type { RuntimeParams } from './interfaces/RuntimeParams';\nimport type { MapOptions } from './interfaces/MapOptions';\nimport type { WebMapEvents, MainMapEvents } from './interfaces/Events';\n\ntype EmitStatusEventData = any;\n\nlet ID = 0;\n\nconst OPTIONS: MapOptions = {\n  minZoom: 0,\n  maxZoom: 20,\n  paint: {\n    color: 'blue',\n    opacity: 0.4,\n    strokeOpacity: 1,\n    stroke: true,\n    radius: 8,\n    weight: 1,\n  },\n  selectedPaint: {\n    color: 'darkblue',\n    opacity: 0.4,\n    strokeOpacity: 1,\n    stroke: true,\n    radius: 12,\n    weight: 1,\n  },\n  create: true,\n};\n\ninterface AddEventsListenersOptions {\n  include: (keyof MainMapEvents)[];\n}\n\nexport class WebMapMain<\n  M = any,\n  E extends WebMapEvents = WebMapEvents,\n  O extends MapOptions = MapOptions,\n> {\n  static keys: Keys = new Keys();\n\n  static getPaintFunctions: { [name: string]: GetPaintFunction };\n\n  options: O = OPTIONS as O;\n  // `WebMapEvents` must be `E` but its not work correct\n  readonly emitter: StrictEventEmitter<EventEmitter, WebMapEvents> =\n    new EventEmitter();\n  readonly keys = WebMapMain.keys;\n\n  readonly mapAdapter: MapAdapter<M>;\n  readonly runtimeParams: RuntimeParams[] = [];\n\n  getPaintFunctions = WebMapMain.getPaintFunctions;\n  mapState: Type<StateItem>[] = [CenterState, ZoomState];\n  id = ID++;\n\n  /**\n   * From runtime params\n   */\n  protected _initMapState: Record<string, any> = {};\n  protected readonly _starterKits: StarterKit[];\n  private _mapState: StateItem[] = [];\n  private _extent?: LngLatBoundsArray;\n  private readonly _eventsStatus: { [key in keyof E]?: boolean } = {};\n  private _coordFromMapClickPromise?: CancelablePromise<LngLatArray>;\n\n  private readonly _mapEvents: {\n    [key in keyof MainMapEvents]?: (...args: any[]) => void;\n  } = {};\n\n  constructor(mapOptions: O) {\n    this.mapAdapter = mapOptions.mapAdapter as MapAdapter<M>;\n    this._starterKits = mapOptions.starterKits || [];\n    if (mapOptions) {\n      this.options = deepmerge((OPTIONS as O) || {}, mapOptions) as O;\n    }\n    if (this.options.runtimeParams) {\n      this.runtimeParams = this.options.runtimeParams;\n    }\n    this._addEventsListeners();\n\n    if (this.options.tileJson) {\n      this._setTileJsonOptions(this.options.tileJson);\n    }\n    if (this.options.create) {\n      this.create();\n    }\n  }\n\n  getId(): number {\n    return this.id;\n  }\n\n  /**\n   * Manual way to create a map (If {@link MapOptions.create} is `false`).\n   * @example\n   * ```javascript\n   * const webMap = new WebMap(options);\n   * webMap.create().then(() => doSomething());\n   * ```\n   */\n  async create(): Promise<this> {\n    if (!this.getEventStatus('create')) {\n      await this._setInitMapState(this.mapState);\n      await this._setupMap();\n      this._emitStatusEvent('create', this);\n    }\n    return this;\n  }\n\n  setRuntimeParams(params: RuntimeParams): void {\n    this.runtimeParams.push(params);\n  }\n\n  /**\n   * Destroys WebMap, MapAdapter, clears all layers and turn off all event listeners\n   */\n  destroy(): void {\n    this._removeEventListeners();\n    clearObject(this._emitStatusEvent);\n    if (this.mapAdapter.destroy) {\n      this.mapAdapter.destroy();\n    }\n  }\n\n  getState(): Record<string, any> {\n    const state: Record<string, any> = {};\n    this._mapState.forEach((x) => {\n      state[x.name] = x.getValue();\n    });\n    return state;\n  }\n\n  getRuntimeParams(): Record<string, any> {\n    const state: Record<string, any> = {};\n    this._mapState.forEach((x) => {\n      for (const r of this.runtimeParams) {\n        const val = r.get(x.name);\n        if (val !== undefined) {\n          state[x.name] = x.parse(val);\n          break;\n        }\n      }\n    });\n    return state;\n  }\n\n  /**\n   * Returns the HTML element that contains the map.\n   * @returns The map's container\n   */\n  getContainer(): HTMLElement | undefined {\n    if (this.mapAdapter.getContainer) {\n      return this.mapAdapter.getContainer();\n    } else if (this.options.target) {\n      if (this.options.target instanceof HTMLElement) {\n        return this.options.target;\n      } else if (typeof this.options.target === 'string') {\n        const element = document.getElementById(this.options.target);\n        if (element) {\n          return element;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the cursor icon to be displayed when hover icon on the map container.\n   * @param cursor - Available cursor name from https://developer.mozilla.org/ru/docs/Web/CSS/cursor\n   */\n  setCursor(cursor: Cursor): void {\n    if (this.mapAdapter.setCursor) {\n      this.mapAdapter.setCursor(cursor);\n    }\n  }\n\n  getCursor(): Cursor | undefined {\n    if (this.mapAdapter.getCursor) {\n      return this.mapAdapter.getCursor() as Cursor;\n    }\n    const container = this.getContainer();\n    if (container) {\n      return container.style.cursor as Cursor;\n    }\n  }\n\n  /**\n   * Set the center of the current view.\n   * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E\n   * webMap.setCenter([86.925278, 27.988056]);\n   * ```\n   */\n  setCenter(lngLat: LngLatArray): this {\n    this.mapAdapter.setCenter(lngLat);\n    return this;\n  }\n\n  /**\n   * Returns the map's geographical centerpoint.\n   * @returns lngLat Array of two numbers representing longitude and latitude of the center of the map view.\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E\n   * webMap.getCenter(); // [86.925278, 27.988056]\n   * ```\n   */\n  getCenter(): LngLatArray | undefined {\n    return this.mapAdapter.getCenter();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.mapAdapter.getBounds) {\n      return this.mapAdapter.getBounds();\n    }\n  }\n\n  getBoundsPolygon(): Feature<Polygon> | undefined {\n    const bounds = this.getBounds();\n    if (bounds) {\n      const feature = getBoundsFeature(bounds);\n      return feature;\n    }\n  }\n\n  /**\n   * Zoom to a specific zoom level.\n   * @param zoom - The zoom level to set (0-24).\n   */\n  setZoom(zoom: number): this {\n    this.mapAdapter.setZoom(zoom);\n    return this;\n  }\n\n  /**\n   * Returns the map's current zoom level.\n   * @returns The map's current zoom level (0-24).\n   */\n  getZoom(): number {\n    const zoom = this.mapAdapter.getZoom();\n    if (typeof zoom === 'number') {\n      return zoom;\n    }\n    throw Error(\n      'Unable to get zoom level. Perhaps the map is not have been initialized yet',\n    );\n  }\n\n  zoomIn(): void {\n    if (this.mapAdapter.zoomIn) {\n      this.mapAdapter.zoomIn();\n    } else {\n      const zoom = this.getZoom();\n      if (zoom) {\n        const toZoom = zoom + 1;\n        this.setZoom(toZoom);\n      }\n    }\n  }\n\n  zoomOut(): void {\n    if (this.mapAdapter.zoomOut) {\n      this.mapAdapter.zoomOut();\n    } else {\n      const zoom = this.getZoom();\n      if (zoom) {\n        const toZoom = zoom - 1;\n        this.setZoom(toZoom);\n      }\n    }\n  }\n\n  /**\n   * Sets the view of the map geographical center and zoom\n   * @param lngLat - Array of two numbers representing longitude and latitude of the center of the map view.\n   * @param zoom - The zoom level to set (0-24).\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27° 59′ 17″ N, 86° 55′ 31″ E\n   * webMap.setView([86.925278, 27.988056], 12)\n   * ```\n   */\n  setView(lngLat?: LngLatArray, zoom?: number): void {\n    if (this.mapAdapter.setView && lngLat && defined(zoom)) {\n      this.mapAdapter.setView(lngLat, zoom);\n    } else {\n      if (lngLat) {\n        this.mapAdapter.setCenter(lngLat);\n      }\n      if (defined(zoom)) {\n        this.mapAdapter.setZoom(zoom);\n      }\n    }\n  }\n\n  /**\n   * Sets a map view that contains the given geographical bounds.\n   * @param bounds - Array of coordinates, measured in degrees, in [west, south, east, north] order.\n   *\n   * @example\n   * ```javascript\n   * // Whole world\n   * webMap.fitBounds([0, -90, 180, 90]);\n   * ```\n   */\n  fitBounds(bounds: LngLatBoundsArray, options?: FitOptions): this {\n    if (bounds.every((x) => defined(x))) {\n      if (bounds[1] < -85.06) {\n        bounds[1] = -85.06;\n      }\n      if (bounds[3] > 85.06) {\n        bounds[3] = 85.06;\n      }\n      this.mapAdapter.fitBounds(bounds, options);\n    }\n    return this;\n  }\n\n  /**\n   * Checking the status of any asynchronous operation\n   * @param event - The name of the event whose status is checked\n   *\n   * @example\n   * ```javascript\n   * var webMap = new WebMap(options);\n   * webMap.getEventStatus('create'); // false\n   * webMap.emitter.on('create', function () {\n   *   webMap.getEventStatus('create'); // true\n   * })\n   * ```\n   */\n  getEventStatus(event: keyof E): boolean {\n    // ugly hack to disable type checking error\n    const _eventName = event as keyof WebMapEvents;\n    const status = this._eventsStatus[_eventName];\n    return status ?? false;\n  }\n\n  /**\n   * helper method to wait for events to load. By default, card creation is tracked\n   * @param event - The name of the event whose status is checked\n   *\n   * @example\n   * ```javascript\n   * var webMap = new WebMap(options);\n   * webMap.onLoad().then(function () {\n   *   webMap.getEventStatus('create'); // true\n   * })\n   *\n   * // use async/await syntax\n   * async function () {\n   *   await webMap.onLoad();\n   *   doSomething();\n   * }\n   *\n   * ```\n   */\n  onLoad(event: keyof WebMapEvents = 'create'): Promise<this> {\n    return new Promise((res) => {\n      if (this.getEventStatus(event)) {\n        res(this);\n      } else {\n        this.emitter.once(event, () => {\n          res(this);\n        });\n      }\n    });\n  }\n\n  onMapLoad(cb?: (mapAdapter: MapAdapter) => void): Promise<MapAdapter> {\n    return new Promise((res) => {\n      const _resolve = () => {\n        const mapAdapter = this.mapAdapter;\n        if (cb) {\n          cb(mapAdapter);\n        }\n        if (mapAdapter) {\n          res(mapAdapter);\n        }\n      };\n      const isLoaded = this.mapAdapter.isLoaded ?? true;\n      if (this.mapAdapter.map && isLoaded) {\n        _resolve();\n      } else {\n        this.mapAdapter.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  getLayerAdapters(): { [name: string]: Type<LayerAdapter> } {\n    return this.mapAdapter.layerAdapters;\n  }\n\n  getLayerAdapter(name: string): Type<LayerAdapter> {\n    const adapter = this.mapAdapter.layerAdapters[name];\n    return adapter;\n  }\n\n  locate(opt: LocateOptions, events?: LocationEvents): Locate {\n    if (this.mapAdapter && this.mapAdapter.locate) {\n      return this.mapAdapter.locate(opt, events);\n    }\n    const stop = () => ({});\n    return { stop };\n  }\n\n  stopGetCoordFromMapClick(): void {\n    if (this._coordFromMapClickPromise) {\n      this._coordFromMapClickPromise.cancel();\n    }\n  }\n\n  getCoordFromMapClick(): CancelablePromise<LngLatArray> {\n    if (!this._coordFromMapClickPromise) {\n      this._coordFromMapClickPromise = new CancelablePromise(\n        (resolve, reject, onCancel) => {\n          const cursor: Cursor = this.getCursor() || 'grab';\n          this._removeEventListeners({ include: ['click'] });\n          this.setCursor('crosshair');\n          const onCancel_ = (): void => {\n            this.setCursor(cursor);\n            this._addEventsListeners({ include: ['click'] });\n            this.mapAdapter.emitter.off('click', onMapClick);\n            this._coordFromMapClickPromise = undefined;\n          };\n          const onMapClick = (e: MapClickEvent) => {\n            onCancel_();\n            deprecatedMapClick(e);\n            resolve(e.lngLat);\n          };\n          this.mapAdapter.emitter.once('click', onMapClick);\n          onCancel(onCancel_);\n        },\n      );\n    } else {\n      return this.getCoordFromMapClick();\n    }\n    return this._coordFromMapClickPromise;\n  }\n\n  protected _emitStatusEvent(\n    eventName: keyof E,\n    data?: EmitStatusEventData,\n  ): void {\n    // ugly hack to disable type checking error\n    const _eventName = eventName as keyof WebMapEvents;\n    this._eventsStatus[_eventName] = true;\n    this.emitter.emit(_eventName, data);\n  }\n\n  protected async _addLayerProviders(): Promise<void> {\n    //\n  }\n\n  protected async _onLoadSync(): Promise<void> {\n    //\n  }\n\n  private async _setupMap(): Promise<this> {\n    if (!this.mapAdapter) {\n      throw new Error('WebMap `mapAdapter` option is not set');\n    }\n    await this.mapAdapter.create(this.options);\n    this._zoomToInitialExtent();\n\n    await this._addLayerProviders();\n    await this._onLoadSync();\n\n    this._emitStatusEvent('build-map', this.mapAdapter);\n    return this;\n  }\n\n  private _setTileJsonOptions(tileJson: TileJson): void {\n    if (tileJson.center) {\n      this.options.center = tileJson.center;\n    }\n    if (tileJson.bounds) {\n      this.options.bounds = tileJson.bounds;\n    }\n    if (defined(tileJson.maxzoom)) {\n      this.options.maxZoom = tileJson.maxzoom;\n      this.options.zoom = tileJson.maxzoom;\n    }\n    if (defined(tileJson.minzoom)) {\n      this.options.minZoom = tileJson.minzoom;\n      this.options.zoom = tileJson.minzoom;\n    }\n    if (defined(tileJson.maxzoom) && defined(tileJson.minzoom)) {\n      this.options.zoom = (tileJson.maxzoom + tileJson.minzoom) / 2;\n    }\n  }\n\n  private _zoomToInitialExtent(): void {\n    const { center, zoom, bounds } = this.options;\n    if (this._extent) {\n      this.fitBounds(this._extent);\n    } else if (center && zoom) {\n      this.setView(center, zoom);\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  private _setInitMapState(states: Type<StateItem>[]): void {\n    for (const X of states) {\n      const state = new X(this);\n      this._mapState.push(state);\n      for (const r of this.runtimeParams) {\n        const str = r.get(state.name);\n        if (str !== undefined) {\n          const val = state.parse(str);\n          // state.setValue(val);\n          this._initMapState[state.name] = val;\n          Object.defineProperty(this.options, state.name, {\n            value: val,\n            configurable: true,\n            enumerable: true,\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  private _addEventsListeners(opt?: AddEventsListenersOptions): void {\n    let events: (keyof MainMapEvents)[] = [\n      'preclick',\n      'click',\n      'zoomstart',\n      'zoom',\n      'zoomend',\n      'movestart',\n      'move',\n      'moveend',\n    ];\n\n    if (opt && opt.include) {\n      events = events.filter((x) => opt.include.includes(x));\n    }\n    events.forEach((x) => {\n      this._mapEvents[x] = (data): void => {\n        if (this.runtimeParams.length) {\n          const mapStatusEvent = this._mapState.find((y) => y.event === x);\n          if (mapStatusEvent) {\n            const value = mapStatusEvent.toString(mapStatusEvent.getValue());\n            this.runtimeParams.forEach((r) => {\n              r.set(mapStatusEvent.name, value);\n            });\n          }\n        }\n        if (this._eventsStatus) {\n          this.emitter.emit(x, data);\n        }\n      };\n      const mapEvent = this._mapEvents[x];\n      if (mapEvent) {\n        this.mapAdapter.emitter.on(x, mapEvent);\n      }\n    });\n  }\n\n  private _removeEventListeners(opt?: AddEventsListenersOptions): void {\n    let events = Object.entries(this._mapEvents) as [\n      keyof MainMapEvents,\n      ((...args: any[]) => void) | undefined,\n    ][];\n    if (opt && opt.include) {\n      events = events.filter((x) => opt.include.includes(x[0]));\n    }\n    events.forEach(([x, event]) => {\n      if (event) {\n        this.mapAdapter.emitter.removeListener(x as keyof MainMapEvents, event);\n      }\n    });\n  }\n}\n","/**\n * @internal\n */\nexport function clearObject(obj: Record<any, any>): void {\n  for (const member in obj) {\n    delete obj[member];\n  }\n}\n","import { preparePaint } from '@nextgis/paint';\nimport { propertiesFilter } from '@nextgis/properties-filter';\n\nimport { updateGeoJsonAdapterOptions } from './utils/updateGeoJsonAdapterOptions';\nimport { WebMapMain } from './WebMapMain';\n\nimport type { Feature, GeoJsonObject, Geometry } from 'geojson';\nimport { defined, FeatureProperties, TileJson, Type } from '@nextgis/utils';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\n\nimport type {\n  LayerAdapter,\n  LayerAdapters,\n  FilterOptions,\n  AdapterOptions,\n  LayerDefinition,\n  DataLayerFilter,\n  MainLayerAdapter,\n  AdapterConstructor,\n  VectorLayerAdapter,\n  TileAdapterOptions,\n  FeatureLayerAdapter,\n  ImageAdapterOptions,\n  OnLayerClickOptions,\n  LayerAdaptersOptions,\n  OnLayerSelectOptions,\n  GeoJsonAdapterOptions,\n  LayerAdapterDefinition,\n} from './interfaces/LayerAdapter';\nimport type { LayerDef } from './interfaces/BaseTypes';\nimport type {\n  GetAttributionsOptions,\n  ToggleLayerOptions,\n  MapOptions,\n} from './interfaces/MapOptions';\nimport type { WebMapEvents } from './interfaces/Events';\nimport type { FitOptions } from './interfaces/MapAdapter';\n\ntype AddedLayers<M = any, L = any> = { [id: string]: LayerAdapter<M, L> };\n\nexport class WebMapLayers<\n  M = any,\n  L = any,\n  E extends WebMapEvents = WebMapEvents,\n  O extends MapOptions = MapOptions,\n> extends WebMapMain<M, E, O> {\n  private _layersIdCounter = 1;\n  private _layersOrderCounter = 1;\n  private readonly _baselayers: string[] = [];\n  private readonly _layers: AddedLayers<M, L> = {};\n  private readonly _selectedLayers: string[] = [];\n\n  constructor(mapOptions: O) {\n    super(mapOptions);\n    const tileJson = this.options.tileJson;\n    if (tileJson) {\n      this.emitter.once('build-map', () => this.addTileJsonLayer(tileJson));\n    }\n  }\n\n  /**\n   * Try to fit map view by given layer bounds.\n   * But not all layers have borders\n   */\n  async fitLayer(layerDef: LayerDef, options?: FitOptions): Promise<void> {\n    const layer = this.getLayer(layerDef);\n    // TODO: remove backward compatibility for `getExtent`\n    const getBounds = layer && (layer.getBounds || layer.getExtent);\n    if (getBounds) {\n      const extent = await getBounds.call(layer);\n      if (extent) {\n        this.fitBounds(extent, options);\n      }\n    }\n  }\n\n  /**\n   * Check if given layer is baselayer\n   */\n  isBaseLayer(layerDef: LayerDef): boolean | undefined {\n    const layer = this.getLayer(layerDef);\n    if (layer && layer.id) {\n      return this._baselayers.indexOf(layer.id) !== -1;\n    }\n    return undefined;\n  }\n\n  getBaseLayers(): LayerAdapter[] {\n    const baselayers: LayerAdapter[] = [];\n    this._baselayers.forEach((x) => {\n      const baselayer = this._layers[x];\n      if (baselayer) {\n        baselayers.push(baselayer);\n      }\n    });\n    return baselayers;\n  }\n\n  getBaseLayersIds(): string[] {\n    return this._baselayers;\n  }\n\n  /**\n   * Helper method to return added layer object by any definition type.\n   */\n  getLayer<LA extends LayerAdapter = LayerAdapter>(\n    layerDef: LayerDef,\n  ): LA | undefined {\n    if (typeof layerDef === 'string') {\n      return this._layers[layerDef] as LA;\n    }\n    return layerDef as LA;\n  }\n\n  /**\n   * Helper method to return added layer identificator by any definition type.\n   */\n  getLayerId(layerDef: LayerDef): string | undefined {\n    const layer = this.getLayer(layerDef);\n    if (layer && layer.options) {\n      return layer.options.id;\n    } else {\n      throw new Error('No id for layer');\n    }\n  }\n\n  /**\n   * Return array of all added layer identifications.\n   */\n  getLayers(): string[] {\n    return Object.keys(this._layers);\n  }\n\n  // TODO: rename to getLayers, getLayers rename to getLayersIds\n  allLayers(): AddedLayers<M, L> {\n    return this._layers;\n  }\n\n  orderedLayers<LA extends LayerAdapter<M, L> = LayerAdapter<M, L>>(): LA[] {\n    return Object.values(this._layers).sort((a, b) =>\n      a.order && b.order ? a.order - b.order : 0,\n    ) as LA[];\n  }\n\n  findLayer<T extends LayerAdapter = LayerAdapter>(\n    filter: (adapter: T) => boolean,\n  ): T | undefined {\n    for (const l in this._layers) {\n      const layerAdapter = this._layers[l] as T;\n      const isFit = filter(layerAdapter);\n      if (isFit) {\n        return layerAdapter;\n      }\n    }\n  }\n\n  /**\n   * Check if the given layer on the map\n   */\n  isLayerVisible(layerDef: LayerDef): boolean {\n    const layer = this.getLayer(layerDef);\n    return layer && layer.options.visibility !== undefined\n      ? layer.options.visibility\n      : false;\n  }\n\n  /**\n   * Shortcut method to create base layer\n   */\n  async addBaseLayer<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions,\n  >(\n    adapter: K | Type<LayerAdapters[K]>,\n    options?: O | LayerAdaptersOptions[K],\n  ): Promise<LayerAdapter> {\n    const layer = await this.addLayer(\n      adapter,\n      {\n        ...options,\n        baselayer: true,\n      },\n      undefined,\n    );\n\n    return layer;\n  }\n\n  /**\n   * Registration of map layer.\n   *\n   * @param adapter - The name of layer adapter from [MapAdapter.layerAdapters](webmap#MapAdapter.layerAdapters).\n   *                May be custom object or class implemented by [MainLayerAdapter](webmap#MainLayerAdapter).\n   * @param options - Specific options for given adapter\n   *\n   * @example\n   * ```javascript\n   * webMap.addLayer('TILE', options).then((layer) => webMap.showLayer(layer));\n   *\n   * webMap.addLayer(CustomLayerAdapter, options);\n   * ```\n   */\n  async addLayer<\n    K extends keyof LayerAdapters,\n    LO extends AdapterOptions = AdapterOptions,\n  >(\n    adapter: LayerAdapterDefinition<K>,\n    options: LO | LayerAdaptersOptions[K] = {},\n    order?: number,\n  ): Promise<LayerAdapter> {\n    const id = this._layersIdCounter++;\n    const _order = defined(order)\n      ? order\n      : options.order !== undefined\n      ? options.order\n      : this.reserveOrder();\n    let adapterEngine: Type<LayerAdapter<M, L, LO>> | undefined;\n    if (typeof adapter === 'string') {\n      adapterEngine = this.getLayerAdapter(adapter) as Type<\n        LayerAdapter<M, L, LO>\n      >;\n    } else if (typeof adapter === 'function') {\n      adapterEngine = adapter as Type<LayerAdapter<M, L, LO>>;\n    } else if (\n      'then' in (adapter as Promise<Type<LayerAdapters[K]> | undefined>)\n    ) {\n      adapterEngine = (await adapter) as Type<LayerAdapter<M, L, LO>>;\n    }\n\n    const geoJsonOptions = options as GeoJsonAdapterOptions;\n\n    this._updateGeoJsonOptions(geoJsonOptions);\n\n    const { maxZoom, minZoom } = this.options;\n\n    options = {\n      id: String(id),\n      order: _order,\n      maxZoom,\n      minZoom,\n      ...options,\n    };\n\n    // options.visibility is a layer global state\n    const visibility = options.visibility ?? true;\n    options.visibility = false;\n\n    if (options.baselayer) {\n      options.order = 0;\n    }\n    if (this.options.onBeforeAddLayer) {\n      const modified = this.options.onBeforeAddLayer({\n        options,\n        adapter: adapterEngine,\n      });\n      if (modified) {\n        if (modified.options) {\n          options = modified.options;\n        }\n        if (modified.adapter) {\n          adapterEngine = modified.adapter as Type<LayerAdapter<M, L, LO>>;\n        }\n      }\n    }\n    if (adapterEngine !== undefined) {\n      const _adapter = new adapterEngine(this.mapAdapter.map, options);\n      _adapter.options = { ...options, ..._adapter.options };\n\n      if (_adapter.options.baselayer) {\n        options.baselayer = true;\n        options.order = 0;\n        _adapter.options.order = 0;\n      }\n\n      let layerId: string | undefined;\n      if (_adapter.options.id) {\n        layerId = String(_adapter.options.id);\n\n        this._layers[layerId] = _adapter;\n      }\n      this._emitLayerEvent('layer:preadd', layerId || '', _adapter);\n      await this.onMapLoad();\n      _adapter.map = this.mapAdapter.map;\n      const layer = await _adapter.addLayer(_adapter.options);\n      // checking that the original layer was inserted into the adapter anyway\n      _adapter.layer = layer;\n      // think about how to move `id` to the adapter's constructor,\n      // but that it is not required in the options\n      _adapter.id = _adapter.options.id || String(id);\n      _adapter.options.id = _adapter.id;\n      if (options.baselayer) {\n        _adapter.options.order = 0;\n      }\n      _adapter.order = _adapter.options.order ?? _order;\n      if (layerId) {\n        delete this._layers[layerId];\n      }\n      layerId = String(_adapter.id);\n      if (this._layers[layerId]) {\n        throw Error(`layer with id '${layerId}' already exist`);\n      }\n      if (layerId) {\n        this._layers[layerId] = _adapter;\n\n        if (geoJsonOptions.filter) {\n          this.filterLayer(_adapter, geoJsonOptions.filter);\n        }\n        if (options.baselayer) {\n          this._baselayers.push(layerId);\n        }\n\n        if (visibility) {\n          await this.showLayer(layerId);\n        }\n      }\n      const opacity = options.opacity;\n      if (opacity !== undefined && opacity <= 1) {\n        this.setLayerOpacity(_adapter, opacity);\n      }\n      // TODO: remove backward compatibility for `getExtent`\n      const getBounds = layer && (_adapter.getBounds || _adapter.getExtent);\n      if (options.fit && getBounds) {\n        const extent = await getBounds.call(_adapter);\n        if (extent) {\n          await this.fitBounds(extent);\n        }\n      }\n      this._emitLayerEvent('layer:add', layerId, _adapter);\n      return _adapter;\n    }\n    return Promise.reject('No adapter');\n  }\n\n  async addLayerFromAsyncAdapter<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions,\n  >(\n    adapter: AdapterConstructor,\n    options: O | LayerAdaptersOptions[K],\n    order?: number,\n  ): Promise<LayerAdapter> {\n    const _order =\n      order || options.order !== undefined\n        ? options.order\n        : 0 || this.reserveOrder();\n    const adapterConstructor = adapter as AdapterConstructor;\n    const adapterConstructorPromise = adapterConstructor();\n    const adapterEngine = await adapterConstructorPromise;\n    if (adapterEngine) {\n      return this.addLayer(adapterEngine, options, _order);\n    }\n    return Promise.reject('No adapter');\n  }\n\n  /**\n   * Remove all layer from map and memory.\n   */\n  removeLayers(\n    allowCb?: (layer: string, adapter: LayerAdapter) => boolean,\n  ): void {\n    for (const l in this._layers) {\n      let allow = true;\n      if (allowCb) {\n        allow = allowCb(l, this._layers[l]);\n      }\n      if (allow) {\n        this.removeLayer(l);\n        delete this._layers[l];\n      }\n    }\n  }\n\n  reserveOrder(): number {\n    return this._layersOrderCounter++;\n  }\n\n  /**\n   * Remove all layers but not remove basemap.\n   */\n  removeOverlays(): void {\n    this.removeLayers((layerId, layer) => {\n      if (layer && layer.options && layer.options.baselayer) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Remove specific layer from map and memory by its definition.\n   */\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    const layerId = layer && this.getLayerId(layer);\n    if (layer && layerId) {\n      this.emitter.emit('layer:preremove', layer);\n      if (layer.beforeRemove) {\n        layer.beforeRemove();\n      }\n      if (layer.removeLayer) {\n        layer.removeLayer();\n      } else {\n        this.mapAdapter.removeLayer(layer.layer);\n      }\n      if (layer.options && layer.options.baselayer) {\n        const index = this._baselayers.indexOf(layerId);\n        if (index) {\n          this._baselayers.splice(index, 1);\n        }\n      }\n      delete this._layers[layerId];\n      this.emitter.emit('layer:remove', layer);\n    }\n  }\n\n  /**\n   * Create layer from GeoJson data. Set style and behavior for selection.\n   *\n   * @example\n   * ```javascript\n   * // Add simple layer\n   * webMap.addGeoJsonLayer({ data: geojson, paint: { color: 'red' } });\n   *\n   * // Add styled by feature property layer with selection behavior\n   * webMap.addGeoJsonLayer({\n   *   data: geojson,\n   *   paint: function (feature) {\n   *     return { color: feature.properties.color, opacity: 0.5 }\n   *   },\n   *  selectedPaint: function (feature) {\n   *    return { color: feature.properties.selcolor, opacity: 1 }\n   *  },\n   *  selectable: true,\n   *  multiselect: true\n   * });\n   *\n   * // Add marker layer styled with use [Icons](icons)\n   * webMap.addGeoJsonLayer({ data: geojson, paint: webMap.getIcon({ color: 'orange' })});\n   *\n   * // work with added layer\n   * const layer = webMap.addGeoJsonLayer({ data: geojson, id: 'my_layer_name'});\n   * // access layer by id\n   * webMap.showLayer('my_layer_name');\n   * // or access layer by instance\n   * webMap.showLayer(layer);\n   * ```\n   */\n  addGeoJsonLayer<\n    K extends keyof LayerAdapters = keyof LayerAdapters,\n    O extends GeoJsonAdapterOptions<any, any> = GeoJsonAdapterOptions,\n  >(\n    opt: O = {} as O,\n    adapter?: LayerAdapterDefinition<K>,\n  ): Promise<VectorLayerAdapter<any, any, any>> {\n    opt = opt || {};\n    opt.multiselect = opt.multiselect !== undefined ? opt.multiselect : false;\n    opt.unselectOnSecondClick =\n      opt.unselectOnSecondClick !== undefined\n        ? opt.unselectOnSecondClick\n        : true;\n    if (!adapter) {\n      opt = updateGeoJsonAdapterOptions(opt);\n    }\n    opt.paint = opt.paint || {};\n    return this.addLayer(adapter || 'GEOJSON', opt);\n  }\n\n  /** Shortcut for {@link WebMapLayers.addGeoJsonLayer} to create GeoJson adapter with generic types for working in typescript */\n  addFeatureLayer<\n    P extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n    O extends GeoJsonAdapterOptions<Feature<G, P>> = GeoJsonAdapterOptions<\n      Feature<G, P>\n    >,\n  >(options = {} as O): Promise<FeatureLayerAdapter<P, G>> {\n    return this.addGeoJsonLayer<'GEOJSON', O>(options) as Promise<\n      FeatureLayerAdapter<P, G>\n    >;\n  }\n\n  /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */\n  addTileLayer(\n    url: string,\n    options: Omit<TileAdapterOptions, 'url'>,\n  ): Promise<MainLayerAdapter<M, L, TileAdapterOptions>> {\n    return this.addLayer('TILE', { ...options, url }) as Promise<\n      MainLayerAdapter<M, L, TileAdapterOptions>\n    >;\n  }\n\n  /** Shortcut for {@link WebMapLayers.addLayer} to create TileLayer adapter */\n  addImageLayer(\n    url: string,\n    options: Omit<ImageAdapterOptions, 'url'>,\n  ): Promise<MainLayerAdapter<M, L, ImageAdapterOptions>> {\n    return this.addLayer('IMAGE', { ...options, url }) as Promise<\n      MainLayerAdapter<M, L, ImageAdapterOptions>\n    >;\n  }\n\n  /**\n   * Show added layer on the map by it definition.\n   */\n  showLayer(\n    layerDef: LayerDef,\n    options: ToggleLayerOptions = {},\n  ): Promise<void> {\n    return this.toggleLayer(layerDef, true, options);\n  }\n\n  /**\n   * Hide added layer on the map by it definition.\n   */\n  hideLayer(\n    layerDef: LayerDef,\n    options: ToggleLayerOptions = {},\n  ): Promise<void> {\n    return this.toggleLayer(layerDef, false, options);\n  }\n\n  /**\n   * Change added layer visibility on the map by given status or inverse current status.\n   *\n   * @example\n   * ```javascript\n   * webMap.addLayer('TILE', {id: 'my_layer', url: ''}).then((layer) => {\n   *   webMap.toggleLayer(layer, true);\n   *   webMap.toggleLayer('my_layer', false);\n   *   webMap.toggleLayer('my_layer');\n   *   webMap.isLayerVisible(layer); // true\n   * });\n   * ```\n   */\n  toggleLayer(\n    layerDef: LayerDef,\n    status?: boolean,\n    options: ToggleLayerOptions = {},\n  ): Promise<void> {\n    const layer = this.getLayer(layerDef);\n\n    const onMap = layer && layer.options.visibility;\n    const toStatus = status !== undefined ? status : !onMap;\n    const silent = options.silent !== undefined ? options.silent : false;\n    const action = async (l: LayerAdapter) => {\n      const id = String(l.id);\n      const preEventName = toStatus ? 'layer:preshow' : 'layer:prehide';\n      const eventName = toStatus ? 'layer:show' : 'layer:hide';\n      if (!silent) {\n        this._emitLayerEvent(preEventName, id, l);\n        this._emitLayerEvent('layer:pretoggle', id, l);\n      }\n      if (toStatus && this.mapAdapter) {\n        const order = l.options.baselayer ? 0 : l.options.order;\n\n        // do not show baselayer if another on the map\n        if (l.options.baselayer && this._baselayers.length) {\n          const anotherVisibleBaselayers = this._baselayers.filter((x) => {\n            return x !== l.id && this.isLayerVisible(x);\n          });\n          for (const bl of anotherVisibleBaselayers) {\n            await this.hideLayer(bl);\n          }\n        }\n        if (l.showLayer) {\n          await l.showLayer.call(l, l.layer);\n        } else if (l.layer !== undefined) {\n          await this.mapAdapter.showLayer(l.layer);\n        }\n        if (order !== undefined) {\n          this.mapAdapter.setLayerOrder(l.layer, order, this._layers);\n        }\n      } else {\n        if (l.hideLayer) {\n          await l.hideLayer.call(l, l.layer);\n        } else if (l.layer !== undefined) {\n          await this.mapAdapter.hideLayer(l.layer);\n        }\n      }\n      if (!silent) {\n        this._emitLayerEvent(eventName, id, l);\n        this._emitLayerEvent('layer:toggle', id, l);\n      }\n      l.options.visibility = toStatus;\n    };\n    if (layer && layer.options.visibility !== toStatus) {\n      return this.onMapLoad().then(() => action(layer));\n    }\n    return Promise.resolve();\n  }\n\n  updateLayer(layerDef: LayerDef): Promise<void> {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (layer.updateLayer) {\n        return Promise.resolve(layer.updateLayer());\n      } else if (this.isLayerVisible(layer)) {\n        return this.hideLayer(layer, { silent: true }).then(() => {\n          return this.showLayer(layer, { silent: true });\n        });\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Set transparency for a given layer by number from 0 to 1\n   */\n  setLayerOpacity(layerDef: LayerDef, value: number): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (layer.setOpacity) {\n        layer.setOpacity(value);\n      } else if (this.mapAdapter.setLayerOpacity) {\n        this.mapAdapter.setLayerOpacity(layer.layer, value);\n      }\n    }\n  }\n\n  // requestGeomString(pixel: Pixel, pixelRadius: number) {\n  //   if (this.mapAdapter.requestGeomString) {\n  //     return this.mapAdapter.requestGeomString(pixel, pixelRadius);\n  //   }\n  // }\n\n  /**\n   * Mark the layer as selected.\n   * If the adapter is a vector layer and supports data selection,\n   * you can pass a callback function to specify which data will be selected.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.selectLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n\n   */\n  selectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const adapter = layer as VectorLayerAdapter;\n      if (adapter && adapter.select) {\n        adapter.select(findFeatureFun);\n      }\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        this._selectedLayers.push(layerId);\n      }\n    }\n  }\n\n  /**\n   * Unselect the given layer.\n   * If the adapter is a vector layer and supports data selection,\n   * you can pass a callback function to specify which data will be unselected.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.unSelectLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   *\n   */\n  unSelectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const adapter = layer && (layer as VectorLayerAdapter);\n      if (adapter.unselect) {\n        adapter.unselect(findFeatureFun);\n      }\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        const index = this._selectedLayers.indexOf(layerId);\n        if (index !== -1) {\n          this._selectedLayers.splice(index, 1);\n        }\n      }\n    }\n  }\n  /** Remove selection from any selected selectable layer */\n  unSelectLayers(): void {\n    const layers = Object.values(this.allLayers());\n    let l: VectorLayerAdapter;\n    for (l of layers) {\n      if (l.unselect) {\n        l.unselect();\n      }\n    }\n  }\n\n  /**\n   * Hide features from a vector layer using a callback function.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.filterLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   *\n   */\n  filterLayer(\n    layerDef: LayerDef,\n    filter: DataLayerFilter<Feature, L>,\n  ): LayerDefinition<Feature, L>[] {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.filter) {\n      return adapter.filter(filter);\n    }\n    return [];\n  }\n\n  propertiesFilter(\n    layerDef: LayerDef,\n    filters: PropertiesFilter,\n    options?: FilterOptions,\n  ): void {\n    const layer = this.getLayer(layerDef);\n    if (!layer) return;\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.propertiesFilter) {\n      adapter.propertiesFilter(filters, options);\n    } else if (adapter.filter) {\n      this.filterLayer(adapter, (e) => {\n        if (e.feature && e.feature.properties) {\n          return propertiesFilter(e.feature.properties, filters);\n        }\n        return true;\n      });\n    }\n  }\n\n  removeLayerFilter(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.removeFilter) {\n      adapter.removeFilter();\n    } else if (adapter.filter) {\n      adapter.filter(() => {\n        return true;\n      });\n    }\n  }\n\n  /**\n   * Sets the GeoJSON data for given vector layer.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON').then((layer) => {\n   *   webMap.setLayerData(layer, geojson);\n   * });\n   * ```\n   */\n  setLayerData(layerDef: LayerDef, data: GeoJsonObject): void | Promise<void> {\n    const vectorAdapter = this.getLayer(layerDef);\n    const adapter = vectorAdapter as VectorLayerAdapter;\n    if (adapter) {\n      if (adapter.setData) {\n        return adapter.setData(data);\n      } else if (adapter.clearLayer && adapter.addData) {\n        adapter.clearLayer();\n        return adapter.addData(data);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Push new the GeoJSON features into given vector layer.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson_features_5}).then((layer) => {\n   *   console.log(layer.getLayers().length) // > 5;\n   *   webMap.addLayerData(layer, geojson_features_3);\n   *   console.log(layer.getLayers().length) // > 8;\n   * });\n   * ```\n   */\n  addLayerData(layerDef: LayerDef, data: GeoJsonObject): void {\n    const layerMem = this.getLayer(layerDef);\n    const adapter = layerMem as VectorLayerAdapter;\n    if (adapter.addData) {\n      adapter.addData(data);\n    }\n  }\n\n  /**\n   * Remove from vector layer all features.\n   * it is possible to remove only some objects if you specify a callback function.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.clearLayerData(layer, (feture) => feture.id === 42);\n   *   webMap.clearLayerData(layer);\n   * });\n   * ```\n   */\n  clearLayerData(layerDef: LayerDef, cb?: (feature: Feature) => boolean): void {\n    const layerMem = this.getLayer(layerDef);\n    const adapter = layerMem as VectorLayerAdapter;\n    if (adapter && adapter.clearLayer) {\n      adapter.clearLayer(cb);\n    }\n  }\n\n  getAttributions(options: GetAttributionsOptions): string[] {\n    const attributions: string[] = [];\n    for (const l in this._layers) {\n      const layerCache = this._layers[l];\n      const onlyVisible =\n        options.onlyVisible !== undefined ? options.onlyVisible : true;\n      let useLayerAttr = onlyVisible ? layerCache.options.visibility : true;\n      if (useLayerAttr && options.onlyBaselayer) {\n        useLayerAttr = this._baselayers.includes(l);\n      }\n      if (useLayerAttr) {\n        const attr = layerCache.options && layerCache.options.attribution;\n        if (attr) {\n          attributions.push(attr);\n        }\n      }\n    }\n\n    return attributions;\n  }\n\n  getActiveBaseLayer(): MainLayerAdapter<M, any, AdapterOptions> | undefined {\n    const visibleLayerBaseLayer = this.getBaseLayers().find((x) => {\n      return this.isLayerVisible(x);\n    });\n    if (visibleLayerBaseLayer) {\n      return this.getLayer(visibleLayerBaseLayer);\n    }\n  }\n\n  addTileJsonLayer(\n    tileJson: TileJson,\n  ): Promise<MainLayerAdapter<M, any, TileAdapterOptions>> {\n    // if (this.mapAdapter.createTileJsonlayer) {\n    // } else {\n\n    const url = tileJson.tiles[0];\n    return this.addLayer('TILE', {\n      url,\n      maxZoom: tileJson.maxzoom,\n      minZoom: tileJson.minzoom,\n      subdomains: tileJson.scheme,\n      attribution: tileJson.attribution,\n    }) as Promise<MainLayerAdapter<M, any, TileAdapterOptions>>;\n  }\n\n  private async _onLayerClick(options: OnLayerClickOptions) {\n    const id = options.layer.id;\n    this._emitLayerEvent('layer:click', id || '', options);\n    return Promise.resolve(options);\n  }\n\n  private async _onLayerSelect(options: OnLayerSelectOptions) {\n    this._emitLayerEvent('layer:select', options.layer.id || '', options);\n    return Promise.resolve(options);\n  }\n\n  private _updateGeoJsonOptions(options: GeoJsonAdapterOptions) {\n    const {\n      onSelect,\n      onLayerSelect,\n      onClick,\n      onLayerClick,\n      onMouseOut,\n      onMouseOver,\n    } = options;\n    const onLayerClickFromOpt = onClick || onLayerClick;\n    options.onClick = (e) => {\n      if (onLayerClickFromOpt) {\n        onLayerClickFromOpt(e);\n      }\n      return this._onLayerClick(e);\n    };\n\n    options.onMouseOut = (e) => {\n      const id = e.layer.id;\n      onMouseOut && onMouseOut(e);\n      if (defined(id)) {\n        this._emitLayerEvent(`layer:mouseout`, id, e);\n      }\n    };\n\n    options.onMouseOver = (e) => {\n      const id = e.layer.id;\n      onMouseOver && onMouseOver(e);\n      if (defined(id)) {\n        this._emitLayerEvent(`layer:mouseover`, id, e);\n      }\n    };\n\n    // TODO: remove backward compatibility for onLayerSelect\n    const onLayerSelectFromOpt = onSelect || onLayerSelect;\n    options.onSelect = (e) => {\n      if (onLayerSelectFromOpt) {\n        onLayerSelectFromOpt(e);\n      }\n      return this._onLayerSelect(e);\n    };\n\n    if (!options.nativePaint) {\n      if (this.options.paint) {\n        options.paint = preparePaint(\n          options.paint || {},\n          this.options.paint,\n          this.getPaintFunctions,\n        );\n      }\n      if (options.selectedPaint && this.options.selectedPaint) {\n        options.selectedPaint = preparePaint(\n          options.selectedPaint,\n          this.options.selectedPaint,\n          this.getPaintFunctions,\n        );\n      }\n    }\n  }\n\n  private _emitLayerEvent(\n    name: keyof WebMapEvents,\n    id: string,\n    options: unknown,\n  ) {\n    if (defined(id) && name.startsWith('layer:')) {\n      const specificLayerName = name.replace('layer:', 'layer-' + id + ':');\n      // @ts-ignore can't paste template literal key for interface\n      this.emitter.emit(specificLayerName, options);\n    }\n    this.emitter.emit(name, options);\n  }\n}\n","import type {\n  ToggleControlOptions,\n  ToggleControl,\n  ButtonControlOptions,\n} from '../../interfaces/MapControl';\n\n/**\n * The toggle is a button with status.\n * @internal\n */\nexport function createToggleControl<C = any>(\n  createButtonControl: (options: ButtonControlOptions) => C,\n  options: ToggleControlOptions,\n): C & ToggleControl {\n  const link = document.createElement('div');\n\n  let status = false;\n  if (options.getStatus) {\n    status = options.getStatus();\n  } else if (options.status) {\n    status = options.status;\n  }\n\n  const title = options.title || '';\n  const html = options.html;\n\n  function setTitle() {\n    if (title) {\n      if (typeof title === 'string') {\n        link.title = title;\n      } else {\n        link.title = status ? title.on : title.off;\n      }\n      link.setAttribute('aria-label', link.title);\n    }\n  }\n  setTitle();\n\n  // DomEvent.disableClickPropagation(link);\n  // DomEvent.on(link, 'click', DomEvent.stop);\n\n  function _setHtml(htmlDef: string | HTMLElement) {\n    if (htmlDef instanceof HTMLElement) {\n      link.innerHTML = '';\n      link.appendChild(htmlDef);\n    } else if (typeof htmlDef === 'string') {\n      link.innerHTML = htmlDef;\n    }\n  }\n  function setHtml() {\n    if (html) {\n      if (typeof html === 'string' || html instanceof HTMLElement) {\n        _setHtml(html);\n      } else {\n        _setHtml(status ? html.on : html.off);\n      }\n      link.setAttribute('aria-label', link.title);\n    }\n  }\n  setHtml();\n\n  function _setClass(addClass: string, impact: boolean) {\n    addClass.split(' ').forEach((x) => {\n      if (impact) {\n        link.classList.add(x);\n      } else {\n        link.classList.remove(x);\n      }\n    });\n  }\n\n  function setClass() {\n    if (options.addClassOn) {\n      _setClass(options.addClassOn, status);\n    }\n    if (options.addClassOff) {\n      _setClass(options.addClassOff, !status);\n    }\n  }\n\n  if (options.addClass) {\n    _setClass(options.addClass, true);\n  }\n  setClass();\n\n  const changeStatus = (status_?: boolean) => {\n    if (status_ !== undefined) {\n      status = status_;\n    }\n    setHtml();\n    setTitle();\n    setClass();\n  };\n\n  const onClick = (status_?: boolean) => {\n    status = status_ !== undefined ? status_ : !status;\n    if (options.onClick) {\n      const afterClick = options.onClick(status);\n      Promise.resolve(afterClick)\n        .then(() => changeStatus())\n        .catch(() => (status = !status));\n    } else {\n      changeStatus();\n    }\n  };\n\n  const buttonControl = createButtonControl({\n    html: link,\n    onClick,\n  }) as C & ToggleControl;\n  buttonControl.onClick = onClick;\n  buttonControl.changeStatus = changeStatus;\n  return buttonControl;\n}\n","import { WebMapLayers } from './WebMapLayers';\nimport { createToggleControl } from './components/controls/createToggleControl';\n\nimport type { WebMapMain } from './WebMapMain';\nimport type { MapOptions } from './interfaces/MapOptions';\nimport type { WebMapEvents } from './interfaces/Events';\nimport type {\n  MapControl,\n  CreateControlOptions,\n  ButtonControlOptions,\n  ToggleControlOptions,\n  ToggleControl,\n  MapControls,\n} from './interfaces/MapControl';\nimport type { ControlPosition } from './interfaces/MapAdapter';\n\n/**\n * Collection of methods for managing map controls\n */\nexport class WebMapControls<\n    M = any,\n    L = any,\n    C = any,\n    E extends WebMapEvents = WebMapEvents,\n    O extends MapOptions = MapOptions,\n  >\n  extends WebMapLayers<M, L, E, O>\n  implements WebMapLayers, WebMapMain\n{\n  static controls: {\n    [name: string]: (webMap: WebMapControls, options?: any) => any;\n  } = {\n    CONTROL: (\n      webMap: WebMapControls,\n      options: {\n        control: MapControl;\n        options?: CreateControlOptions;\n      },\n    ) => {\n      return webMap.createControl(options.control, options.options);\n    },\n    BUTTON: (webMap: WebMapControls, options: ButtonControlOptions) => {\n      return webMap.createButtonControl(options);\n    },\n    TOGGLE: (webMap: WebMapControls, options: ToggleControlOptions) => {\n      return webMap.createToggleControl(options);\n    },\n  };\n\n  private _loadControlQueue: {\n    [key in ControlPosition]: (() => Promise<any>)[];\n  } = {\n    'top-right': [],\n    'bottom-right': [],\n    'top-left': [],\n    'bottom-left': [],\n  };\n  private _isControlLoading: { [key in ControlPosition]: boolean } = {\n    'top-right': false,\n    'bottom-right': false,\n    'top-left': false,\n    'bottom-left': false,\n  };\n\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    let control: C | undefined;\n    position = position ?? 'top-left';\n    if (typeof controlDef === 'string') {\n      control = this.getControl(controlDef, options);\n    } else {\n      control = controlDef as C;\n    }\n    if (control) {\n      return new Promise<() => Promise<any>>((resolve) => {\n        const promise = async () => {\n          const _control = await control;\n          const c = this.mapAdapter.addControl(_control, position);\n          resolve(c);\n        };\n        this._setControlQueue(position, promise);\n      });\n    }\n  }\n\n  /**\n   * Creating a universal map layout control element. Can be used with any map adapter.\n   *\n   * @example\n   * ```javascript\n   * const control = webMap.createControl({\n   *   onAdd() {\n   *     return document.createElement('div');\n   *   }\n   * });\n   * ```\n   */\n  async createControl(\n    control: MapControl,\n    options?: CreateControlOptions,\n  ): Promise<C | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createControl) {\n      return this.mapAdapter.createControl(control, options);\n    }\n  }\n\n  async createButtonControl(\n    options: ButtonControlOptions,\n  ): Promise<C | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createButtonControl) {\n      return this.mapAdapter.createButtonControl(options);\n    }\n  }\n\n  /**\n   * Create any toggler control button\n   * @param options - Options for control layout customization and assigning a callback function\n   *\n   * @example\n   * ```javascript\n   * const toggleControl = ngwMap.createToggleControl({\n   *   getStatus: () => webMap.isLayerVisible('any-layer-id'),\n   *   onClick: (status) => ngwMap.toggleLayer('webmap', status),\n   *   html: {\n   *     on: 'ON',\n   *     off: 'OFF'\n   *   },\n   *   title: 'Toggle layer visibility'\n   * });\n   * webMap.addControl(toggleControl, 'top-right');\n   * ```\n   * {@link http://code.nextgis.com/demo-examples-toggle-control | Toggle button control example}\n   */\n  async createToggleControl(\n    options: ToggleControlOptions,\n  ): Promise<(C & ToggleControl) | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createToggleControl) {\n      return this.mapAdapter.createToggleControl(options);\n    } else {\n      if (this.mapAdapter.createButtonControl) {\n        return createToggleControl<C>(\n          this.mapAdapter.createButtonControl,\n          options,\n        );\n      }\n    }\n  }\n\n  /**\n   *\n   * @param control - Instance of WEB-GIS framework control.\n   *                  What is returned by the {@Link WebMapControls.createControl | create} method\n   */\n  removeControl(control: C): void {\n    if ('remove' in control) {\n      // @ts-ignore TODO: ugly code, rewrite\n      control.remove();\n    } else if (this.mapAdapter.removeControl) {\n      Promise.resolve(control).then((c) => {\n        this.mapAdapter.removeControl(c);\n      });\n    }\n  }\n\n  /**\n   * Get instance of registered control\n   * @param control - Any registered control string name\n   * @param options - Custom control options\n   */\n  getControl<K extends keyof MapControls>(\n    control: K,\n    options?: MapControls[K],\n  ): C | undefined {\n    const engine = this.mapAdapter.controlAdapters[control];\n    if (engine) {\n      return new engine(options);\n    } else {\n      const createFun = WebMapControls.controls[control];\n      if (createFun) {\n        return createFun(this, options);\n      }\n    }\n  }\n\n  getControlContainer(): HTMLElement | undefined {\n    if (this.mapAdapter.getControlContainer) {\n      return this.mapAdapter.getControlContainer();\n    }\n  }\n\n  private _setControlQueue(position: ControlPosition, cb: () => Promise<any>) {\n    this._loadControlQueue[position].push(cb);\n    if (!this._isControlLoading[position]) {\n      this._applyControls(position);\n    }\n  }\n\n  private async _applyControls(position: ControlPosition) {\n    if (this._loadControlQueue[position].length) {\n      this._isControlLoading[position] = true;\n      const controlCb = this._loadControlQueue[position][0];\n      await controlCb();\n      this._loadControlQueue[position].splice(0, 1);\n      this._applyControls(position);\n    } else {\n      this._isControlLoading[position] = false;\n    }\n  }\n}\n","import type { WebMap } from './WebMap';\n\nconst WEB_MAP_CONTAINER: Record<number, any> = {};\n\nexport function getWebMap<T extends WebMap = WebMap>(id: number): T {\n  return WEB_MAP_CONTAINER[id];\n}\n\nexport function setWebMap(id: number, webMap: WebMap) {\n  WEB_MAP_CONTAINER[id] = webMap;\n}\n","/**\n * @privateRemarks\n * Since it was not possible to split the code through mixins, inheritance was used.\n * The `ts-mixin` plugin worked fine, but led to errors in IE.\n *\n * Now inheritance is as follow:\n * BaseWebMap \\> WebMapLayers \\> WebMap\n *\n * Will need to be done this way:\n * ```javascript\n * class WebMap extend mixin(WebMapLayers, WebMapControls) {}\n * ```\n *\n * This approach can also be considered\n * ```javascript\n * class WebMap {\n *   layers: WebMapLayers;\n *   controls  WebMapControls\n * }\n * ```\n * and then\n *\n * const webMap = new WebMap(...);\n * webMap.layers.addLayer(...)\n *\n * looks good, but will add difficulty in inheriting from WebMap\n *\n * old:\n * ```javascript\n * class NgwMap extends WebMap {\n *   addLayer(...) {\n *      super.addLayer(...)\n *   }\n * }\n * ```\n * new:\n * ```javascript\n * class NgwLayers extends WebMapLayers {\n *   addLayer(...) {\n *     super.addLayer(...)\n *   }\n * }\n *\n * class NgwMap extends WebMap {\n *   layersClass = NgwLayers\n * }\n * ```\n * ...and there will be compatibility issues\n */\n\nimport { WebMapMain } from './WebMapMain';\nimport { WebMapControls } from './WebMapControls';\n\nimport type { MapOptions } from './interfaces/MapOptions';\nimport type { ControlOptions } from './interfaces/MapControl';\nimport type { WebMapEvents } from './interfaces/Events';\nimport type { WebMapLayers } from './WebMapLayers';\nimport { getWebMap, setWebMap } from './container';\n\n/**\n * The core component for managing map adapters.\n * It contains methods for adding and manipulation with\n * {@link WebMapMain | map}, {@link WebMapLayers | layers} and {@link WebMapControls | controls}.\n *\n * @example\n * ```javascript\n * import { WebMap } from '@nextgis/webmap';\n * import MapAdapter from '@nextgis/ol-map-adapter';\n *\n * const webMap = new WebMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n * });\n * ```\n *\n * @typeParam M - Interactive Map used in the adapter\n * @typeParam L - Layer\n * @typeParam C - Control\n * @typeParam E - Events\n *\n */\nexport class WebMap<\n    M = any,\n    L = any,\n    C = any,\n    E extends WebMapEvents = WebMapEvents,\n    O extends MapOptions = MapOptions,\n  >\n  extends WebMapControls<M, L, C, E, O>\n  implements WebMapControls, WebMapLayers, WebMapMain\n{\n  constructor(mapOptions: O) {\n    super(mapOptions);\n    this._addControls();\n    setWebMap(this.id, this);\n  }\n\n  static get<T extends WebMap = WebMap>(id: number): T {\n    return getWebMap<T>(id);\n  }\n\n  /**\n   * @internal\n   */\n  protected async _addLayerProviders(): Promise<void> {\n    for await (const kit of this._starterKits) {\n      if (kit.getLayerAdapters) {\n        const adapters = await kit.getLayerAdapters.call(kit);\n        if (adapters) {\n          for await (const adapter of adapters) {\n            const newAdapter = await adapter.createAdapter(this);\n            if (newAdapter) {\n              this.mapAdapter.layerAdapters[adapter.name] = newAdapter;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async _onLoadSync(): Promise<void> {\n    for await (const kit of this._starterKits) {\n      if (kit.onLoadSync) {\n        try {\n          await kit.onLoadSync.call(kit, this);\n        } catch (er) {\n          console.error(er);\n        }\n      }\n    }\n  }\n\n  private _addControls(): void {\n    if (this.options.controls) {\n      this.options.controls.forEach((x) => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n}\n"],"names":["findMostFrequentGeomType","arr","maxName","counts","fry","length","c","count","undefined","paintTypeAlias","polygon","line","point","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","updateGeoJsonAdapterOptions","opt","data","geomType","geojson","type","features","map","f","geometry","geometries","g","p","paint","isPaint","KeyCodes","Keys","this","_windowOnFocus","windowOnFocus","bind","_keysPressed","keysPressed","_keysReleased","keysReleased","addKeyboardEventsListener","keyName","code","keyCodeAlias","keys","window","addEventListener","removeEventListener","e","stopPropagation","keyCode","StateItem","webMap","value","setValue","name","event","val","CenterState","getCenter","setCenter","d","x","toFixed","str","split","Number","ZoomState","zoom","getZoom","Math","round","setZoom","String","ID","OPTIONS","minZoom","maxZoom","color","opacity","strokeOpacity","stroke","radius","weight","selectedPaint","create","WebMapMain","mapOptions","EventEmitter","getPaintFunctions","mapAdapter","_starterKits","starterKits","options","deepmerge","runtimeParams","_addEventsListeners","tileJson","_setTileJsonOptions","id","getEventStatus","_setInitMapState","mapState","_setupMap","_emitStatusEvent","params","push","_removeEventListeners","obj","member","clearObject","destroy","state","_mapState","forEach","getValue","get","parse","getContainer","target","HTMLElement","element","document","getElementById","cursor","setCursor","getCursor","container","style","lngLat","getBounds","bounds","getBoundsFeature","Error","zoomIn","toZoom","zoomOut","setView","defined","every","fitBounds","_eventName","status","_eventsStatus","Promise","res","emitter","once","cb","_resolve","isLoaded","layerAdapters","events","locate","stop","_coordFromMapClickPromise","cancel","getCoordFromMapClick","CancelablePromise","resolve","reject","onCancel","include","onCancel_","off","onMapClick","deprecatedMapClick","eventName","emit","_zoomToInitialExtent","_addLayerProviders","_onLoadSync","center","maxzoom","minzoom","_extent","states","X","_initMapState","Object","defineProperty","configurable","enumerable","filter","includes","_mapEvents","mapStatusEvent","find","y","toString","r","set","mapEvent","on","entries","removeListener","WebMapLayers","addTileJsonLayer","layerDef","layer","getLayer","getExtent","call","extent","_baselayers","indexOf","baselayers","baselayer","_layers","values","sort","a","b","order","l","layerAdapter","visibility","adapter","addLayer","_layersIdCounter","_order","reserveOrder","adapterEngine","getLayerAdapter","geoJsonOptions","_updateGeoJsonOptions","onBeforeAddLayer","modified","_adapter","layerId","_emitLayerEvent","onMapLoad","filterLayer","showLayer","setLayerOpacity","fit","adapterConstructorPromise","allowCb","allow","removeLayer","_layersOrderCounter","removeLayers","getLayerId","beforeRemove","index","splice","multiselect","unselectOnSecondClick","addGeoJsonLayer","url","toggleLayer","onMap","toStatus","silent","action","preEventName","anotherVisibleBaselayers","isLayerVisible","bl","hideLayer","setLayerOrder","then","updateLayer","setOpacity","findFeatureFun","select","_selectedLayers","unselect","allLayers","filters","propertiesFilter","feature","properties","removeFilter","setData","clearLayer","addData","attributions","layerCache","useLayerAttr","onlyVisible","onlyBaselayer","attr","attribution","visibleLayerBaseLayer","getBaseLayers","tiles","subdomains","scheme","onSelect","onLayerSelect","onClick","onLayerClick","onMouseOut","onMouseOver","onLayerClickFromOpt","_onLayerClick","onLayerSelectFromOpt","_onLayerSelect","nativePaint","preparePaint","startsWith","specificLayerName","replace","createToggleControl","createButtonControl","link","createElement","getStatus","title","html","setTitle","setAttribute","_setHtml","htmlDef","innerHTML","appendChild","setHtml","_setClass","addClass","impact","classList","add","remove","setClass","addClassOn","addClassOff","changeStatus","status_","afterClick","catch","buttonControl","WebMapControls","controlDef","position","control","getControl","promise","_control","addControl","_setControlQueue","onLoad","createControl","removeControl","engine","controlAdapters","createFun","controls","getControlContainer","_loadControlQueue","_isControlLoading","_applyControls","controlCb","CONTROL","BUTTON","TOGGLE","WEB_MAP_CONTAINER","WebMap","_addControls","kit","getLayerAdapters","adapters","createAdapter","newAdapter","onLoadSync","console","error","controlAdapterName","controlOptions","controlsOptions","getWebMap"],"sourceRoot":""}