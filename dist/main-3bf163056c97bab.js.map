{"version":3,"file":"main-3bf163056c97bab.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/paint/src/typeHelpers.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/fromPaintExpression.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/preparePaint.ts","webpack://clear_horizon/./@nextgis/packages/properties-filter/src/propertiesFilter.ts"],"sourcesContent":["import type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  PropertiesPaint,\n  GeometryPaint,\n  Expression,\n  IconPaint,\n  Paint,\n} from './interfaces';\n\nexport function isExpression(value: unknown): value is Expression {\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { isExpression } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  Expression,\n  ExpressionName,\n} from './interfaces';\n\ntype ExpressionFun = (feature: Feature, args: any[]) => SimpleType;\n\nfunction get(feature: Feature, args: any[]) {\n  const field = args[0];\n  return feature.properties && feature.properties[field];\n}\n\nfunction match(feature: Feature, args: any[]) {\n  const [lookup, ...cases] = args;\n  let property = lookup;\n  if (Array.isArray(lookup)) {\n    property = featureExpression(feature, lookup as Expression);\n  }\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry];\n    if (key === property) {\n      return cases[fry + 1];\n    }\n  }\n  return defValue;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFun } = {\n  get,\n  match,\n};\n\ntype SimpleType = string | number | boolean | undefined;\n\ntype PropertyExpressionCb = (feature: Feature) => SimpleType;\n\nfunction featureExpression(feature: Feature, expression: Expression) {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(feature, args);\n  }\n  return undefined;\n}\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    return featureExpression(feature, expression);\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: Record<string, any>,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  Paint,\n  PropertyPaint,\n  GeometryPaint,\n  PropertiesPaint,\n  GetPaintCallback,\n  GetPaintFunction,\n  GetCustomPaintOptions,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  for (const p of propertiesPaint) {\n    if (p) {\n      if (Array.isArray(p)) {\n        paintsFilters.push(p);\n      } else {\n        mask = p as VectorAdapterLayerPaint;\n      }\n    }\n  }\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nexport function expressionCallback<P extends Record<string, any> = Record<string, any>>(\n  paint: P,\n  defaultPaint?: P,\n  getPaintFunctions?: Record<string, GetPaintFunction>,\n) {\n  const expressionCallback = createExpressionCallback(paint);\n  if (expressionCallback) {\n    const expressionPaintCb = (feature: Feature) => {\n      return preparePaint(\n        expressionCallback(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n    expressionPaintCb.paint = paint;\n    return expressionPaintCb;\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  newPaint = { ...newPaint, ...paint };\n  newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n  newPaint.stroke =\n    newPaint.stroke !== undefined\n      ? newPaint.stroke\n      : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  return newPaint;\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint?: GeometryPaint,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint(\n        paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    newPaint = expressionCallback(paint, defaultPaint, getPaintFunctions);\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import type { Feature } from 'geojson';\nimport type {\n  Operation,\n  Properties,\n  PropertiesFilter,\n  PropertyFilter,\n} from './interfaces';\n\nfunction reEscape(s: string): string {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operation]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function isPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/** @deprecated use {@link isPropertyFilter} instead */\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  return isPropertyFilter(filter);\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter,\n): boolean {\n  const properties: Properties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter<T extends Properties = Properties>(\n  properties: T,\n  filters: PropertiesFilter<T>,\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (isPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n"],"names":["isPaint","paint","Object","prototype","toString","call","isPaintCallback","expressions","get","feature","args","field","properties","match","_args","_toArray","lookup","cases","slice","property","Array","isArray","featureExpression","defValue","splice","length","fry","expression","_expression","name","expressionFun","createPropertyExpressionCb","excludeExpressionList","preparePaint","defaultPaint","getPaintFunctions","Error","newPaint","_objectSpread","getPaintFunction","getPaint","type","isPropertiesPaint","propertiesPaint","_step","mask","paintsFilters","_iterator","_createForOfIteratorHelper","s","n","done","p","value","push","err","e","f","find","x","featureFilter","createPropertiesPaint","from","options","updatePaintOptionFromCallback","expressionCallback","withExpression","indexOf","p_","val","fromCb","createExpressionCallback","expressionPaintCb","fill","undefined","stroke","strokeColor","strokeOpacity","color","fillColor","opacity","fillOpacity","like","b","a","iLike","String","toUpperCase","re","concat","replace","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","ilike","isPropertyFilter","filter","pf","filters","$id","id","propertiesFilter","logic","filterFunction","_p","operation","operationExec","prop","value_","cleanField","filters_","some","every"],"sourceRoot":""}