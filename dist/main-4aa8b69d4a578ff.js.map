{"version":3,"file":"main-4aa8b69d4a578ff.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/icons/src/index.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/Attribution.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/createControl.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/boundsToArray.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/detectType.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/geometries.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/convertMapClickEvent.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/GeoJsonAdapter/utils/GeoJsonEvents.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/createMouseEvent.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/GeoJsonAdapter/utils/GeojsonPaint.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/callAjax.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageOverlay.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/makeRemoteTileLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/TileAdapter/TileLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/TileAdapter/TileAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/WmsAdapter/WmsLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/arrayToBoundsExpression.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/LeafletMapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/createButtonControl.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/GeoJsonAdapter/GeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/WmsAdapter/WmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/index.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItems.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/prepareNgwFieldsToPropertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/BookmarkItem.ts","webpack://clear_horizon/./@nextgis/packages/tree/src/treeFilter.ts","webpack://clear_horizon/./@nextgis/packages/item/src/TreeHelper.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/BaseProperty.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/CheckProperty.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/ItemProperties.ts","webpack://clear_horizon/./@nextgis/packages/item/src/Item.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/utils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/WebmapLayerOpacityPropertyHandler.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwExtent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwResource.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/updateQmsOptions.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/loadJson.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/getSubmodulesFromOriginUrl.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/QmsKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatureCollection.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatures.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createGeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/createPopupContent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerCount.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/ngwApiToAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createRasterAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createAsyncAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createNgwWebmapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createBasemapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowNgwAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/constants.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeature.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/IdentifyItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/identifyUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/appendNgwResources.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/NgwError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/ResourceNotFoundError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/isObject.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/resourceToQuery.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/ResourcesControl.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/resourceCompare.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/activeConnectors.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/InsufficientPermissionsError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/template.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/errors/NetworkError.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/loadData.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/NgwConnector.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/utils/apiRequest.ts","webpack://clear_horizon/./@nextgis/packages/ngw-connector/src/index.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/prepareWebMapOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/NgwMap.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getCompanyLogo.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/typeHelpers.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/fromPaintExpression.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/preparePaint.ts","webpack://clear_horizon/./@nextgis/packages/properties-filter/src/propertiesFilter.ts"],"sourcesContent":["/**\n * @module icons\n */\n\nimport type { IconPaint } from '@nextgis/paint';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star: '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>',\n};\n\nexport interface IconOptions {\n  svg?: string;\n  /** Svg path */\n  p?: string;\n  shape?:\n    | 'rect'\n    | 'star'\n    | 'plus'\n    | 'minus'\n    | 'brill'\n    | 'circle'\n    | 'marker'\n    | 'triangle'\n    | 'asterisk';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n  anchor?: [number, number];\n}\n\ninterface GenerateSvgOptions {\n  width: number;\n  height: number;\n  stroke?: number;\n  content?: string;\n}\n\nconst VIEW_BOX = 12;\nconst STROKE = 0.8;\n\nfunction generateSvg({\n  width,\n  height,\n  stroke = 0,\n  content,\n}: GenerateSvgOptions) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${VIEW_BOX + stroke} ${VIEW_BOX + stroke}\"\n  >${content}</svg>`;\n  return svg;\n}\n\nfunction insertSvg(svg: string) {\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\n/**\n * Retrieves an icon with the provided options.\n * @function\n * @param {IconOptions} [opt={}] - Options for the icon.\n * @returns {IconPaint} Icon paint object.\n */\nexport function getIcon(opt: IconOptions = {}): IconPaint {\n  // Default values\n  const shape = opt.shape ?? 'circle';\n  const color = opt.color ?? 'blue';\n  const strokeColor = opt.strokeColor ?? 'white';\n  const size = opt.size ?? VIEW_BOX;\n\n  const rotate = opt.rotate ?? 0;\n\n  const anchor = opt.anchor ?? [size / 2, size / 2];\n\n  const stroke = opt.stroke !== undefined ? Number(opt.stroke) : STROKE;\n\n  const pathAlias = opt.p || svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(\n    opt.svg ||\n      generateSvg({\n        width: size,\n        height: size,\n        stroke,\n        content: path,\n      }),\n  );\n\n  svg.setAttribute('width', String(size));\n  svg.setAttribute('height', String(size));\n\n  svg.setAttribute('fill', color);\n  if (stroke) {\n    svg.setAttribute('stroke', strokeColor);\n    svg.setAttribute('stroke-width', String(stroke));\n  }\n  const s = new XMLSerializer();\n\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: anchor,\n    html: s.serializeToString(svg),\n    rotate,\n    svg,\n  };\n}\n","import { Control } from 'leaflet';\n\nimport type { AttributionControlOptions } from '@nextgis/webmap';\nimport type { ControlOptions } from 'leaflet';\n\nexport class AttributionControl extends Control.Attribution {\n  // options: AttributionControlOptions\n  constructor(options: AttributionControlOptions & ControlOptions) {\n    super(options);\n    const customAttribution = options && options.customAttribution;\n    if (customAttribution) {\n      let attributions: string[] = [];\n      if (Array.isArray(customAttribution)) {\n        attributions = customAttribution;\n      } else if (customAttribution) {\n        attributions = [customAttribution];\n      }\n      attributions.forEach((x) => this.addAttribution(x));\n    }\n  }\n}\n","import { Control, DomEvent } from 'leaflet';\n\nimport type {\n  CreateControlOptions,\n  MapAdapter,\n  MapControl,\n} from '@nextgis/webmap';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {},\n  map: MapAdapter,\n): Control {\n  const C = Control.extend({\n    onAdd() {\n      const element = document.createElement('div');\n      const content = control.onAdd(map);\n      element.classList.add('leaflet-control');\n      if (options.bar) {\n        element.classList.add('leaflet-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      if (!options.margin && !options.bar) {\n        element.style.marginBottom = '0px';\n        element.style.marginTop = '0px';\n        element.style.marginLeft = '0px';\n        element.style.marginRight = '0px';\n      }\n      if (content) {\n        element.appendChild(content);\n      }\n\n      DomEvent.disableClickPropagation(element);\n\n      return element;\n    },\n    onRemove() {\n      control.onRemove();\n    },\n  });\n  return new C();\n}\n","import type { LngLatBoundsArray } from '@nextgis/utils';\nimport type { LatLngBounds } from 'leaflet';\n\nexport function boundsToArray(bounds: LatLngBounds): LngLatBoundsArray {\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  return [sw.lng, sw.lat, ne.lng, ne.lat];\n}\n","import type {\n  Feature,\n  FeatureCollection,\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  GeometryCollection,\n} from 'geojson';\n\nfunction findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[],\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type,\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type,\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n","import { GeoJSON } from 'leaflet';\n\nimport { boundsToArray } from './boundsToArray';\n\nimport type { LngLatArray, LngLatBoundsArray } from '@nextgis/utils';\nimport type { FeaturePosition, VectorAdapterLayerType } from '@nextgis/webmap';\nimport type {\n  Feature,\n  FeatureCollection,\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  GeometryCollection,\n} from 'geojson';\nimport type { LatLngBounds } from 'leaflet';\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'point',\n  LineString: 'line',\n  MultiPoint: 'point',\n  Polygon: 'polygon',\n  MultiLineString: 'line',\n  MultiPolygon: 'polygon',\n  GeometryCollection: 'polygon',\n};\n\nexport const PAINT = {\n  stroke: false,\n  opacity: 1,\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType,\n): boolean {\n  const geoJsonGeometry = backAliases[type] || [];\n  return geoJsonGeometry.indexOf(geometry) !== -1;\n}\n\nexport function filterGeometries(\n  data: GeoJsonObject,\n  type: VectorAdapterLayerType,\n): GeoJsonObject | false {\n  if (data.type === 'FeatureCollection') {\n    const _data = data as FeatureCollection;\n    _data.features = _data.features.filter((f) =>\n      geometryFilter(f.geometry.type, type),\n    );\n  } else if (data.type === 'Feature') {\n    const allow = geometryFilter((data as Feature).geometry.type, type);\n    if (!allow) {\n      return false;\n    }\n  } else if (data.type === 'GeometryCollection') {\n    const _data = data as GeometryCollection;\n    _data.geometries = _data.geometries.filter((g) =>\n      geometryFilter(g.type, type),\n    );\n  }\n  return data;\n}\n\nfunction featuresBounds(features: Feature | Feature[]): LatLngBounds {\n  const geoJsonLayer = new GeoJSON();\n  const features_ = Array.isArray(features) ? features : [features];\n  features_.forEach((f) => geoJsonLayer.addData(f));\n  return geoJsonLayer.getBounds();\n}\n\nexport function getFeaturesBounds(\n  features: Feature | Feature[],\n): LngLatBoundsArray {\n  return boundsToArray(featuresBounds(features));\n}\n\nexport function getFeaturesCenter(features: Feature | Feature[]): LngLatArray {\n  const { lat, lng } = featuresBounds(features).getCenter();\n  return [lng, lat];\n}\n\nexport function createFeaturePositionOptions(\n  features: Feature | Feature[],\n): FeaturePosition {\n  return {\n    getBounds: () => getFeaturesBounds(features),\n    getCenter: () => getFeaturesCenter(features),\n  };\n}\n","import type { AdapterOptions, MainLayerAdapter } from '@nextgis/webmap';\nimport type { Map } from 'leaflet';\n\nexport class BaseAdapter<O extends AdapterOptions = AdapterOptions, L = any>\n  implements MainLayerAdapter<Map, L, O>\n{\n  layer?: L;\n  protected pane = 'order-0';\n\n  constructor(\n    public map: Map,\n    public options: O,\n  ) {\n    if (options.order !== undefined) {\n      const pane = 'order-' + options.order;\n      let exist = map.getPane(pane);\n      if (!exist) {\n        exist = map.createPane(pane);\n      }\n      exist.style.zIndex = String(Math.round(options.order * 100));\n      this.pane = pane;\n    }\n  }\n\n  addLayer(options: O): L | Promise<L> | undefined {\n    Object.assign(this.options, options);\n    return undefined;\n  }\n}\n","import type { MapClickEvent } from '@nextgis/webmap';\nimport type { LeafletMouseEvent } from 'leaflet';\n\nexport function convertMapClickEvent(evt: LeafletMouseEvent): MapClickEvent {\n  const coord = evt.containerPoint;\n  const latLng = evt.latlng;\n  const { lat, lng } = latLng;\n  return {\n    latLng,\n    lngLat: [lng, lat],\n    pixel: { left: coord.x, top: coord.y },\n    source: evt,\n  };\n}\n","import { createMouseEvent } from '../../../utils/createMouseEvent';\n\nimport type { GeoJsonAdapter } from '../GeoJsonAdapter';\nimport type { OnLayerMouseOptions } from '@nextgis/webmap';\nimport type { Layer } from 'leaflet';\nimport type { LeafletEvent, LeafletMouseEvent } from 'leaflet';\n\nexport class GeoJsonEvents {\n  private layer: GeoJsonAdapter;\n\n  private _onclick?: (e: LeafletMouseEvent) => void;\n  private _mouseout?: (e: LeafletMouseEvent) => void;\n  private _mouseover?: (e: LeafletMouseEvent) => void;\n\n  constructor(layer: GeoJsonAdapter) {\n    this.layer = layer;\n  }\n\n  handleMouseEvents(layer: Layer) {\n    const { onClick, onLayerClick, onMouseOut, onMouseOver } =\n      this.layer.options;\n    // TODO: remove backward compatibility for onLayerClick\n    const onClick_ = onClick || onLayerClick;\n\n    if (onClick_) {\n      this._onclick = (e: LeafletMouseEvent) => {\n        const selected = !!this.layer._getSelected(layer);\n        onClick_({\n          selected,\n          ...this._createMouseEvent(e),\n        });\n      };\n      layer.on('click', this._onclick, this);\n    }\n    if (onMouseOut) {\n      this._mouseout = (e: LeafletMouseEvent) => {\n        onMouseOut(this._createMouseEvent(e));\n      };\n      layer.on('mouseout', this._mouseout, this);\n    }\n    if (onMouseOver) {\n      this._mouseover = (e: LeafletMouseEvent) => {\n        onMouseOver(this._createMouseEvent(e));\n      };\n      layer.on('mouseover', this._mouseover, this);\n    }\n  }\n\n  stopMouseEvents(layer: Layer) {\n    if (this._mouseover) {\n      layer.off('mouseover', this._mouseover, this);\n    }\n    if (this._mouseout) {\n      layer.off('mouseout', this._mouseout, this);\n    }\n    if (this._onclick) {\n      layer.off('click', this._onclick, this);\n    }\n  }\n\n  private _createMouseEvent(source: LeafletEvent): OnLayerMouseOptions {\n    return createMouseEvent({\n      layer: this.layer,\n      source: source as LeafletMouseEvent,\n    });\n  }\n}\n","import { convertMapClickEvent } from './convertMapClickEvent';\nimport { createFeaturePositionOptions } from './geometries';\n\nimport type { LayerDef } from '../layer-adapters/GeoJsonAdapter/GeoJsonAdapter';\nimport type { LayerAdapter, OnLayerMouseOptions } from '@nextgis/webmap';\nimport type { LeafletMouseEvent } from 'leaflet';\n\nexport interface CreateMouseEventOptions {\n  layer: LayerAdapter;\n  source: LeafletMouseEvent;\n}\n\nexport function createMouseEvent({\n  layer,\n  source,\n}: CreateMouseEventOptions): OnLayerMouseOptions {\n  const layer_ = source.target as LayerDef;\n  const feature = layer_.feature;\n  const opt: OnLayerMouseOptions = {\n    layer,\n    feature,\n    event: convertMapClickEvent(source),\n    source,\n    ...createFeaturePositionOptions(feature),\n  };\n  return opt;\n}\n","import { isPaint, isPaintCallback } from '@nextgis/paint';\nimport { defined } from '@nextgis/utils';\nimport { CircleMarker, DivIcon, Marker } from 'leaflet';\n\nimport { PAINT } from '../../../utils/geometries';\n\nimport type { GeoJsonAdapter, LayerDef } from '../GeoJsonAdapter';\nimport type {\n  IconPaint,\n  PathPaint,\n  VectorAdapterLayerPaint,\n} from '@nextgis/paint';\nimport type {\n  CircleMarkerOptions,\n  GeoJSONOptions,\n  LatLngExpression,\n  Path,\n  PathOptions,\n} from 'leaflet';\n\nexport class GeoJsonPaint {\n  private layer: GeoJsonAdapter;\n\n  constructor(layer: GeoJsonAdapter) {\n    this.layer = layer;\n  }\n\n  setPaintEachLayer(paint: VectorAdapterLayerPaint) {\n    this.layer._layers.forEach((layerDef) => {\n      this.setPaint(layerDef, paint);\n    });\n  }\n\n  setPaint(layerDef: LayerDef, paint: VectorAdapterLayerPaint) {\n    let style: VectorAdapterLayerPaint | undefined = undefined;\n    const { layer, feature } = layerDef;\n    if (layer && feature) {\n      if (isPaintCallback(paint)) {\n        style = paint(feature);\n      } else if (isPaint(paint)) {\n        style = paint;\n      }\n      if (style) {\n        if (this.layer.type === 'point' && style.type === 'icon') {\n          const marker = layer as Marker;\n          const divIcon = this._createDivIcon(style);\n          setTimeout(() => {\n            marker.setIcon(divIcon);\n          }, 10);\n        } else if ('setStyle' in layer) {\n          (layer as Path).setStyle(this.preparePaint(style));\n        }\n      }\n    }\n  }\n\n  preparePaint(paint: VectorAdapterLayerPaint): PathOptions {\n    if (paint.type !== 'get-paint') {\n      const paintAliases: [keyof PathOptions, keyof PathPaint][] = [\n        ['color', 'strokeColor'],\n        ['opacity', 'strokeOpacity'],\n        ['stroke', 'stroke'],\n        ['fillColor', 'fillColor'],\n        ['fillOpacity', 'fillOpacity'],\n        ['fill', 'fill'],\n        ['weight', 'weight'],\n      ];\n      const aliases: [keyof PathOptions, keyof PathPaint][] =\n        this.layer.type === 'line'\n          ? [\n              ['color', 'strokeColor'],\n              ['opacity', 'strokeOpacity'],\n              ['weight', 'weight'],\n            ]\n          : paintAliases;\n\n      const readyPaint: PathOptions & CircleMarkerOptions = {};\n\n      if ('radius' in paint && typeof paint.radius === 'number') {\n        readyPaint.radius = paint.radius;\n      }\n      for (const [to, from] of aliases) {\n        const opacity = this.layer.options.opacity;\n        let paintProp = (paint as PathPaint)[from];\n        if (defined(opacity) && from.toLowerCase().indexOf('opacity') !== -1) {\n          paintProp = Number(paintProp) * opacity;\n        }\n\n        if (paintProp !== undefined) {\n          Object.defineProperty(readyPaint, to, {\n            enumerable: true,\n            value: paintProp,\n          });\n        }\n      }\n\n      return readyPaint;\n    }\n    return PAINT;\n  }\n\n  _createDivIcon(icon: IconPaint) {\n    const { html, rotate, className, ...toLIconOpt } = icon;\n\n    const element = document.createElement('div');\n    if (className) {\n      element.className = className;\n    }\n    if (rotate) {\n      element.style.transform = `rotateZ(${rotate}deg)`;\n    }\n    if (html) {\n      element.innerHTML = html;\n    }\n\n    const divIcon = new DivIcon({\n      className: '',\n      ...toLIconOpt,\n      html: element,\n    });\n    return divIcon;\n  }\n\n  createPaintToLayer(icon: IconPaint) {\n    if (icon && icon.type) {\n      if (icon.type === 'icon') {\n        const iconClassName = icon.className;\n        const html = icon.html;\n        if (iconClassName || html) {\n          return (_: any, latlng: LatLngExpression) => {\n            const divIcon = this._createDivIcon(icon);\n            return new Marker(latlng, { icon: divIcon });\n          };\n        }\n      } else if (icon.type === 'pin') {\n        return (_: any, latlng: LatLngExpression) => {\n          return new Marker(latlng);\n        };\n      }\n    }\n    return (_: any, latlng: LatLngExpression) => {\n      const p: any = PAINT;\n      return new CircleMarker(latlng, this.preparePaint({ ...p, ...icon }));\n    };\n  }\n\n  createPaintOptions(paint: VectorAdapterLayerPaint): GeoJSONOptions {\n    const geoJsonOptions: GeoJSONOptions = {};\n    const newPaint = this.preparePaint(paint);\n    if (paint) {\n      geoJsonOptions.style = () => {\n        return newPaint;\n      };\n    }\n    if (this.layer.type === 'point') {\n      (geoJsonOptions as any).pointToLayer = this.createPaintToLayer(\n        paint as IconPaint,\n      );\n    } else if (this.layer.type === 'line') {\n      newPaint.stroke = true;\n    }\n    return geoJsonOptions;\n  }\n}\n","export function callAjax(\n  src: string,\n  callback: (resp: any) => any,\n  headers: Record<string, any>,\n): () => void {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', src);\n  xhr.responseType = 'arraybuffer';\n  for (const h in headers) {\n    xhr.setRequestHeader(h, headers[h]);\n  }\n  xhr.onload = function () {\n    const arrayBufferView = new Uint8Array(this.response);\n    const blob = new Blob([arrayBufferView], { type: 'image/png' });\n    // @ts-ignore for typedoc\n    const urlCreator = window.URL || window.webkitURL;\n    const imageUrl = urlCreator.createObjectURL(blob);\n    callback(imageUrl);\n  };\n  xhr.send();\n  return () => {\n    xhr.abort();\n  };\n}\n","import { ImageOverlay as LImageOverlay } from 'leaflet';\n\nimport { callAjax } from '../../utils/callAjax';\n\nimport type { ImageOverlayOptions, LatLngBoundsExpression } from 'leaflet';\n\ntype IOptions = ImageOverlayOptions & { headers?: any };\n\nexport class ImageOverlay extends LImageOverlay {\n  private _abort: (() => void)[] = [];\n\n  constructor(\n    imageUrl: string,\n    bounds: LatLngBoundsExpression,\n    options?: IOptions,\n  ) {\n    super(imageUrl, bounds, options);\n  }\n\n  cancelLoad(): void {\n    if (this._abort) {\n      this._abort.forEach((x) => x());\n      this._abort = [];\n    }\n  }\n\n  _initImage(): void {\n    // @ts-ignore\n    super._initImage();\n    // @ts-ignore\n    const headers = this.options.headers;\n    if (headers) {\n      // @ts-ignore\n      const img: HTMLImageElement = this._image;\n      const src = img.src;\n      img.src = '';\n      this._abort.push(\n        callAjax(\n          src,\n          (response) => {\n            img.src = response;\n          },\n          headers,\n        ),\n      );\n    }\n  }\n}\n","/*!\n * leaflet.wms.js\n * A collection of Leaflet utilities for working with Web Mapping services.\n * (c) 2014-2016, Houston Engineering, Inc.\n * MIT License\n */\n\nimport { debounce } from '@nextgis/utils';\nimport { CRS, Layer, Util } from 'leaflet';\n\nimport { ImageOverlay } from './ImageOverlay';\n\nimport type { Map } from 'leaflet';\n\ninterface OverlayOptions {\n  crs?: null;\n  uppercase?: boolean;\n  attribution?: string;\n  opacity?: number;\n  isBack?: boolean;\n  minZoom?: number;\n  maxZoom?: number;\n  zIndex?: number;\n  pane?: string;\n  headers?: any;\n  viewPortBuffer?: number;\n  setViewDelay?: number;\n}\n\n/*\n * Overlay:\n * \"Single Tile\" WMS image overlay that updates with map changes.\n * Portions of wms.Overlay are directly extracted from L.TileLayer.WMS.\n * See Leaflet license.\n */\nexport class ImageLayer extends Layer {\n  defaultWmsParams = {\n    service: 'WMS',\n    request: 'GetMap',\n    version: '1.1.1',\n    layers: '',\n    styles: '',\n    format: 'image/jpeg',\n    transparent: false,\n  };\n\n  options: OverlayOptions = {\n    crs: null,\n    uppercase: false,\n    attribution: '',\n    opacity: 1,\n    isBack: false,\n    minZoom: 0,\n    pane: 'tilePane',\n    headers: null,\n    viewPortBuffer: 0,\n    setViewDelay: 100,\n  };\n\n  private wmsParams: any;\n  private _url?: string;\n  private _currentUrl?: string;\n  private _currentOverlay?: ImageOverlay;\n\n  constructor(url: string, options: OverlayOptions) {\n    super(options);\n    this._url = url;\n\n    // Move WMS parameters to params object\n    const params: any = {};\n    const opts: any = {};\n    let opt: keyof OverlayOptions;\n    for (opt in options) {\n      if (opt in this.options) {\n        opts[opt] = options[opt];\n      } else {\n        params[opt] = options[opt];\n      }\n    }\n    Util.setOptions(this, opts);\n    this.wmsParams = Util.extend({}, this.defaultWmsParams, params);\n  }\n\n  setParams(params: Record<string, any>): void {\n    Util.extend(this.wmsParams, params);\n    this.update();\n  }\n\n  getAttribution(): string {\n    return this.options.attribution || '';\n  }\n\n  onAdd(): this {\n    this.update();\n    return this;\n  }\n\n  onRemove(map: Map): this {\n    if (this._currentOverlay) {\n      this._currentOverlay.cancelLoad();\n      map.removeLayer(this._currentOverlay);\n      delete this._currentOverlay;\n    }\n    if (this._currentUrl) {\n      delete this._currentUrl;\n    }\n    return this;\n  }\n\n  getEvents(): {\n    moveend: () => void;\n  } {\n    return {\n      moveend: debounce(this.update, this.options.setViewDelay),\n    };\n  }\n\n  update(): void {\n    if (!this._map) {\n      return;\n    }\n    // Determine image URL and whether it has changed since last update\n    this.updateWmsParams();\n    const url = this.getImageUrl();\n    if (this._currentUrl === url) {\n      return;\n    }\n    this._currentUrl = url;\n\n    // Keep current image overlay in place until new one loads\n    // (inspired by esri.leaflet)\n    const viewPortBuffer = this.options.viewPortBuffer || 0;\n    const bounds = this._map.getBounds().pad(viewPortBuffer);\n\n    const overlay = new ImageOverlay(url, bounds, {\n      opacity: 0,\n      pane: this.options.pane,\n      headers: this.options.headers,\n    });\n    overlay.addTo(this._map);\n    if (this._currentOverlay) {\n      this._currentOverlay.cancelLoad();\n    }\n    overlay.once(\n      'load',\n      () => {\n        if (!this._map) {\n          return;\n        }\n        // @ts-ignore\n        if (overlay._url !== this._currentUrl) {\n          this._map.removeLayer(overlay);\n          return;\n        } else if (this._currentOverlay) {\n          this._map.removeLayer(this._currentOverlay);\n        }\n        this._currentOverlay = overlay;\n        overlay.setOpacity(\n          this.options.opacity !== undefined ? this.options.opacity : 1,\n        );\n        if (this.options.isBack === true) {\n          overlay.bringToBack();\n        }\n        if (this.options.isBack === false) {\n          overlay.bringToFront();\n        }\n        if (this.options.zIndex !== undefined) {\n          overlay.setZIndex(this.options.zIndex);\n        }\n      },\n      this,\n    );\n    const { minZoom, maxZoom } = this.options;\n    if (\n      (minZoom && this._map.getZoom() < minZoom) ||\n      (maxZoom && this._map.getZoom() > maxZoom)\n    ) {\n      this._map.removeLayer(overlay);\n    }\n  }\n\n  setOpacity(opacity: number): void {\n    this.options.opacity = opacity;\n    if (this._currentOverlay) {\n      this._currentOverlay.setOpacity(opacity);\n    }\n  }\n\n  bringToBack(): void {\n    this.options.isBack = true;\n    if (this._currentOverlay) {\n      this._currentOverlay.bringToBack();\n    }\n  }\n\n  bringToFront(): void {\n    this.options.isBack = false;\n    if (this._currentOverlay) {\n      this._currentOverlay.bringToFront();\n    }\n  }\n\n  setZIndex(zIndex: number): void {\n    this.options.zIndex = zIndex;\n    if (this._currentOverlay) {\n      this._currentOverlay.setZIndex(zIndex);\n    }\n  }\n\n  // See L.TileLayer.WMS: onAdd() & getTileUrl()\n  updateWmsParams(map?: Map): void {\n    if (!map) {\n      map = this._map;\n    }\n    // Compute WMS options\n    const viewPortBuffer = this.options.viewPortBuffer || 0;\n    const bounds = map.getBounds().pad(viewPortBuffer);\n    const size = map.getSize();\n    if (this.options.viewPortBuffer !== 0) {\n      const factor = viewPortBuffer + 1;\n      size.x = Math.ceil(size.x * factor);\n      size.y = Math.ceil(size.y * factor);\n    }\n    const wmsVersion = parseFloat(this.wmsParams.version);\n    const crs = this.options.crs || map.options.crs;\n    const projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';\n    if (crs) {\n      const nw = crs.project(bounds.getNorthWest());\n      const se = crs.project(bounds.getSouthEast());\n\n      // Assemble WMS parameter string\n      const params: any = {\n        width: size.x,\n        height: size.y,\n      };\n      params[projectionKey] = crs.code;\n      params.bbox = (\n        wmsVersion >= 1.3 && crs === CRS.EPSG4326\n          ? [se.y, nw.x, nw.y, se.x]\n          : [nw.x, se.y, se.x, nw.y]\n      ).join(',');\n\n      Util.extend(this.wmsParams, params);\n    }\n  }\n\n  getImageUrl(): string {\n    const uppercase = this.options.uppercase || false;\n    const pstr = Util.getParamString(this.wmsParams, this._url, uppercase);\n    return this._url + pstr;\n  }\n}\n","import { DomUtil, GridLayer, Util } from 'leaflet';\n\nimport { debounce } from '../../../utils/src';\n\nimport { callAjax } from './callAjax';\n\n// import type { TileLayerOptionsExtended } from './TileAdapter/TileLayer';\n\ntype Constructor = new (...args: any[]) => any;\n\nexport function makeRemote<\n  TBase extends Constructor,\n  // O extends TileLayerOptionsExtended = TileLayerOptionsExtended\n>(Base: TBase): TBase {\n  return class RemoteTileLayer extends Base {\n    constructor(...args: any[]) {\n      super(...args);\n      if (this.options.setViewDelay) {\n        // @ts-ignore\n        this._update = debounce((...a: any[]) => {\n          // @ts-ignore\n          GridLayer.prototype._update.call(this, ...a);\n        }, this.options.setViewDelay);\n      }\n    }\n\n    createTile(\n      coords: Record<string, unknown>,\n      done: (error: any, tile: HTMLImageElement) => void,\n    ): HTMLImageElement {\n      // @ts-ignore\n      const url = this.getTileUrl(coords);\n\n      const tile = document.createElement('img');\n      (tile as any).abort = callAjax(\n        url,\n        (response) => {\n          tile.src = response;\n          done(null, tile);\n        },\n        // @ts-ignore\n        this.options.headers,\n      );\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin =\n          this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      tile.alt = '';\n      tile.setAttribute('role', 'presentation');\n\n      return tile;\n    }\n\n    _abortLoading() {\n      // @ts-ignore\n      const tiles = this._tiles;\n      // @ts-ignore\n      const tileZoom = this._tileZoom;\n      for (const i in tiles) {\n        if (tiles[i].coords.z !== tileZoom) {\n          const tile = tiles[i].el;\n\n          tile.onload = Util.falseFn;\n          tile.onerror = Util.falseFn;\n          if (!tile.complete) {\n            if (tile.abort) {\n              tile.abort();\n            }\n            tile.src = Util.emptyImageUrl;\n            DomUtil.remove(tile);\n            delete tiles[i];\n          }\n        }\n      }\n    }\n  };\n}\n","import { TileLayer as TL } from 'leaflet';\n\nimport { makeRemote } from '../../utils/makeRemoteTileLayer';\n\nimport type { TileLayerOptions } from 'leaflet';\n\nexport type TileLayerOptionsExtended = TileLayerOptions & {\n  headers: Record<string, any>;\n  setViewDelay?: number;\n};\n\nclass TileLayerBase extends TL {\n  constructor(urlTemplate: string, options?: TileLayerOptionsExtended) {\n    super(urlTemplate, options);\n    Object.assign(this.options, options);\n  }\n}\n\nexport const TileLayer = makeRemote(TileLayerBase);\n","import { TileLayer } from 'leaflet';\n\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport { TileLayer as TL } from './TileLayer';\n\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { TileLayerOptions } from 'leaflet';\n\nexport class TileAdapter\n  extends BaseAdapter<TileAdapterOptions, TileLayer>\n  implements MainLayerAdapter\n{\n  addLayer(options: TileAdapterOptions): TileLayer | undefined {\n    this.options = Object.assign(this.options, options);\n    if (options) {\n      const { url, ...opt } = options;\n      if (url) {\n        const tileLayerOptions: TileLayerOptions = {\n          pane: this.pane,\n          attribution: opt.attribution,\n          minZoom: opt.minZoom,\n          maxZoom: opt.maxZoom,\n\n          ...opt.nativeOptions,\n        };\n        if (opt.subdomains) {\n          tileLayerOptions.subdomains = opt.subdomains;\n        }\n        let layer;\n        if (opt.headers) {\n          layer = new TL(url, {\n            ...tileLayerOptions,\n            headers: opt.headers,\n            setViewDelay: opt.setViewDelay,\n          });\n        } else {\n          layer = new TileLayer(url, tileLayerOptions);\n        }\n        return layer;\n      }\n    }\n  }\n}\n","import { TileLayer } from 'leaflet';\n\nimport { makeRemote } from '../../utils/makeRemoteTileLayer';\n\nimport type { WMSOptions } from 'leaflet';\n\ntype LayerOptions = WMSOptions & { headers: any };\n\nclass WmsLayerBase extends TileLayer.WMS {\n  constructor(urlTemplate: string, options: LayerOptions) {\n    super(urlTemplate, options);\n  }\n}\n\nexport const WmsLayer = makeRemote(WmsLayerBase);\n","import type { LngLatBoundsArray } from '@nextgis/utils';\nimport type { LatLngBoundsExpression } from 'leaflet';\n\nexport function arrayToBoundsExpression(\n  bounds: LngLatBoundsArray,\n): LatLngBoundsExpression {\n  const e = bounds;\n  // top, left, bottom, right\n  return [\n    [e[3], e[0]],\n    [e[1], e[2]],\n  ];\n}\n","import { EventEmitter } from 'events';\n\nimport { Control, Map } from 'leaflet';\n\nimport { AttributionControl } from './controls/Attribution';\nimport { createButtonControl } from './controls/createButtonControl';\nimport { createControl } from './controls/createControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter/GeoJsonAdapter';\nimport { ImageAdapter } from './layer-adapters/ImageAdapter/ImageAdapter';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter/TileAdapter';\nimport { WmsAdapter } from './layer-adapters/WmsAdapter/WmsAdapter';\nimport { arrayToBoundsExpression } from './utils/arrayToBoundsExpression';\nimport { convertMapClickEvent } from './utils/convertMapClickEvent';\n\nimport type { LngLatArray, LngLatBoundsArray } from '@nextgis/utils';\nimport type {\n  ButtonControlOptions,\n  CreateControlOptions,\n  FitOptions,\n  LayerAdapter,\n  Locate,\n  LocateOptions,\n  LocationEvents,\n  MainMapEvents,\n  MapAdapter,\n  MapControl,\n  MapOptions,\n  ViewOptions,\n} from '@nextgis/webmap';\nimport type {\n  ControlPosition,\n  FitBoundsOptions,\n  GridLayer,\n  LatLngBoundsExpression,\n  Layer,\n  LeafletEvent,\n  LeafletMouseEvent,\n  LocationEvent,\n} from 'leaflet';\n\nexport type Type<T> = new (...args: any[]) => T;\nexport type UnselectCb = () => void;\nexport type UnselectDef = UnselectCb;\nexport class LeafletMapAdapter implements MapAdapter<Map, any, Control> {\n  static layerAdapters: {\n    [name: string]: Type<LayerAdapter<Map, any, any>>;\n  } = {\n    GEOJSON: GeoJsonAdapter,\n    IMAGE: ImageAdapter,\n    TILE: TileAdapter,\n    WMS: WmsAdapter,\n    // // MVT: MvtAdapter,\n    OSM: OsmAdapter,\n  };\n\n  static controlAdapters = {\n    ZOOM: Control.Zoom,\n    ATTRIBUTION: AttributionControl,\n  };\n\n  static Map = Map;\n\n  options: MapOptions<Map> = { target: 'map' };\n\n  layerAdapters = LeafletMapAdapter.layerAdapters;\n  controlAdapters = LeafletMapAdapter.controlAdapters;\n  emitter = new EventEmitter();\n  map?: Map;\n\n  private _resizeObserver?: ResizeObserver;\n  private _unselectCb: UnselectDef[] = [];\n  private _universalEvents: (keyof MainMapEvents)[] = [\n    'move',\n    'zoom',\n    'zoomend',\n    'zoomstart',\n    'moveend',\n    'movestart',\n  ];\n  private _positionEvents: (keyof MainMapEvents)[] = [\n    'mousemove',\n    'mouseout',\n    'mouseover',\n  ];\n\n  create(options: MapOptions<Map>): void {\n    this.options = { ...options };\n    if (this.options.target) {\n      const {\n        zoom,\n        center,\n        maxZoom,\n        minZoom,\n        maxBounds: mb,\n        mapAdapterOptions,\n      } = this.options;\n\n      this.map =\n        this.options.map ||\n        new Map(this.options.target, {\n          attributionControl: false,\n          zoomControl: false,\n          maxBounds: mb ? arrayToBoundsExpression(mb) : undefined,\n          maxZoom,\n          minZoom,\n          center: center && [center[1], center[0]],\n          zoom,\n          ...mapAdapterOptions,\n        });\n      // create default pane\n      const defPane = this.map.createPane('order-0');\n      (this.map as any)._addUnselectCb = (def: UnselectDef) => {\n        this._addUnselectCb(def);\n      };\n      defPane.style.zIndex = String(0);\n      this.emitter.emit('create', this);\n      this._addMapListeners();\n    }\n  }\n\n  destroy(): void {\n    if (this.map) {\n      this.map.remove();\n    }\n    this._stopWatchSizeChangeToUpdateMinZoom();\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this.map && this.map.getContainer();\n  }\n\n  getControlContainer(): HTMLElement {\n    const controlContainer = this.map && (this.map as any)._controlContainer;\n    if (controlContainer) {\n      return controlContainer;\n    }\n    throw new Error('Leaflet Map is not initialized yet');\n  }\n\n  setCursor(cursor: string): void {\n    if (this.map) {\n      this.map.getContainer().style.cursor = cursor;\n    }\n  }\n\n  setView(lngLat: LngLatArray, zoom?: number): void;\n  setView(options: ViewOptions): void;\n  setView(lngLatOrOpt: LngLatArray | ViewOptions, zoom?: number): void {\n    const map = this.map;\n    if (!map) return;\n    if (Array.isArray(lngLatOrOpt)) {\n      const lngLat = lngLatOrOpt;\n      const [lng, lat] = lngLat;\n      if (this.map) {\n        if (typeof zoom === 'number') {\n          this.map.setView([lat, lng], zoom, { animate: false });\n        } else {\n          this.setCenter([lng, lat]);\n        }\n      }\n    } else {\n      const { zoom, center, maxBounds, bounds, minZoom, maxZoom } = lngLatOrOpt;\n      if (center && zoom !== undefined) {\n        this.setView(center, zoom);\n      } else {\n        if (zoom !== undefined) {\n          this.setZoom(zoom);\n        }\n        if (center) {\n          this.setCenter(center);\n        }\n      }\n      if (bounds) {\n        this.fitBounds(bounds);\n      }\n      if (maxBounds !== undefined) {\n        if (maxBounds) {\n          const b = arrayToBoundsExpression(maxBounds);\n          map.setMaxBounds(b);\n          map.setMinZoom(map.getBoundsZoom(b));\n          this._watchSizeChangeToUpdateMinZoom(b);\n        } else {\n          // @ts-ignore `null` works for unset maxBounds, but not in typing\n          map.setMaxBounds(null);\n          this._stopWatchSizeChangeToUpdateMinZoom();\n        }\n      }\n      if (maxZoom !== undefined) {\n        map.setMaxZoom(maxZoom);\n      }\n      if (minZoom !== undefined) {\n        this._stopWatchSizeChangeToUpdateMinZoom();\n        map.setMinZoom(minZoom);\n      }\n    }\n  }\n\n  setCenter(lngLat: LngLatArray): void {\n    const [lng, lat] = lngLat;\n    if (this.map) {\n      this.map.panTo([lat, lng]);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    const map = this.map;\n    if (map) {\n      const bounds = map.getBounds();\n      const center = bounds.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom);\n    }\n  }\n\n  getZoom(): number | undefined {\n    return (this.map && this.map.getZoom()) ?? undefined;\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (!this.map) return undefined;\n    const b = this.map.getBounds();\n    const sw = b.getSouthWest();\n    const ne = b.getNorthEast();\n    return [sw.lng, sw.lat, ne.lng, ne.lat];\n  }\n\n  // [west, south, east, north]\n  fitBounds(bounds: LngLatBoundsArray, options: FitOptions = {}): void {\n    if (this.map) {\n      const { maxZoom, offset, padding } = options;\n      const opt: FitBoundsOptions = {};\n      if (maxZoom) {\n        opt.maxZoom = maxZoom;\n      }\n      if (padding) {\n        opt.padding = [padding, padding];\n      }\n      if (offset) {\n        opt.padding = offset;\n      }\n\n      this.map.fitBounds(arrayToBoundsExpression(bounds), opt);\n    }\n  }\n\n  getLayerAdapter(name: string): Type<LayerAdapter<Map, any, any>> {\n    return LeafletMapAdapter.layerAdapters[name];\n  }\n\n  createControl(control: MapControl, options: CreateControlOptions): Control {\n    return createControl(control, options, this);\n  }\n\n  createButtonControl(options: ButtonControlOptions): Control {\n    return createButtonControl(options, this);\n  }\n\n  addControl(control: Control, position: string): Control | undefined {\n    control.options.position = position.replace('-', '') as ControlPosition;\n    if (this.map) {\n      this.map.addControl(control);\n      return control;\n    }\n  }\n\n  removeControl(control: Control): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  removeLayer(layer: Layer): void {\n    layer && layer.remove && layer.remove();\n  }\n\n  showLayer(layer: Layer): void {\n    if (this.map) {\n      layer.addTo(this.map);\n    }\n  }\n\n  hideLayer(layer: Layer): void {\n    layer.remove();\n  }\n\n  setLayerOpacity(layer: GridLayer | Layer, value: number): void {\n    if ('setOpacity' in layer) {\n      layer.setOpacity(value);\n    }\n  }\n\n  setLayerOrder(\n    layer: Layer,\n    order: number,\n    layers: { [x: string]: LayerAdapter },\n  ): void {\n    //\n  }\n\n  onMapClick(evt: LeafletMouseEvent): void {\n    const converted = convertMapClickEvent(evt);\n    this.emitter.emit('preclick', converted);\n    this.emitter.emit('click', converted);\n  }\n\n  locate(opt: LocateOptions, events?: LocationEvents): Locate {\n    const map = this.map;\n    if (map) {\n      map.locate(opt);\n      if (events) {\n        const { locationfound, locationerror } = events;\n        const locationFound = (e: LeafletEvent) => {\n          const event = e as LocationEvent;\n          const lngLat: [number, number] = [event.latlng.lng, event.latlng.lat];\n          locationfound({ lngLat });\n        };\n        if (locationfound !== undefined) {\n          map.on('locationfound', locationFound, this);\n        }\n        if (locationerror) {\n          map.on('locationerror', locationerror, this);\n        }\n        const stop = () => {\n          if (locationfound !== undefined) {\n            map.off('locationfound', locationFound);\n          }\n          if (locationerror) {\n            map.off('locationerror', locationerror);\n          }\n        };\n        return { stop };\n      }\n    }\n    const stop = () => void 'fake function';\n    return { stop };\n  }\n\n  private _addUnselectCb(cb: UnselectDef) {\n    for (const p of this._unselectCb) {\n      p();\n    }\n    this._unselectCb.length = 0;\n    this._unselectCb.push(cb);\n  }\n\n  private _watchSizeChangeToUpdateMinZoom(bounds: LatLngBoundsExpression) {\n    this._stopWatchSizeChangeToUpdateMinZoom();\n    const container = this.getContainer();\n    const map = this.map;\n    if (container && map && window.ResizeObserver) {\n      this._resizeObserver = new ResizeObserver(() => {\n        map.setMinZoom(map.getBoundsZoom(bounds));\n      });\n      this._resizeObserver.observe(container);\n    }\n  }\n\n  private _stopWatchSizeChangeToUpdateMinZoom() {\n    const map = this.map;\n    if (map) {\n      map.setMinZoom(0);\n    }\n    if (this._resizeObserver) {\n      this._resizeObserver.disconnect();\n      this._resizeObserver = undefined;\n    }\n  }\n\n  private _addMapListeners() {\n    const map = this.map;\n    if (map) {\n      map.on('click', (evt) => {\n        this.onMapClick(evt as LeafletMouseEvent);\n      });\n      for (const e of this._universalEvents) {\n        map.on(e, () => this.emitter.emit(e, this), map);\n      }\n\n      for (const e of this._positionEvents) {\n        map.on(\n          e,\n          (evt) =>\n            this.emitter.emit(\n              e,\n              convertMapClickEvent(evt as LeafletMouseEvent),\n            ),\n          map,\n        );\n      }\n    }\n  }\n}\n","import { DomEvent } from 'leaflet';\n\nimport { createControl } from './createControl';\n\nimport type { ButtonControlOptions, MapAdapter } from '@nextgis/webmap';\nimport type { Control } from 'leaflet';\n\nexport function createButtonControl(\n  options: ButtonControlOptions,\n  map: MapAdapter,\n): Control {\n  const link = document.createElement('a');\n\n  const title = options.title || '';\n  link.href = '#';\n  link.title = title;\n\n  link.setAttribute('role', 'button');\n  link.setAttribute('aria-label', title);\n\n  if (options.addClass) {\n    link.classList.add(options.addClass);\n  }\n\n  DomEvent.disableClickPropagation(link);\n  DomEvent.on(link, 'click', DomEvent.stop);\n\n  if (options.html instanceof HTMLElement) {\n    link.appendChild(options.html);\n  } else if (typeof options.html === 'string') {\n    link.innerHTML = options.html;\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n\n  return createControl(\n    {\n      onAdd() {\n        if (options.onClick !== undefined) {\n          link.addEventListener('click', onClick);\n        }\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      },\n    },\n    { bar: true },\n    map,\n  );\n}\n","import { debounce, defined } from '@nextgis/utils';\nimport { DomEvent, FeatureGroup, GeoJSON } from 'leaflet';\n\nimport { boundsToArray } from '../../utils/boundsToArray';\nimport { detectType } from '../../utils/detectType';\nimport {\n  PAINT,\n  createFeaturePositionOptions,\n  filterGeometries,\n  typeAlias,\n} from '../../utils/geometries';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport { GeoJsonEvents } from './utils/GeoJsonEvents';\nimport { GeoJsonPaint } from './utils/GeojsonPaint';\n\nimport type { IconPaint, Paint, VectorAdapterLayerPaint } from '@nextgis/paint';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type {\n  DataLayerFilter,\n  GeoJsonAdapterOptions,\n  LayerDefinition,\n  OnLayerSelectType,\n  PopupOnCloseFunction,\n  PopupOptions,\n  VectorAdapterLayerType,\n  VectorLayerAdapter,\n} from '@nextgis/webmap';\nimport type { Feature, GeoJsonObject, Point } from 'geojson';\nimport type {\n  GeoJSONOptions,\n  PopupOptions as LPopupOptions,\n  LatLng,\n  LatLngExpression,\n  Layer,\n  LeafletMouseEvent,\n  Map,\n} from 'leaflet';\n\nexport type LayerDef = LayerDefinition<Feature, Layer>;\n\nexport class GeoJsonAdapter\n  extends BaseAdapter<GeoJsonAdapterOptions>\n  implements VectorLayerAdapter<Map>\n{\n  layer?: FeatureGroup;\n  selected = false;\n\n  type?: VectorAdapterLayerType;\n  _layers: LayerDef[] = [];\n  _events: GeoJsonEvents;\n  private paint?: Paint;\n  private selectedPaint?: Paint;\n\n  private _selectedLayers: LayerDef[] = [];\n  private _filteredLayers: LayerDef[] = [];\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _openedPopup: [Layer, PopupOnCloseFunction[], LayerDef][] = [];\n  private _paint: GeoJsonPaint;\n\n  private $updateTooltip = debounce(() => {\n    this.updateTooltip();\n  }, 300);\n\n  constructor(map: Map, options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this._events = new GeoJsonEvents(this);\n    this._paint = new GeoJsonPaint(this);\n  }\n\n  addLayer(options: GeoJsonAdapterOptions): FeatureGroup<any> | undefined {\n    Object.assign(this.options, options);\n    this.paint = options.paint;\n    this.layer = new FeatureGroup([], {\n      ...options.nativeOptions,\n      pane: this.pane,\n    });\n    this.selectedPaint = options.selectedPaint;\n    options.paint = this.paint;\n\n    if (options.data) {\n      this.addData(options.data);\n    }\n\n    this._addMapListener();\n\n    return this.layer;\n  }\n\n  beforeRemove(): void {\n    this._removeMapListener();\n  }\n\n  select(findFeatureFun?: DataLayerFilter): void {\n    this.unselect();\n    if (findFeatureFun) {\n      const def = this._layers.filter(findFeatureFun);\n      for (const x of def) {\n        this._selectLayer(x, 'api');\n      }\n    } else if (!this.selected) {\n      this.selected = true;\n      if (this.selectedPaint) {\n        this._paint.setPaintEachLayer(\n          this.selectedPaint as VectorAdapterLayerPaint,\n        );\n      }\n    }\n  }\n\n  unselect(findFeatureFun?: DataLayerFilter): void {\n    if (findFeatureFun) {\n      const feature = this._layers.filter(findFeatureFun);\n      feature.forEach((x) => {\n        this._unSelectLayer(x);\n      });\n    } else if (this.selected) {\n      for (const p of this._openedPopup) {\n        this._removePopup(p[0]);\n      }\n      if (this.paint) {\n        this._paint.setPaintEachLayer(this.paint as VectorAdapterLayerPaint);\n      }\n      this._selectedLayers.length = 0;\n      this.selected = false;\n    }\n  }\n\n  getSelected(): LayerDefinition<Feature, LayerDef>[] {\n    return this._selectedLayers.map((x) => {\n      return {\n        target: this,\n        feature: x.feature,\n        layer: x,\n        ...createFeaturePositionOptions(x.feature),\n      };\n    });\n  }\n\n  getFiltered(): LayerDef[] {\n    return this._filteredLayers;\n  }\n\n  filter(fun?: DataLayerFilter): LayerDef[] {\n    // Some optimization\n    this._filterFun = fun;\n    const layer_ = this.layer;\n    const map = layer_ && (layer_ as any)._map;\n    if (layer_ && map) {\n      layer_.remove();\n\n      const filteredLayers: LayerDef[] = [];\n      this._layers.forEach(({ feature, layer }) => {\n        if (layer) {\n          const ok = fun\n            ? fun({\n                target: this,\n                feature,\n                layer,\n                ...createFeaturePositionOptions(feature),\n              })\n            : true;\n          if (ok) {\n            layer_.addLayer(layer);\n            filteredLayers.push({\n              target: this,\n              feature,\n              layer,\n              ...createFeaturePositionOptions(feature),\n            });\n          } else {\n            layer_.removeLayer(layer);\n          }\n        }\n      });\n      this._filteredLayers = filteredLayers;\n\n      layer_.addTo(map);\n    }\n    return this._filteredLayers;\n  }\n\n  cleanFilter(): void {\n    this.filter();\n  }\n\n  getLayers(): LayerDef[] {\n    return this._layers.map(({ layer, feature }) => {\n      const visible = layer && !!(layer as any)._map;\n      return {\n        feature,\n        layer,\n        visible,\n        target: this,\n        ...createFeaturePositionOptions(feature),\n      };\n    });\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean): void {\n    this.unselect();\n    const layer_ = this.layer;\n    if (layer_) {\n      if (cb) {\n        for (let fry = this._layers.length; fry--; ) {\n          const def = this._layers[fry];\n          if (def) {\n            const { feature, layer } = def;\n            if (feature && layer) {\n              const exist = cb(feature);\n              if (exist) {\n                layer_.removeLayer(layer);\n                this._layers.splice(fry, 1);\n              }\n            }\n          }\n        }\n      } else {\n        layer_.clearLayers();\n        this._layers = [];\n      }\n    }\n  }\n\n  setData(data: GeoJsonObject): void {\n    this.clearLayer();\n    this.addData(data);\n  }\n\n  addData(data: GeoJsonObject | false): void {\n    const options = this.options;\n    let geoJsonOptions: GeoJSONOptions | undefined;\n    if (options) {\n      if (data) {\n        let type: VectorAdapterLayerType;\n\n        if (!options.type) {\n          const detectedType = detectType(data);\n          type = typeAlias[detectedType];\n        } else {\n          type = options.type;\n        }\n        if (this.type && this.type !== type) {\n          console.warn('no other data type than layer can be added');\n          return;\n        }\n        this.type = type;\n\n        data = filterGeometries(data, type);\n        if (data) {\n          geoJsonOptions = this._getGeoJsonOptions(options, type);\n        }\n      }\n      new GeoJSON(data || undefined, geoJsonOptions);\n    }\n  }\n\n  openPopup(findFeatureFun: DataLayerFilter, options?: PopupOptions): void {\n    if (findFeatureFun) {\n      const def = this._layers.filter(findFeatureFun);\n      def.forEach((x) => {\n        this._openPopup(x, options, 'api');\n      });\n    }\n  }\n\n  closePopup(findFeatureFun?: DataLayerFilter): void {\n    const popupToClose = findFeatureFun\n      ? this._openedPopup.filter((x) => findFeatureFun(x[2]))\n      : this._openedPopup;\n\n    popupToClose.forEach((x) => {\n      this._removePopup(x[0]);\n    });\n  }\n\n  updateTooltip(layerDef?: LayerDefinition): void {\n    if (layerDef) {\n      this._updateTooltip(layerDef);\n    } else {\n      this.getLayers().forEach((x) =>\n        this._updateTooltip({ feature: x.feature, layer: x.layer }),\n      );\n    }\n  }\n\n  /** @deprecated use {@link GeoJsonAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.layer) {\n      const bounds = this.layer.getBounds();\n      if (bounds.isValid()) {\n        return boundsToArray(bounds);\n      }\n    }\n  }\n\n  setOpacity(value: number): void {\n    this.options.opacity = value;\n    this.setPaint(this.paint);\n    this.setSelectedPaint(this.selectedPaint);\n  }\n\n  setPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.paint = paint;\n      for (const l of this._layers) {\n        this._paint.setPaint(l, paint as VectorAdapterLayerPaint);\n      }\n    }\n  }\n  setSelectedPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.selectedPaint = paint;\n      for (const l of this._selectedLayers) {\n        this._paint.setPaint(l, paint as VectorAdapterLayerPaint);\n      }\n    }\n  }\n  updatePaint(paint: Partial<Paint>): void {\n    this.paint = { ...this.paint, ...paint } as Paint;\n    for (const l of this._layers) {\n      this._paint.setPaint(l, this.paint as VectorAdapterLayerPaint);\n    }\n  }\n  updateSelectedPaint(paint: Partial<Paint>): void {\n    this.selectedPaint = { ...this.selectedPaint, ...paint } as Paint;\n    for (const l of this._selectedLayers) {\n      this._paint.setPaint(l, this.selectedPaint as VectorAdapterLayerPaint);\n    }\n  }\n\n  _getSelected(layer: LayerDef['layer']) {\n    return this._selectedLayers.find((x) => x.layer === layer);\n  }\n\n  private $unselect = () => {\n    this.unselect();\n  };\n\n  private _updateTooltip(layerDef: Pick<LayerDef, 'feature' | 'layer'>) {\n    const { feature, layer } = layerDef;\n    const { label, labelField, labelOnHover } = this.options;\n    if (layer) {\n      layer.unbindTooltip();\n      let message: string | undefined;\n      if (feature.properties && labelField) {\n        message = feature.properties[labelField];\n      } else if (label) {\n        message = label({\n          target: this,\n          ...layerDef,\n          ...createFeaturePositionOptions(feature),\n        });\n      }\n      if (message) {\n        const permanent = !labelOnHover;\n        layer.bindTooltip(String(message), { permanent, sticky: false });\n      }\n    }\n  }\n\n  private async _openPopup(\n    def: LayerDef,\n    options: PopupOptions = {},\n    type: OnLayerSelectType,\n    latLng?: LatLngExpression,\n  ) {\n    const { feature, layer } = def;\n    const {\n      minWidth,\n      autoPan,\n      maxWidth,\n      closeButton: closeButton_,\n    } = {\n      minWidth: 300,\n      ...options,\n    };\n    const closeButton = closeButton_ ?? !this.options.selectOnHover;\n    let popup: Layer;\n    const _closeHandlers: PopupOnCloseFunction[] = [];\n    const onClose = (handler: PopupOnCloseFunction) => {\n      _closeHandlers.push(handler);\n    };\n    const close = () => {\n      if (popup) {\n        this._removePopup(popup);\n      }\n    };\n    let content;\n    if (options.createPopupContent) {\n      content = await options.createPopupContent({\n        layer,\n        feature,\n        target: this,\n        type,\n        close,\n        onClose,\n        ...createFeaturePositionOptions(feature),\n      });\n    } else {\n      content = options.popupContent;\n    }\n\n    if (content && layer) {\n      const popupOptions: LPopupOptions = {\n        minWidth,\n        autoPan,\n        // maxWidth,\n        closeButton,\n        closeOnClick: false,\n        autoClose: false,\n      };\n      if (defined(maxWidth)) {\n        popupOptions.maxWidth = maxWidth;\n      }\n      popup = layer.bindPopup(content, popupOptions);\n\n      const unselectOnClose =\n        this.options.popupOptions?.unselectOnClose ?? true;\n      if (unselectOnClose) {\n        const p = layer.getPopup();\n        p &&\n          p.once(\n            'remove',\n            () => {\n              close();\n            },\n            this,\n          );\n      }\n      this._openedPopup.push([popup, _closeHandlers, def]);\n      popup.openPopup(latLng);\n    }\n  }\n\n  private _removePopup(popup: Layer) {\n    const map = this.map;\n    if (map) {\n      popup.closePopup().unbindPopup();\n      const index = this._openedPopup.findIndex((x) => x[0] === popup);\n      if (index !== -1) {\n        const unselectOnClose =\n          this.options.popupOptions?.unselectOnClose ?? true;\n        const [, closeHandlers, def] = this._openedPopup[index];\n        for (const h of closeHandlers) {\n          h(def);\n        }\n        closeHandlers.length = 0;\n        if (unselectOnClose) {\n          this._unSelectLayer(def);\n        }\n        this._openedPopup.splice(index, 1);\n      }\n    }\n  }\n\n  private _getGeoJsonOptions(\n    options: GeoJsonAdapterOptions,\n    type: VectorAdapterLayerType,\n  ): GeoJSONOptions {\n    const paint = options.paint;\n    let lopt: GeoJSONOptions = {};\n\n    if (typeof paint === 'function') {\n      if (type === 'point') {\n        // TODO: fix types (@geoman-io/leaflet-geoman-free)\n        (lopt as any).pointToLayer = (\n          feature: Feature<Point, any>,\n          latLng: LatLng,\n        ) => {\n          const iconOpt = paint(feature);\n          const pointToLayer = this._paint.createPaintToLayer(\n            iconOpt as IconPaint,\n          );\n          return pointToLayer(feature, latLng);\n        };\n      } else {\n        lopt = {\n          style: (feature) => {\n            if (feature) {\n              return this._paint.preparePaint({ ...PAINT, ...paint(feature) });\n            } else {\n              return this._paint.preparePaint({ ...PAINT, type: 'path' });\n            }\n          },\n        };\n      }\n    } else {\n      lopt = this._paint.createPaintOptions(paint as VectorAdapterLayerPaint);\n    }\n\n    lopt.onEachFeature = (feature: Feature, layer) => {\n      this._onEachFeature(feature, layer);\n    };\n\n    return lopt;\n  }\n\n  private _onEachFeature(feature: Feature, layer: Layer) {\n    const layer_ = this.layer;\n    if (layer_) {\n      const def = {\n        target: this,\n        feature,\n        layer,\n        ...createFeaturePositionOptions(feature),\n      };\n      // @ts-ignore\n      layer.options.pane = this.pane;\n      this._layers.push(def);\n      let ok = true;\n      if (this._filterFun) {\n        ok = this._filterFun(def);\n      }\n      if (ok) {\n        const { popup, popupOptions, selectable, interactive, selectOnHover } =\n          this.options;\n        // @ts-ignore\n        layer.options.interactive = defined(interactive) ? interactive : true;\n        layer_.addLayer(layer);\n        if (selectable) {\n          if (selectOnHover) {\n            layer.on('mouseover', () => {\n              this._selectLayer(def, 'hover');\n            });\n            layer.on('mouseout', () => {\n              this._unSelectLayer(def);\n            });\n          } else {\n            layer.on(\n              'click',\n              (e) => this._selectOnLayerClick(e as LeafletMouseEvent),\n              this,\n            );\n          }\n        }\n        this._events.handleMouseEvents(layer);\n        // The timeout is needed to display the popup immediately when adding a layer to the map.\n        // Without a timeout, the layer may not yet have a _map object\n        setTimeout(() => {\n          if (popup) {\n            this._openPopup(\n              {\n                target: this,\n                layer,\n                feature,\n                ...createFeaturePositionOptions(feature),\n              },\n              popupOptions,\n              'api',\n            );\n          }\n          this._updateTooltip({ layer, feature });\n        });\n      }\n    }\n  }\n\n  private _selectOnLayerClick(e: LeafletMouseEvent) {\n    DomEvent.stopPropagation(e);\n    const layer = e.target as Layer;\n    const feature = (layer as any).feature;\n    const def: LayerDef = {\n      target: this,\n      layer,\n      feature,\n      ...createFeaturePositionOptions(feature),\n    };\n    const isSelected = this._getSelected(layer);\n    if (isSelected) {\n      if (this.options && this.options.unselectOnSecondClick) {\n        this._unSelectLayer(isSelected);\n      }\n    } else {\n      this._selectLayer(def, 'click', e.latlng);\n    }\n  }\n\n  private _selectLayer(\n    def: LayerDef,\n    type: OnLayerSelectType,\n    latlng?: LatLngExpression,\n  ) {\n    const { multiselect } = this.options;\n    if (!multiselect) {\n      // To unselect layer on another layer click\n      (this.map as any)._addUnselectCb(() => {\n        this._unSelectLayer(def);\n      });\n      this._selectedLayers.forEach((x) => this._unSelectLayer(x));\n    }\n    this._selectedLayers.push(def);\n    this.selected = true;\n    const { selectedPaint, popupOnSelect, popupOptions } = this.options;\n\n    if (selectedPaint && def.layer) {\n      this._paint.setPaint(def, selectedPaint as VectorAdapterLayerPaint);\n    }\n    if (popupOnSelect) {\n      this._openPopup(def, popupOptions, type, latlng);\n    }\n    if (this.options.onSelect) {\n      const features = def.feature ? [def.feature] : [];\n      this.options.onSelect({\n        type,\n        layer: this,\n        features,\n        ...createFeaturePositionOptions(features),\n      });\n    }\n  }\n\n  private _unSelectLayer(def: LayerDef) {\n    const index = this._selectedLayers.indexOf(def);\n    if (index !== -1) {\n      this._selectedLayers.splice(index, 1);\n      if (this.options) {\n        if (this.options.paint) {\n          this._paint.setPaint(\n            def,\n            this.options.paint as VectorAdapterLayerPaint,\n          );\n        }\n\n        if (this.options.popupOnSelect && def.layer) {\n          this._removePopup(def.layer);\n        }\n      }\n    }\n    this.selected = this._selectedLayers.length > 0;\n  }\n\n  private _addMapClickListener() {\n    const map = this.map;\n    if (map) {\n      const { unselectOnClick } = this.options;\n      const uoc = unselectOnClick ?? true;\n      if (uoc) {\n        map.on('click', this.$unselect);\n      }\n    }\n  }\n\n  private _removeMapClickListener() {\n    this.map.off('zoomend', this.$updateTooltip);\n    this.map.off('moveend', this.$updateTooltip);\n    this.map.off('click', this.$unselect);\n  }\n\n  private _addMapListener() {\n    const map = this.map;\n    if (map) {\n      const { label, labelField, labelOnHover } = this.options;\n      this._addMapClickListener();\n      if ((labelField || label) && !labelOnHover) {\n        map.on('zoomend', this.$updateTooltip);\n        map.on('moveend', this.$updateTooltip);\n      }\n    }\n  }\n\n  private _removeMapListener() {\n    this._removeMapClickListener();\n    this.map.off('zoomend', this.$updateTooltip);\n    this.map.off('moveend', this.$updateTooltip);\n  }\n}\n","import { BaseAdapter } from '../BaseAdapter';\n\nimport { ImageLayer } from './ImageLayer';\n\nimport type { MainLayerAdapter } from '@nextgis/webmap';\nimport type { ImageAdapterOptions } from '@nextgis/webmap';\nimport type { Map } from 'leaflet';\n\nexport class ImageAdapter\n  extends BaseAdapter<ImageAdapterOptions>\n  implements MainLayerAdapter<Map>\n{\n  layer: any;\n\n  addLayer(options: ImageAdapterOptions): any {\n    const url = options && options.url;\n    if (url) {\n      options = { transparent: true, ...options };\n      const updateWmsParamsFromOpt = options.updateWmsParams;\n      this.layer = new ImageLayer(url, {\n        pane: this.pane,\n        headers: options.headers,\n        setViewDelay: options.setViewDelay,\n        /**\n         * TODO: safe remove, use only options.nativeOptions\n         */\n        ...options,\n        ...options.params,\n        ...options.nativeOptions,\n      });\n      if (updateWmsParamsFromOpt) {\n        const updateWmsParams = this.layer.updateWmsParams;\n        this.layer.updateWmsParams = function (map: Map) {\n          updateWmsParams.call(this, map);\n          this.wmsParams = updateWmsParamsFromOpt(this.wmsParams);\n        };\n      }\n      return this.layer;\n    }\n  }\n}\n","import { TileLayer } from 'leaflet';\n\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport { WmsLayer as WMS } from './WmsLayer';\n\nimport type { MainLayerAdapter, WmsAdapterOptions } from '@nextgis/webmap';\nimport type { WMSOptions } from 'leaflet';\n\nexport class WmsAdapter\n  extends BaseAdapter<WmsAdapterOptions, TileLayer.WMS>\n  implements MainLayerAdapter\n{\n  addLayer(options: WmsAdapterOptions): TileLayer.WMS | undefined {\n    Object.assign(this.options, options);\n    const { url, ...opt } = options;\n    if (url) {\n      const layerOptions: WMSOptions = {\n        pane: this.pane,\n        attribution: opt.attribution,\n        minZoom: opt.minZoom,\n        maxZoom: opt.maxZoom,\n        layers: options.layers,\n        format: options.format,\n        ...options.nativeOptions,\n      };\n      let layer;\n      if (opt.headers) {\n        layer = new WMS(url, { ...layerOptions, headers: opt.headers });\n      } else {\n        layer = new TileLayer.WMS(url, layerOptions);\n      }\n      return layer;\n    }\n  }\n}\n","import { TileAdapter } from './TileAdapter/TileAdapter';\n\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { TileLayer } from 'leaflet';\n\nexport class OsmAdapter extends TileAdapter implements MainLayerAdapter {\n  addLayer(options: Omit<TileAdapterOptions, 'url'>): TileLayer | undefined {\n    const url = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    return super.addLayer({\n      name: 'OpenStreetMap',\n      attribution:\n        '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n      ...options,\n      url,\n    });\n  }\n}\n","/**\n * @module leaflet-map-adapter\n */\n\nimport { LeafletMapAdapter } from './LeafletMapAdapter';\n\nexport default LeafletMapAdapter;\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { isPropertyFilter } from '@nextgis/properties-filter';\nimport {\n  defined,\n  degrees2meters,\n  getBoundsCoordinates,\n  isLngLatBoundsArray,\n  round,\n} from '@nextgis/utils';\n\nimport type {\n  FeatureRequestParams,\n  FetchNgwItemsOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\nimport type {\n  FeatureItem,\n  RequestItemAdditionalParams,\n} from '@nextgis/ngw-connector';\nimport type {\n  PropertiesFilter,\n  PropertyFilter,\n} from '@nextgis/properties-filter';\nimport type { FeatureProperties, LngLatArray } from '@nextgis/utils';\nimport type { Feature, Geometry } from 'geojson';\n\nexport const FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson',\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    geometry,\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n  };\n  return feature;\n}\n\nexport function updateItemRequestParam<\n  P extends FeatureProperties = FeatureProperties,\n>(params: FeatureRequestParams, options: NgwFeatureRequestOptions<P>): void {\n  const { extensions, geom, fields, srs, ilike, like } = options;\n  // Empty extesions by default\n  const extensionsStr = extensions ? extensions.join(',') : '';\n  // Use character * to set all extensions\n  if (extensionsStr !== '*') {\n    params.extensions = extensionsStr;\n  }\n\n  if (fields !== undefined) {\n    params.fields = Array.isArray(fields) ? fields.join(',') : '';\n  }\n  if (geom !== undefined) {\n    params.geom = geom ? 'yes' : 'no';\n    if (!geom) {\n      delete params.srs;\n      delete params.geom_format;\n    }\n  }\n  if (defined(ilike)) {\n    params.ilike = ilike;\n  } else if (defined(like)) {\n    params.like = like;\n  }\n  if (defined(srs)) {\n    params.srs = srs;\n  }\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nexport function createFeatureFieldFilterQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const queries: CancelablePromise<FeatureItem<P, G>[]>[] = getQueries<G, P>(\n    opt,\n  );\n\n  return CancelablePromise.all(queries).then((itemsParts) => {\n    // this list of ids used for optimization\n    const ids: number[] = [];\n    const items: FeatureItem<P, G>[] = [];\n    for (const part of itemsParts) {\n      for (const item of part) {\n        if (!ids.includes(item.id)) {\n          items.push(item);\n          ids.push(item.id);\n        }\n      }\n    }\n    const offset = opt.offset !== undefined ? opt.offset : 0;\n    const limit = opt.limit !== undefined ? opt.limit : items.length;\n    if (opt.offset || opt.limit) {\n      return items.splice(offset, limit);\n    }\n    return items;\n  });\n}\n\nfunction createParam(pf: PropertyFilter): [string, any] {\n  const [field, operation, value] = pf;\n  const isFldStr = field !== 'id' ? 'fld_' : '';\n  let vStart = '';\n  let vEnd = '';\n  const field_ = String(field)\n    .trim()\n    .replace(/^(%?)(.+?)(%?)$/, (m, a, b, c) => {\n      vStart = a;\n      vEnd = c;\n      return b;\n    });\n  const v = vStart + value + vEnd;\n  return [`${isFldStr}${field_}__${operation}`, v];\n}\n\nfunction getQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(\n  opt: FetchNgwItemsOptions<P> &\n    Required<Pick<FetchNgwItemsOptions, 'filters'>>,\n  _queries: CancelablePromise<FeatureItem<P, G>[]>[] = [],\n  _parentAllParams: [string, any][] = [],\n): CancelablePromise<FeatureItem<P, G>[]>[] {\n  const { filters } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter((x) => Array.isArray(x)) as PropertyFilter[];\n\n  if (logic === 'any') {\n    for (const f of filters_) {\n      if (isPropertyFilter(f)) {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)],\n          }),\n        );\n      } else {\n        getQueries(\n          {\n            ...opt,\n            filters: f,\n          },\n          _queries,\n          [..._parentAllParams],\n        );\n      }\n    }\n  } else if (logic === 'all') {\n    const filters: [string, any][] = [];\n    const propertiesFilterList: PropertiesFilter[] = [];\n    for (const f of filters_) {\n      if (isPropertyFilter(f)) {\n        filters.push(createParam(f));\n      } else {\n        propertiesFilterList.push(f);\n      }\n    }\n\n    if (propertiesFilterList.length) {\n      for (const x of propertiesFilterList) {\n        getQueries(\n          {\n            ...opt,\n            filters: x,\n          },\n          _queries,\n          [..._parentAllParams, ...filters],\n        );\n      }\n    } else {\n      _queries.push(\n        fetchNgwLayerItemsRequest<G, P>({\n          ...opt,\n          paramList: [..._parentAllParams, ...filters],\n        }),\n      );\n    }\n  }\n  return _queries;\n}\n\nfunction createWktFromCoordArray(coord: LngLatArray[]): string {\n  const polygon = coord.map(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat).map((c) => round(c));\n    return x + ' ' + y;\n  });\n  return `POLYGON((${polygon.join(', ')}))`;\n}\n\nexport function fetchNgwLayerItemsRequest<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any },\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  const {\n    limit,\n    cache,\n    signal,\n    offset,\n    orderBy,\n    paramList,\n    connector,\n    geomFormat,\n    intersects,\n    resourceId,\n  } = options;\n  if (limit) {\n    if (limit !== Number.POSITIVE_INFINITY) {\n      params.limit = limit;\n    }\n  } else {\n    // Strict restriction on loading data from large layers\n    params.limit = 7000;\n  }\n  if (offset) {\n    params.offset = offset;\n  }\n  if (geomFormat) {\n    params.geom_format = geomFormat;\n  }\n  updateItemRequestParam(params, options);\n\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  if (Array.isArray(intersects)) {\n    const coordinates = isLngLatBoundsArray(intersects)\n      ? getBoundsCoordinates(intersects)\n      : intersects;\n\n    params.intersects = createWktFromCoordArray(coordinates);\n  } else if (typeof intersects === 'string') {\n    params.intersects = intersects;\n  }\n\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  const reqParams = {\n    id: resourceId,\n    ...params,\n  };\n\n  return connector.get(\n    'feature_layer.feature.collection',\n    { cache, signal },\n    reqParams,\n  ) as CancelablePromise<FeatureItem<P, G>[]>;\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\nimport { isArray } from '@nextgis/utils';\n\nimport {\n  createFeatureFieldFilterQueries,\n  fetchNgwLayerItemsRequest,\n} from './featureLayerUtils';\nimport { prepareNgwFieldsToPropertiesFilter } from './prepareNgwFieldsToPropertiesFilter';\n\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { Geometry } from 'geojson';\n\nexport function fetchNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<FeatureItem<P, G>[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({\n      ...options,\n      filters,\n    }).then((data) => {\n      const clientFilterValidate =\n        options.clientFilterValidate ?? isFilterWithAnyCase(filters);\n      // Additional client-side filter check\n      if (clientFilterValidate) {\n        data = data.filter((y) => {\n          const fields = prepareNgwFieldsToPropertiesFilter({\n            ...y.fields,\n            id: y.id,\n          });\n          const result = propertiesFilter(fields, filters);\n          return result;\n        });\n      }\n      return data;\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  } else {\n    return fetchNgwLayerItemsRequest<G, P>(options);\n  }\n}\n\nfunction isFilterWithAnyCase(filters: PropertiesFilter): boolean {\n  if (filters[0] === 'any') {\n    return true;\n  }\n  for (let i = 1; i < filters.length; i++) {\n    const p = filters[i];\n    if (isArray(p)) {\n      const deep = isFilterWithAnyCase(p);\n      if (deep) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import { defined, isObject } from '@nextgis/utils';\n\nimport type { NgwDateFormat, NgwDateTimeFormat } from '@nextgis/ngw-connector';\n\nexport function prepareNgwFieldsToPropertiesFilter(\n  fields: Record<string, any>,\n): Record<string, any> {\n  let f: keyof typeof fields;\n  for (f in fields) {\n    const field = fields[f];\n    if (isObject(field)) {\n      const date = field as NgwDateFormat | NgwDateTimeFormat;\n      if (defined(date.year) && defined(date.month) && defined(date.day)) {\n        const dt: [number, number, number, number?, number?, number?] = [\n          date.year,\n          date.month - 1,\n          date.day,\n        ];\n        if ('hour' in date) {\n          [date.hour, date.minute, date.second].forEach((x) => {\n            dt.push(x);\n          });\n        }\n        fields[f] = new Date(...dt).toISOString();\n      }\n    } else if (f === 'id' && typeof field === 'string') {\n      fields[f] = field.split(',').map(Number);\n    }\n  }\n  return fields;\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport {\n  FEATURE_REQUEST_PARAMS,\n  createGeoJsonFeature,\n  updateItemRequestParam,\n} from './featureLayerUtils';\n\nimport type {\n  FeatureRequestParams,\n  FetchNgwItemOptions,\n  NgwFeatureItemResponse,\n} from '../interfaces';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { Geometry } from 'geojson';\n\nexport function fetchNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G>> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  updateItemRequestParam(params, options);\n  const queryParams = {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params,\n  };\n  const cache = options.cache || true;\n  return options.connector\n    .get('feature_layer.feature.item', { cache }, queryParams)\n    .then((resp) => {\n      return {\n        ...resp,\n        toGeojson: () => {\n          if (resp.geom) {\n            return CancelablePromise.resolve(createGeoJsonFeature<G, P>(resp));\n          } else {\n            return fetchNgwLayerItem({\n              ...options,\n              geom: true,\n              fields: null,\n              extensions: null,\n            }).then((onlyGeomItem) => {\n              const geom = onlyGeomItem.geom;\n              return createGeoJsonFeature<G, P>({ ...resp, geom });\n            });\n          }\n        },\n      } as NgwFeatureItemResponse<P, G>;\n    });\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport { createGeoJsonFeature, fetchNgwLayerItem } from '@nextgis/ngw-kit';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type { Feature, Point } from 'geojson';\n\ninterface BookmarkItemOptions {\n  connector: NgwConnector;\n  resourceId: number;\n  item: FeatureItem;\n  labelField?: string;\n}\n\nexport class BookmarkItem {\n  readonly name: string;\n  readonly resourceId: number;\n  readonly item: FeatureItem;\n\n  private _extent?: LngLatBoundsArray;\n\n  constructor(private options: BookmarkItemOptions) {\n    this.resourceId = options.resourceId;\n    const item = options.item;\n    this.item = item;\n    if (options.labelField && item.fields) {\n      this.name = item.fields[options.labelField];\n    } else {\n      this.name = String(item.id);\n    }\n  }\n\n  extent(): CancelablePromise<LngLatBoundsArray> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return this.options.connector\n      .get('feature_layer.feature.item_extent', null, {\n        id: this.resourceId,\n        fid: this.item.id,\n      })\n      .then((resp) => {\n        const { minLat, minLon, maxLat, maxLon } = resp.extent;\n        const lonLat = [minLon, minLat, maxLon, maxLat];\n        this._extent = lonLat;\n        return lonLat;\n      });\n  }\n\n  geoJson(): CancelablePromise<Feature<Point, any>> {\n    if (this.item.geom) {\n      return CancelablePromise.resolve(createGeoJsonFeature(this.item));\n    } else {\n      return fetchNgwLayerItem({\n        resourceId: this.resourceId,\n        featureId: this.item.id,\n        connector: this.options.connector,\n        geom: true,\n        fields: null,\n        extensions: null,\n      }).then((onlyGeomItem) => {\n        const geom = onlyGeomItem.geom;\n        this.item.geom = geom;\n        return createGeoJsonFeature(this.item);\n      });\n    }\n  }\n}\n","import { propertiesFilter } from '@nextgis/properties-filter';\n\nimport type {\n  DefaultTreeItem,\n  RelationFunction,\n  SelfFilter,\n  TreeRelation,\n} from './interfaces';\nimport type { PropertyFilter } from '@nextgis/properties-filter';\n\ntype D = DefaultTreeItem;\n\ntype TreeFunction<X extends D> = (\n  item: X | X[],\n  filter: SelfFilter<X>,\n  relation: TreeRelation<X>,\n) => X | X[] | boolean | undefined;\n\ntype ItemPrepareFunction<F extends D> = (item: D) => F;\n\nexport function treeEvery<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): boolean {\n  return !!treeWrapper<F>(item, filter, relation, treeEvery_, itemPrepare);\n}\n\nexport function treeSome<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): boolean {\n  return !!treeWrapper<F>(item, filter, relation, treeFind_, itemPrepare);\n}\n\nexport function treeFind<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): F | undefined {\n  return treeWrapper<F>(item, filter, relation, treeFind_, itemPrepare) as F;\n}\n\nexport function treeFilter<F extends D = D>(\n  item: F | F[],\n  filter?: PropertyFilter | SelfFilter<F>,\n  relation?: TreeRelation<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): F[] {\n  return treeWrapper<F>(\n    item,\n    filter,\n    relation,\n    treeFilter_,\n    itemPrepare,\n  ) as F[];\n}\n\nexport function getChildren<F extends D = D>(\n  item: F,\n  relation: TreeRelation<F> = 'children',\n): F[] | undefined {\n  let children: F[] = [];\n  const relationFunction: RelationFunction<F> =\n    typeof relation === 'function' ? relation : (i): F[] => i[relation];\n  const relChild = relationFunction(item);\n  if (relChild) {\n    if (Array.isArray(relChild)) {\n      children = relChild;\n    } else {\n      children.push(relChild);\n    }\n  }\n  return relChild ? children : undefined;\n}\n\nfunction treeWrapper<F extends D = D>(\n  item: F | F[],\n  filter: PropertyFilter | SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F> = 'children',\n  treeFunction: TreeFunction<F>,\n  itemPrepare?: ItemPrepareFunction<F>,\n): F[] | F | boolean | undefined {\n  const filterFunction: SelfFilter<F> =\n    typeof filter === 'function'\n      ? filter\n      : (i: F): boolean => propertiesFilter(i, filter);\n  if (itemPrepare) {\n    return treeFunction(\n      item,\n      (i: F): boolean => filterFunction(itemPrepare(i)),\n      relation,\n    );\n  }\n  return treeFunction(item, filterFunction, relation);\n}\n\nfunction treeFind_<F extends D = D>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F>,\n  _filtered: F[] = [],\n): F | undefined {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      return item;\n    }\n    const relChildren = getChildren(item, relation);\n    if (relChildren) {\n      children = relChildren;\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      const result = treeFind_(children[fry], filterFunc, relation, _filtered);\n      if (result) {\n        return result;\n      }\n    }\n  }\n}\n\nfunction treeFilter_<F extends D = D>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F>,\n  _filtered: F[] = [],\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChildren = getChildren(item, relation);\n    if (relChildren) {\n      children = relChildren;\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      treeFilter_(children[fry], filterFunc, relation, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n\nfunction treeEvery_<F extends D = D>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F): boolean => !!x,\n  relation: TreeRelation<F>,\n  _filtered: F[] = [],\n): boolean {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (!filter) {\n      return false;\n    }\n    const relChildren = getChildren(item, relation);\n    if (relChildren) {\n      children = relChildren;\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      const res = treeEvery_(children[fry], filterFunc, relation, _filtered);\n      if (!res) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n","import { treeEvery, treeFilter, treeFind, treeSome } from '@nextgis/tree';\n\nimport type { Item } from './Item';\nimport type { ItemOptions } from './interfaces';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  setParent(parent: Item): void {\n    this._parent = parent;\n  }\n\n  addChild(child: Item): void {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return treeFilter<I>(\n        parent,\n        filterFunc,\n        (x: I) => x.tree.getParent() as I,\n      );\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n\n  find(filterFunc?: (item: Item) => boolean): Item<ItemOptions> | undefined {\n    return treeFind(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  every<I extends Item = Item>(filterFunc?: (item: I) => boolean): boolean {\n    return treeEvery(this._children as I[], filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  some<I extends Item = Item>(filterFunc?: (item: I) => boolean): boolean {\n    return treeSome(this._children as I[], filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return treeFilter(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return [...this._children] as T[];\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport type { Item } from '../Item';\nimport type { ItemBasePropertyOptions, ItemOptions } from '../interfaces';\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>,\n  I extends Item = Item,\n> {\n  options: O;\n\n  emitter = new EventEmitter();\n  name: string;\n\n  item: I;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: I, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty(): V | undefined {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent(): Item<ItemOptions> | undefined {\n    return this.item.tree.getParent();\n  }\n\n  getChildren(): Item<ItemOptions>[] {\n    return this.item.tree.getChildren();\n  }\n\n  isGroup(): number {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked(): boolean {\n    if (this._blocked !== undefined) {\n      return this._blocked;\n    }\n\n    const parents = this.item.tree.getParents();\n    this._blocked = this._calculateBlockedStatus(parents);\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O): void {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O): void {\n    this._callOnSet(value, options);\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this._container;\n  }\n\n  destroy(): void {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O): void {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O): void {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach((x) => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', {\n            value,\n            options,\n            item: this.item,\n          });\n        }\n      });\n    }\n  }\n\n  private _calculateBlockedStatus(parents: Item[]): boolean {\n    const isBlocked = parents.some((parent: Item) => {\n      const parentProp = parent.properties?.property(this.name);\n      return parentProp ? !parentProp.get() : false;\n    });\n\n    return isBlocked;\n  }\n}\n","import { BaseProperty } from './BaseProperty';\n\nimport type { Item } from '../Item';\nimport type { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\ntype PreparedValue = any;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>,\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle',\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O): void {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false }),\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue(): boolean | undefined {\n    return (\n      this.get() &&\n      this.getParents().every((x) => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  block(options?: O): void {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  unBlock(options?: O): void {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  blockChild(options?: O): void {\n    this.item.tree\n      .getDescendants()\n      .forEach((x) => this._blockChild(x, options));\n  }\n\n  unblockChild(options?: O): void {\n    this.item.tree.getChildren().forEach((x) => this._unBlockChild(x, options));\n  }\n\n  protected _prepareValue(value?: PreparedValue): V | undefined {\n    return value;\n  }\n\n  private _turnOff(options?: O): void {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChild(options);\n    }\n  }\n\n  private _turnOn(options?: O): void {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChild(options);\n    }\n  }\n\n  private _block(options?: O): void {\n    this._turnOff(options);\n  }\n\n  private _unBlock(options?: O): void {\n    this._turnOn(options);\n  }\n\n  private _blockChild(item: Item, options?: O): void {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  private _unBlockChild(item: Item, options?: O): void {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  private _propagation(value?: V, options?: O): void {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false,\n            },\n          });\n        }\n      }\n    }\n  }\n}\n","import { CheckProperty } from './CheckProperty';\n\nimport type { BaseProperty } from './BaseProperty';\nimport type { Item } from '../Item';\nimport type {\n  ItemBasePropertyOptions,\n  ItemPropertyConfig,\n  ItemPropertyTypes,\n  Type,\n} from '../interfaces';\n\n// Constants for property types\nconst BOOLEAN_TYPE = 'boolean';\nconst STRING_TYPE = 'string';\n\nexport class ItemProperties {\n  static handlers: Record<string, Type<BaseProperty>> = {\n    CheckProperty,\n  };\n\n  options: Record<string, any> = {};\n\n  private _properties: Record<string, BaseProperty> = {};\n  private _propertiesList: string[] = [];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[],\n  ) {\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>): void {\n    this._setPropertyHandler(propOpt);\n  }\n\n  update(): void {\n    this.list().forEach((x) => x.update());\n  }\n\n  get(name: string): any {\n    const prop = this.property(name);\n    return prop ? prop.get() : undefined;\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>,\n  ): void {\n    const prop = this.property(name);\n    if (prop && prop.getValue() !== value) {\n      prop.set(value, options);\n    }\n  }\n\n  property(name: string): BaseProperty<any, ItemBasePropertyOptions<any>> {\n    return this._properties[name];\n  }\n\n  list(): BaseProperty<any, ItemBasePropertyOptions<any>>[] {\n    return this._propertiesList.map((name) => this._properties[name]);\n  }\n\n  destroy(): void {\n    for (const name in this._properties) {\n      const prop = this.property(name);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n\n  private _setPropertyHandler(\n    propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>,\n  ): void {\n    const Handler = this._getHandler(propOpt);\n    if (Handler && propOpt.name) {\n      const options = { ...propOpt };\n      this._properties[propOpt.name] = new Handler(\n        propOpt.name,\n        this.item,\n        options,\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  private _getHandler(\n    propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>,\n  ): Type<BaseProperty> | undefined {\n    const Handler = propOpt.handler;\n    if (!Handler && propOpt.type) {\n      switch (propOpt.type) {\n        case BOOLEAN_TYPE:\n          return ItemProperties.handlers.CheckProperty;\n        case STRING_TYPE:\n        default:\n          return ItemProperties.handlers.BaseProperty;\n      }\n    }\n    return Handler;\n  }\n}\n","import { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\n\nimport type { ItemOptions } from './interfaces';\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties(): void {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport { Item } from '@nextgis/item';\nimport { treeSome } from '@nextgis/tree';\n\nimport { WebmapLayerOpacityPropertyHandler } from './utils/WebmapLayerOpacityPropertyHandler';\nimport { setScaleRatio } from './utils/utils';\n\nimport type { TreeGroup, TreeItem, TreeLayer } from './interfaces';\nimport type { ItemOptions } from '@nextgis/item';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type {\n  GetLegendOptions,\n  ImageAdapterOptions,\n  LayerAdapter,\n  LayerAdapterDefinition,\n  LayerLegend,\n  VectorAdapterOptions,\n  WebMap,\n} from '@nextgis/webmap';\n\nexport class NgwWebmapItem extends Item<ItemOptions> {\n  static GetAdapterFromLayerType: {\n    [layerType: string]: (\n      item: TreeItem,\n      options: any,\n      webMap: WebMap,\n      connector?: NgwConnector,\n    ) => LayerAdapterDefinition;\n  } = {};\n\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: NgwWebmapItem): boolean {\n          if (item) {\n            if (\n              item.item.item_type === 'group' ||\n              item.item.item_type === 'root'\n            ) {\n              return treeSome<TreeGroup | TreeLayer>(\n                item.item,\n                (i) => ('layer_enabled' in i ? i.layer_enabled : false),\n                (i) => (i as TreeGroup).children,\n              );\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            }\n            // else if (item.item.item_type === 'root') {\n            //   return true;\n            // }\n          }\n          return false;\n        },\n        onSet(\n          value: boolean,\n          options?: Record<string, any>,\n          item?: NgwWebmapItem,\n        ): void {\n          if (item && item.item.item_type === 'layer') {\n            if (item.layer) {\n              if (value) {\n                item.webMap.showLayer(item.layer);\n              } else {\n                item.webMap.hideLayer(item.layer);\n              }\n            }\n            item.item['layer_enabled'] = value;\n          }\n        },\n      },\n      {\n        name: 'opacity',\n        handler: WebmapLayerOpacityPropertyHandler,\n      },\n    ],\n  };\n\n  item: TreeGroup | TreeLayer;\n  connector?: NgwConnector;\n  layer?: LayerAdapter;\n  readonly emitter = new EventEmitter();\n\n  protected _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n    noInit?: boolean,\n  ) {\n    super({ ...NgwWebmapItem.options, ...options });\n    if (connector) {\n      this.connector = connector;\n    }\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n    this.initProperties();\n    if (!noInit) {\n      this._init(item);\n    }\n  }\n\n  static async create(\n    webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n  ): Promise<NgwWebmapItem> {\n    const ngwWebmapItem = new NgwWebmapItem(\n      webMap,\n      item,\n      options,\n      connector,\n      parent,\n      true,\n    );\n    await ngwWebmapItem._init(item);\n    return ngwWebmapItem;\n  }\n\n  initItem(item: TreeGroup | TreeLayer): Promise<void> {\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      return this.initGroupItem(item as TreeGroup);\n    } else {\n      return this.initLayerItem(item as TreeLayer);\n    }\n  }\n\n  bringToFront(): void {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      // console.log(this.item);\n    }\n  }\n\n  getLayer() {\n    return this.layer;\n  }\n\n  async getLegend(options?: GetLegendOptions): Promise<LayerLegend[]> {\n    const id = this.layer?.id;\n    if (id !== undefined) {\n      const connector = this.connector;\n      if (connector) {\n        const ngwLegend = await connector.get('render.legend_symbols', {\n          params: { id: this.item.resourceId },\n          cache: true,\n          ...options,\n        });\n        const legend: LayerLegend = {\n          layerId: id,\n          legend: ngwLegend.map(({ display_name, icon }) => ({\n            name: display_name,\n            symbol: icon,\n          })),\n        };\n        return [legend];\n      }\n    }\n\n    return [];\n  }\n\n  protected getItemOptions(item: TreeGroup | TreeLayer): Record<string, any> {\n    const transparency = item.item_type === 'layer' && item.layer_transparency;\n    const opacity =\n      typeof transparency === 'number' ? (100 - transparency) / 100 : undefined;\n    const options: Partial<ImageAdapterOptions> &\n      Pick<VectorAdapterOptions, 'popupOptions'> = {\n      visibility: false,\n      name: item.display_name,\n      headers: this.options.headers,\n      crossOrigin: this.options.crossOrigin,\n      setViewDelay: this.options.setViewDelay,\n      params: { resource: this.item.resourceId, item: this.item },\n    };\n    if (this.options.order) {\n      const subOrder =\n        this.options.drawOrderEnabled && 'draw_order_position' in item\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n\n      // 9 > 0009, 11 > 0011\n      // TODO: find better way to set order in sub level, not limit by 1000 layer in group\n      const subLevel = String(subOrder).padStart(4, '0');\n      options.order = Number((this.options.order | 0) + '.' + subLevel);\n    }\n    if (this.options.popupOptions) {\n      options.popupOptions = this.options.popupOptions;\n    }\n    if (item.item_type === 'layer') {\n      const { maxZoom, minZoom } = this._getZoomRange(item);\n\n      Object.assign(options, {\n        updateWmsParams: item.updateWmsParams,\n        url: item.url,\n        headers: this.options.headers,\n        ratio: this.options.ratio,\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n        interactive: item.layer_identifiable,\n      });\n    }\n    if (opacity !== undefined) {\n      options.opacity = opacity;\n    }\n    return options;\n  }\n\n  protected getChildren(item: TreeGroup): (TreeGroup | TreeLayer)[] {\n    return [...item.children].reverse();\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private initGroupItem(group: TreeGroup): Promise<void> {\n    if (group.children && group.children.length) {\n      const children = this.getChildren(group);\n      for (const child of children) {\n        const childItem = new (this.constructor as typeof NgwWebmapItem)(\n          this.webMap,\n          child,\n          this.options,\n          this.connector,\n          this,\n        );\n        this.tree.addChild(childItem);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  private initLayerItem(layer: TreeLayer): Promise<void> {\n    const options: Partial<ImageAdapterOptions> = this.getItemOptions(layer);\n    const setNewLayer = (l: LayerAdapter) => {\n      layer._layer = l;\n      this.layer = l;\n      const enabled = this.properties.get('visibility');\n      if (enabled) {\n        this.properties.set('visibility', true);\n      }\n\n      if (options.opacity !== undefined) {\n        this.webMap.setLayerOpacity(l, options.opacity);\n      }\n    };\n\n    let adapter: LayerAdapterDefinition | undefined;\n    if (layer.item_type === 'layer') {\n      adapter = layer.adapter || layer.layer_adapter.toUpperCase();\n    } else if (NgwWebmapItem.GetAdapterFromLayerType[layer.item_type]) {\n      const getAdapter = NgwWebmapItem.GetAdapterFromLayerType[layer.item_type];\n      adapter = getAdapter(layer, options, this.webMap, this.connector);\n    }\n\n    if (adapter) {\n      return this.webMap.addLayer(adapter, options).then((newLayer) => {\n        setNewLayer(newLayer);\n      });\n    }\n\n    if (layer._layer) {\n      return Promise.resolve(setNewLayer(layer._layer));\n    }\n\n    return Promise.reject('No layer added');\n  }\n\n  private _getZoomRange(item: TreeLayer) {\n    const minZoomWebmap = this.options.minZoom;\n    const maxZoomWebmap = this.options.maxZoom;\n\n    const minZoomLayer = item.layer_min_scale_denom\n      ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n      : undefined;\n    const maxZoomLayer = item.layer_max_scale_denom\n      ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n      : undefined;\n\n    const minZooms = [minZoomWebmap, minZoomLayer].filter(Boolean) as number[];\n    const maxZooms = [maxZoomWebmap, maxZoomLayer].filter(Boolean) as number[];\n    const minZoom = minZooms.length ? Math.max(...minZooms) : undefined;\n    const maxZoom = maxZooms.length ? Math.min(...maxZooms) : undefined;\n    return { minZoom, maxZoom };\n  }\n\n  private _init(item: TreeGroup | TreeLayer) {\n    this.initItem(item).then(() => {\n      this.emitter.emit('init');\n    });\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import { NgwWebmapLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { createAsyncAdapter } from '../adapters/createAsyncAdapter';\n\nimport type {\n  NgwLayerOptions,\n  NgwWebmapAdapterOptions,\n  ResourceAdapter,\n} from '../interfaces';\nimport type { GeometryType } from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { Type } from '@nextgis/utils';\nimport type { VectorAdapterLayerType, WebMap } from '@nextgis/webmap';\n\nexport function updateImageParams(\n  params: Record<string, any>,\n  resourceId: number | number[],\n): Record<string, any> {\n  const { bbox, width, height, nd } = params;\n  return {\n    resource: Array.isArray(resourceId) ? resourceId.join(',') : resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now(),\n    nd: nd ?? 200,\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'point',\n  LINESTRING: 'line',\n  POLYGON: 'polygon',\n  MULTIPOINT: 'point',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'polygon',\n  POINTZ: 'point',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'polygon',\n  MULTIPOINTZ: 'point',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'polygon',\n};\n\nexport function createNgwLayerAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, connector);\n}\n\n/** @deprecated use {@link createNgwLayerAdapter} instead */\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  return createNgwLayerAdapter(options, webMap, connector);\n}\n\nexport interface ExtendNgwWebmapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendNgwWebmapLayerAdapter(\n  opt: ExtendNgwWebmapLayerAdapterOptions,\n): Type<NgwWebmapLayerAdapter> {\n  class A extends NgwWebmapLayerAdapter {\n    constructor(map: any, options: NgwWebmapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth(): number {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number): number {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 0): number {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n\n  const centerLat = lat;\n  const crsScale =\n    (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n  const zoom = getZoomFromScale(crsScale);\n  return zoom;\n\n  // return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { BaseProperty } from '@nextgis/item';\n\nimport type { ItemBasePropertyOptions } from '../../../item/src/interfaces';\nimport type { NgwWebmapItem } from '../NgwWebmapItem';\n\ntype VAL = number;\n\nexport class WebmapLayerOpacityPropertyHandler<\n  V extends VAL = VAL,\n> extends BaseProperty<VAL, ItemBasePropertyOptions<VAL>, NgwWebmapItem> {\n  getProperty(): number {\n    const layer = this.item.layer;\n    if (layer) {\n      return layer && layer.options && layer.options.opacity !== undefined\n        ? layer.options.opacity\n        : 1;\n    }\n    return 1;\n  }\n\n  update(value: V, options?: ItemBasePropertyOptions<VAL>): void {\n    options = options || {};\n\n    if (this.isGroup()) {\n      this._value = this._prepareValue(value, options);\n      const children = this.getChildren();\n      for (const child of children) {\n        const property = child.properties.property(this.name);\n        if (property) {\n          if (options.propagation) {\n            property.set(value, options);\n          } else {\n            property.update(property.get(), options);\n          }\n        }\n      }\n    }\n    const layer = this.item.layer;\n    if (layer) {\n      const parents = this.getParents();\n      const coef = parents.reduce((s, x) => {\n        const prop = x.properties.property(this.name);\n        const multiplier = prop ? prop.getValue() : 1;\n        return s * multiplier;\n      }, 1);\n      const val = value * coef;\n      this.item.webMap.setLayerOpacity(layer, this._prepareValue(val));\n    }\n  }\n\n  protected _prepareValue(\n    value: number,\n    options?: ItemBasePropertyOptions<VAL>,\n  ): number {\n    if (options && options.propagation && this.isGroup()) {\n      return 1;\n    }\n    // value = Number(value);\n    // return value < 0.1 ? 0.1 : value;\n    return Number(value);\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type {\n  FetchNgwLayerExtentOptions,\n  FetchNgwLayerItemExtentOptions,\n} from '../interfaces';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { ResourceItem, WebmapResource } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\nexport function getNgwWebmapExtent(\n  webmap: WebmapResource,\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function fetchNgwLayerExtent({\n  resourceId,\n  connector,\n  cache = true,\n}: FetchNgwLayerExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get('layer.extent', { cache }, { id: resourceId })\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwLayerItemExtent({\n  resourceId,\n  featureId,\n  connector,\n  cache = true,\n}: FetchNgwLayerItemExtentOptions): CancelablePromise<\n  LngLatBoundsArray | undefined\n> {\n  return connector\n    .get(\n      'feature_layer.feature.item_extent',\n      { cache },\n      { id: resourceId, fid: featureId },\n    )\n    .then((resp) => {\n      if (resp) {\n        const { maxLat, maxLon, minLat, minLon } = resp.extent;\n        const extentArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n        return extentArray;\n      }\n    });\n}\n\nexport function fetchNgwExtent(\n  options: FetchNgwLayerExtentOptions,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  return options.connector.getResource(options.resourceId).then((resource) => {\n    if (resource) {\n      return fetchNgwResourceExtent(resource, options.connector, options);\n    }\n  });\n}\n\n/** @deprecated use {@link fetchNgwExtent} instead */\nexport function fetchNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n  options?: FetchNgwLayerExtentOptions,\n): CancelablePromise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return CancelablePromise.resolve(getNgwWebmapExtent(item.webmap));\n  } else {\n    const resource = item.resource;\n    if (resource.cls && resource.cls.indexOf('style') !== -1) {\n      return connector.getResource(resource.parent.id).then((res) => {\n        if (res) {\n          return fetchNgwLayerExtent({\n            ...options,\n            resourceId: res.resource.id,\n            connector,\n          });\n        }\n      });\n    } else {\n      return fetchNgwLayerExtent({\n        ...options,\n        resourceId: resource.id,\n        connector,\n      });\n    }\n  }\n}\n","import { fetchNgwResourceExtent } from './utils/fetchNgwExtent';\n\nimport type { FetchNgwLayerExtentOptions } from './interfaces';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { ResourceItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  protected _extent?: LngLatBoundsArray;\n\n  /** @deprecated use {@link NgwResource.getBounds} instead */\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    return this.getBounds();\n  }\n\n  async getBounds(\n    options?: FetchNgwLayerExtentOptions,\n  ): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await fetchNgwResourceExtent(\n        this.item,\n        this.connector,\n        options,\n      );\n      return this._extent;\n    }\n  }\n}\n","import type { NgwLayerOptions } from '../interfaces';\nimport type { ResourceItem } from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector,\n): Promise<number> {\n  const resource = options.resource;\n  const item = resource as ResourceItem;\n\n  // @ts-ignore @deprecated\n  let { keyname, resourceId } = options;\n\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else if (\n      item.resource &&\n      item.resource !== undefined &&\n      'resource' in item\n    ) {\n      resourceId = (resource as ResourceItem).resource.id;\n    } else {\n      // TODO: safe remove this case\n      resourceId = await resourceIdFromLayerOptions(resource as any, connector);\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResource(keyname);\n    if (resourceItem) {\n      resourceId = resourceItem.resource.id;\n    }\n  }\n  return resourceId;\n}\n","import type { QmsBasemap, QmsLayerType } from '../interfaces';\nimport type { AdapterOptions, LayerAdaptersOptions } from '@nextgis/webmap';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE',\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap,\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  let serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  if (!qms.y_origin_top) {\n    serviceUrl = serviceUrl.replace('{y}', '{-y}');\n  }\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min,\n  };\n}\n","import { mixinProperties } from '@nextgis/utils';\n\nimport { getSubdomainsOriginUrl } from './getSubmodulesFromOriginUrl';\nimport { loadJson } from './loadJson';\nimport { alias, updateQmsOptions } from './updateQmsOptions';\n\nimport type {\n  CreateQmsAdapterOptions,\n  QmsAdapter as QA,\n  QmsAdapterOptions,\n  QmsBasemap,\n} from '../interfaces';\nimport type { Type } from '@nextgis/utils';\nimport type { MainLayerAdapter, WebMap } from '@nextgis/webmap';\n\nconst URL = 'https://qms.nextgis.com';\n\nexport function createQmsAdapter(\n  options: CreateQmsAdapterOptions,\n): Type<MainLayerAdapter>;\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url?: string,\n  createOpt?: Partial<QmsAdapterOptions>,\n): Type<MainLayerAdapter>;\nexport function createQmsAdapter(\n  webMapOrOptions: WebMap | CreateQmsAdapterOptions,\n  url = URL,\n  createOpt: Partial<QmsAdapterOptions> = {},\n): Type<MainLayerAdapter> {\n  let webMap: WebMap;\n  if ('webMap' in webMapOrOptions) {\n    const { webMap: webMap_, url: url_, ...adapterOptions } = webMapOrOptions;\n    webMap = webMap_;\n    if (url_) {\n      url = url_;\n    }\n    if (adapterOptions) {\n      createOpt = adapterOptions;\n    }\n  } else {\n    webMap = webMapOrOptions;\n  }\n\n  if (!url) {\n    url = URL;\n  }\n  class QmsAdapter<M = any> implements MainLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      const opt = { ...createOpt, ...options };\n      this.options = opt;\n      this.options.baselayer = true;\n      if (opt.qms) {\n        this.qms = opt.qms;\n      }\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        try {\n          this.qms = await loadJson<QmsBasemap>(\n            url + '/api/v1/geoservices/' + options.qmsId,\n          );\n        } catch (er) {\n          console.error(er);\n        }\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const WebMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (WebMapAdapter) {\n          mixinProperties(QmsAdapter, WebMapAdapter, [\n            'showLayer',\n            'hideLayer',\n          ]);\n          if (type === 'TILE') {\n            options = {\n              order: 0,\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms),\n            };\n            if (qms.origin_url) {\n              const [url, subdomains] = getSubdomainsOriginUrl(qms.origin_url);\n              if (subdomains.length) {\n                options.subdomains = subdomains;\n                options.url = url;\n              }\n            }\n            this.options = options;\n            const adapter = new WebMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","import { fixUrlStr } from '@nextgis/utils';\n\nexport function loadJson<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","export function getSubdomainsOriginUrl(originUrl: string): [string, string[]] {\n  const submodules: string[] = [];\n  originUrl = originUrl.replace(/{switch:(.*?)}/, (m, group) => {\n    if (typeof group === 'string') {\n      group.split(',').forEach((s) => submodules.push(s));\n    }\n    return '{s}';\n  });\n  return [originUrl, submodules];\n}\n","import { createQmsAdapter } from './utils/createQmsAdapter';\n\nimport type { QmsOptions } from './interfaces';\nimport type { Type } from '@nextgis/utils';\nimport type {\n  LayerAdapterCreators,\n  MainLayerAdapter,\n  StarterKit,\n  WebMap,\n} from '@nextgis/webmap';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter,\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com',\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap)),\n      },\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<MainLayerAdapter> {\n    return createQmsAdapter({ webMap, url: this.url });\n  }\n}\n","import { fetchNgwLayerFeatures } from './fetchNgwLayerFeatures';\n\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { FeatureCollection, Geometry } from 'geojson';\n\nexport function fetchNgwLayerFeatureCollection<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: FetchNgwItemsOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatures<G, P>(options).then((features) => {\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features,\n    };\n    return featureCollection;\n  });\n}\n","import { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerItems } from './fetchNgwLayerItems';\n\nimport type { FetchNgwItemsOptions } from '../interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { FeatureProperties } from '@nextgis/utils';\nimport type { Feature, Geometry } from 'geojson';\n\nexport function fetchNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(options: FetchNgwItemsOptions<P>): CancelablePromise<Feature<G, P>[]> {\n  return fetchNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach((y) => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    return features;\n  });\n}\n","import type { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy',\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions,\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach((x) => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import { EventEmitter } from 'events';\n\nimport { propertiesFilter } from '@nextgis/properties-filter';\nimport { debounce } from '@nextgis/utils';\n\nimport { createPopupContent } from '../utils/createPopupContent';\nimport { fetchNgwExtent } from '../utils/fetchNgwExtent';\nimport { fetchNgwLayerCount } from '../utils/fetchNgwLayerCount';\nimport { fetchNgwLayerFeatureCollection } from '../utils/fetchNgwLayerFeatureCollection';\nimport { getLayerFilterOptions } from '../utils/getLayerFilterOptions';\nimport { prepareNgwFieldsToPropertiesFilter } from '../utils/prepareNgwFieldsToPropertiesFilter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\n\nimport type {\n  GetClassAdapterOptions,\n  NgwFeatureRequestOptions,\n  NgwLayerOptions,\n} from '../interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { LngLatBoundsArray, Type } from '@nextgis/utils';\nimport type {\n  FilterOptions,\n  GeoJsonAdapterOptions,\n  LayerAdapter,\n  VectorLayerAdapter,\n} from '@nextgis/webmap';\nimport type { FeatureCollection } from 'geojson';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  props: GetClassAdapterOptions,\n): Promise<Type<VectorLayerAdapter>> {\n  const {\n    item,\n    webMap,\n    Adapter,\n    connector,\n    layerOptions,\n    addLayerOptionsPriority: alop,\n  } = props;\n  const addLayerOptionsPriority = alop ?? true;\n  const options = layerOptions as NgwLayerOptions<'GEOJSON'>;\n  const GeoJsonAdapter: Type<VectorLayerAdapter> =\n    Adapter || webMap.mapAdapter.layerAdapters.GEOJSON;\n\n  const _loadedIds: string[] = [];\n  let _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n  let _dataPromise: CancelablePromise<FeatureCollection> | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (options.adapterOptions?.popupOptions?.fromProperties) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const getData = async (\n    filters?: PropertiesFilter,\n    filterOpt?: NgwFeatureRequestOptions,\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: filterOpt };\n    _dataPromise = fetchNgwLayerFeatureCollection({\n      resourceId,\n      filters,\n      connector,\n      cache: true,\n      ...filterOpt,\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  class NgwGeoJsonAdapter extends GeoJsonAdapter {\n    emitter = new EventEmitter();\n    __onMapMove?: () => void;\n    __onMapMoveStart?: () => void;\n    __enableMapMoveListener?: (e: LayerAdapter) => void;\n    __disableMapMoveListener?: (e: LayerAdapter) => void;\n\n    async addLayer(opt: GeoJsonAdapterOptions) {\n      let needUpdate = !opt.data;\n      const waitFullLoad =\n        opt.waitFullLoad !== undefined ? opt.waitFullLoad : true;\n      if (options.id !== undefined) {\n        opt.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (options.adapterOptions) {\n        // TODO: remove addLayerOptionsPriority options/\n        // in some cases, addLayer options must be used,\n        // but in others factory method options needs first\n        if (addLayerOptionsPriority) {\n          opt = {\n            ...options.adapterOptions,\n            ...opt,\n          };\n        } else {\n          opt = {\n            ...opt,\n            ...options.adapterOptions,\n          };\n        }\n      }\n      if (opt.data && Object.keys(opt.data).length === 0) {\n        opt.data = undefined;\n        needUpdate = false;\n      }\n      const strategy = opt.strategy || undefined;\n      this.options.strategy = strategy;\n\n      const layer = super.addLayer(opt);\n      _lastFilterArgs = {\n        filters: opt.propertiesFilter,\n        options: getLayerFilterOptions(opt),\n      };\n      let updatePromise: Promise<any> | undefined;\n      if (needUpdate) {\n        updatePromise = this.updateLayer();\n      }\n      if (waitFullLoad && updatePromise) {\n        await updatePromise;\n      }\n      if (strategy && strategy.startsWith('BBOX') && !_fullDataLoad) {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    /** @deprecated use {@link NgwGeoJsonAdapter.getBounds} instead */\n    getExtent(): Promise<LngLatBoundsArray | undefined> {\n      return this.getBounds();\n    }\n\n    async getBounds(): Promise<LngLatBoundsArray | undefined> {\n      const hasData = this.getLayers && this.getLayers().length;\n      const strategy = this.options.strategy;\n      if (strategy?.startsWith('BBOX') || hasData) {\n        return fetchNgwExtent({ connector, resourceId: item.resource.id });\n      } else {\n        if (super.getBounds) {\n          return super.getBounds();\n        }\n      }\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      this.__onMapMoveStart = undefined;\n      abort();\n    }\n\n    getCount() {\n      return fetchNgwLayerCount({ connector, resourceId, cache: true });\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy?.startsWith('BBOX')) {\n        await webMap.onLoad('create');\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = webMap.getBounds();\n        const { minZoom, maxZoom } = this.options;\n        const zoom = webMap.getZoom();\n        if (zoom !== undefined) {\n          if (minZoom !== undefined && zoom < minZoom) {\n            return;\n          }\n          if (maxZoom !== undefined && zoom > maxZoom) {\n            return;\n          }\n          if (_fullDataLoad) {\n            return;\n          }\n        }\n      }\n      if (removed) {\n        return;\n      }\n      try {\n        this.emitter.emit('preupdate', filterArgs);\n        webMap._emitLayerEvent('layer:preupdate', options.id || '', filterArgs);\n\n        const data = await getData(filterArgs.filters, {\n          ...filterArgs.options,\n          srs: this.options.srs,\n        });\n        let newData: FeatureCollection = data;\n        const count = await this.getCount();\n\n        if (this.options.strategy === 'BBOX+') {\n          newData = {\n            type: 'FeatureCollection',\n            features: [],\n          };\n          for (const f of data.features) {\n            if (_loadedIds.indexOf(String(f.id)) === -1) {\n              _loadedIds.push(String(f.id));\n              newData.features.push(f);\n            }\n          }\n          _fullDataLoad = count !== undefined && _loadedIds.length >= count;\n          await webMap.addLayerData(this, newData);\n        } else {\n          _fullDataLoad = count !== undefined && data.features.length >= count;\n          await webMap.setLayerData(this, data);\n        }\n        this.emitter.emit('updated', data);\n        webMap._emitLayerEvent('layer:updated', options.id || '', {\n          data,\n          newData,\n          isFull: _fullDataLoad,\n        });\n      } catch (er) {\n        if (er instanceof Error && er.name !== 'CancelError') {\n          throw er;\n        }\n      }\n      if (super.updateLayer) {\n        super.updateLayer();\n      }\n    }\n\n    async propertiesFilter(\n      filters: PropertiesFilter,\n      opt?: FilterOptions,\n    ): Promise<void> {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter((e) => {\n          const props_ =\n            e.feature &&\n            e.feature.properties &&\n            prepareNgwFieldsToPropertiesFilter({ ...e.feature.properties });\n          if (props_) {\n            return propertiesFilter(props_, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await getData(filters, {\n          ...opt,\n          srs: this.options.srs,\n        });\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    private _addBboxEventListener() {\n      this.__enableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener(this);\n    }\n\n    private _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    private _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      this.__onMapMoveStart = abort;\n      webMap.emitter.on('movestart', this.__onMapMoveStart);\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    private _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.removeListener('moveend', this.__onMapMove);\n      }\n      if (this.__onMapMoveStart) {\n        webMap.emitter.removeListener('movestart', this.__onMapMoveStart);\n      }\n    }\n  }\n\n  return NgwGeoJsonAdapter;\n}\n","import type { ResourceItem } from '@nextgis/ngw-connector';\nimport type { Feature } from 'geojson';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem,\n): HTMLElement | string {\n  // @ts-ignore\n  if (__BROWSER__) {\n    const element = document.createElement('div');\n    if (item && item.feature_layer) {\n      item.feature_layer.fields.forEach((x) => {\n        if (x.grid_visibility) {\n          const value = feature.properties && feature.properties[x.keyname];\n          if (value) {\n            const propElem = document.createElement('div');\n            element.appendChild(propElem);\n            propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n          }\n        }\n      });\n    } else if (feature.properties) {\n      for (const p in feature.properties) {\n        const propElem = document.createElement('div');\n        element.appendChild(propElem);\n        propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n      }\n    }\n    return element;\n  } else {\n    return '';\n  }\n}\n","import type { FetchNgwLayerCountOptions } from '../interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\n\nexport function fetchNgwLayerCount({\n  connector,\n  resourceId,\n  cache = true,\n}: FetchNgwLayerCountOptions): CancelablePromise<number> {\n  return connector\n    .get(\n      'feature_layer.feature.count',\n      { cache },\n      {\n        id: resourceId,\n      },\n    )\n    .then((resp) => {\n      return resp.total_count;\n    });\n}\n","import { updateImageParams } from './utils';\n\nimport type { NgwLayerOptions, TileNoData } from '../interfaces';\nimport type {\n  ImageAdapterOptions,\n  MvtAdapterOptions,\n  RasterAdapterOptions,\n  WebMap,\n  WmsAdapterOptions,\n} from '@nextgis/webmap';\n\nexport interface GetLayerAdapterOptions {\n  options: NgwLayerOptions;\n  webMap?: WebMap;\n  baseUrl?: string;\n}\n\nexport interface GetImageAdapterOptionsParams {\n  resourceId: number | number[];\n  baseUrl?: string;\n  nd?: TileNoData;\n  headers: any;\n}\n\nexport function getImageAdapterOptions({\n  resourceId,\n  baseUrl,\n  nd,\n  headers,\n}: GetImageAdapterOptionsParams): ImageAdapterOptions {\n  const url = baseUrl + '/api/component/render/image';\n  const params: Record<string, any> = { resource: resourceId };\n  if (nd) {\n    params.nd = nd;\n  }\n  return {\n    url,\n    resourceId,\n    headers,\n    params,\n    updateWmsParams: (params_: Record<string, any>) => {\n      if (nd) {\n        params_.nd = nd;\n      }\n      return updateImageParams(params_, resourceId);\n    },\n  } as ImageAdapterOptions;\n}\n\nexport function ngwApiToAdapterOptions({\n  options,\n  webMap,\n  baseUrl,\n}: GetLayerAdapterOptions):\n  | MvtAdapterOptions\n  | RasterAdapterOptions\n  | ImageAdapterOptions\n  | undefined {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap && webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = options.resource;\n  const nd: TileNoData = options.tileNoData ? options.tileNoData : 200;\n\n  if (typeof resourceId === 'number') {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        return getImageAdapterOptions({\n          resourceId,\n          headers: options.headers,\n          nd,\n          baseUrl,\n        });\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      const adapterOptions = options.adapterOptions as WmsAdapterOptions;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: adapterOptions && adapterOptions.layers,\n        headers: options.headers,\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification ?? 6);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url,\n        sourceLayer: 'ngw:' + resourceId,\n        featureIdName: '$id',\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'MODEL_3D') {\n      url = baseUrl + `/api/component/model_3d/${resourceId}/data.glb`;\n      return { url };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId +\n        '&nd=' +\n        nd;\n      return { url, adapter };\n    }\n  } else if (resourceId !== undefined) {\n    throw new Error(\n      'Option `resource` must be number, not ' + typeof resourceId,\n    );\n  } else {\n    console.log('Option `resource` not set');\n  }\n}\n\n/** @deprecated use {@link ngwApiToAdapterOptions} instead */\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n): RasterAdapterOptions | ImageAdapterOptions | undefined {\n  return ngwApiToAdapterOptions({ options, webMap, baseUrl });\n}\n","import { defined } from '@nextgis/utils';\n\nimport { ngwApiToAdapterOptions } from '../utils/ngwApiToAdapterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type {\n  GetClassAdapterOptions,\n  NgwLayerAdapterType,\n  ResourceAdapter,\n} from '../interfaces';\nimport type { ResourceCls, ResourceItem } from '@nextgis/ngw-connector';\nimport type { Type } from '@nextgis/utils';\nimport type {\n  GetLegendOptions,\n  ImageAdapterOptions,\n  LayerLegend,\n  MainLayerAdapter,\n} from '@nextgis/webmap';\n\nexport async function createRasterAdapter({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  const resourceCls = item.resource.cls;\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    tmsclient_layer: 'IMAGE',\n  };\n  let adapter =\n    layerOptions.adapter ||\n    (resourceCls && clsAdapterAlias[resourceCls]) ||\n    'IMAGE';\n  if (adapter !== undefined) {\n    layerOptions.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const AdapterClass = webMap.mapAdapter.layerAdapters[\n    adapter\n  ] as Type<MainLayerAdapter>;\n  if (AdapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(\n      layerOptions,\n      connector,\n    );\n    return class RasterAdapter extends AdapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem = item;\n      resourceId = resourceId;\n\n      constructor(\n        public map: any,\n        _options: any,\n      ) {\n        super(map, _options);\n        const opt = ngwApiToAdapterOptions({\n          options: layerOptions,\n          webMap,\n          baseUrl: connector.options.baseUrl || '',\n        });\n        if (opt) {\n          const layerAdapterOptions: ImageAdapterOptions = {\n            ...opt,\n            ...layerOptions.adapterOptions,\n            params: { resource: resourceId },\n            layers: opt.layers || String(resourceId),\n            resourceId,\n          };\n          if (\n            layerOptions.adapterOptions &&\n            defined(layerOptions.adapterOptions.setViewDelay)\n          ) {\n            layerAdapterOptions.setViewDelay =\n              layerOptions.adapterOptions.setViewDelay;\n          }\n          this.options = { ...this.options, ...layerAdapterOptions };\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getLegend(options?: GetLegendOptions): Promise<LayerLegend[]> {\n        const ngwLegend = await connector.get('render.legend_symbols', {\n          params: { id: resourceId },\n          cache: true,\n          ...options,\n        });\n        const id = this.options.id;\n        if (id !== undefined) {\n          const legend: LayerLegend = {\n            layerId: id,\n            legend: ngwLegend.map(({ display_name, icon }) => ({\n              name: display_name,\n              symbol: icon,\n            })),\n          };\n          return [legend];\n        }\n        return [];\n      }\n\n      async getIdentificationIds(): Promise<number[]> {\n        if (this.item) {\n          if (adapter === 'MVT') {\n            return [this.item.resource.id];\n          }\n          const id = this.item.resource.parent.id;\n          if (defined(id)) {\n            return [id];\n          }\n        }\n        return [];\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","import { applyMixins } from '@nextgis/utils';\n\nimport { NgwResource } from '../NgwResource';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\n\nimport { createBasemapLayerAdapter } from './createBasemapLayerAdapter';\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createWebMapAdapter } from './createNgwWebmapAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\n\nimport type {\n  ClassAdapter,\n  GetClassAdapter,\n  GetClassAdapterByType,\n  GetClassAdapterCallback,\n  GetClassAdapterOptions,\n  NgwLayerOptions,\n  ResourceAdapter,\n} from '../interfaces';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { ResourceCls, ResourceItem } from '@nextgis/ngw-connector';\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap } from '@nextgis/webmap';\n\nexport const classAdapters: Record<string, GetClassAdapter> = {};\n\nconst supportCls: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'basemap_layer',\n  'vector_layer',\n  'raster_layer',\n  'postgis_layer',\n  'webmap',\n  // in tms branch\n  'tmsclient_layer',\n];\n\nasync function createAdapterFromFirstStyle({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions) {\n  const parent = item.resource.id;\n  const childrenStyles = await connector.getResourceChildren(parent);\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    return createAsyncAdapter(\n      { ...layerOptions, resource: firstStyle.resource.id },\n      webMap,\n      connector,\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: ClassAdapter | undefined;\n  let item: ResourceItem | undefined;\n  const adapterType = options.adapter;\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  if (resourceId) {\n    const resourceOptions = options as NgwLayerOptions;\n    const itemFromResOpt = resourceOptions.resource as ResourceItem;\n    if (\n      itemFromResOpt &&\n      itemFromResOpt.resource &&\n      itemFromResOpt.resource.id !== undefined\n    ) {\n      item = itemFromResOpt;\n    } else {\n      item = await connector.getResource(resourceId);\n    }\n    if (item) {\n      const cls = item.resource.cls;\n      const layerOptions: NgwLayerOptions = {\n        ...options,\n        resource: resourceId,\n      };\n\n      const adapterOptions: GetClassAdapterOptions = {\n        layerOptions,\n        webMap,\n        connector,\n        item,\n      };\n\n      if (supportCls.indexOf(cls) !== -1) {\n        if (cls === 'webmap') {\n          adapter = createWebMapAdapter(adapterOptions);\n        } else if (cls === 'vector_layer' || cls === 'postgis_layer') {\n          const type =\n            item.vector_layer &&\n            vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n          const adapterOptions_ =\n            adapterOptions.layerOptions.adapterOptions || {};\n          adapterOptions_.type = adapterOptions_.type || type;\n          adapterOptions.layerOptions.adapterOptions = adapterOptions_;\n          options.adapterOptions = adapterOptions;\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(adapterOptions);\n            } else {\n              return createAdapterFromFirstStyle(adapterOptions);\n            }\n          } else {\n            adapter = createGeoJsonAdapter(adapterOptions);\n          }\n        } else if (cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(adapterOptions);\n        } else if (cls === 'basemap_layer') {\n          adapter = createBasemapLayerAdapter(adapterOptions);\n        } else {\n          if (adapterType === 'GEOJSON') {\n            const parentItem = await connector.getResource(\n              item.resource.parent.id,\n            );\n            if (parentItem) {\n              const parentOptions: NgwLayerOptions = {\n                ...options,\n                resource: item.resource.parent.id,\n              };\n              adapter = createGeoJsonAdapter({\n                ...adapterOptions,\n                item: parentItem,\n                layerOptions: parentOptions,\n              });\n            }\n          } else {\n            adapter = createRasterAdapter(adapterOptions);\n          }\n        }\n      } else if (classAdapters[cls]) {\n        const getClassAdapter = classAdapters[cls];\n        let classAdapter: GetClassAdapterCallback | undefined;\n        if (adapterType && typeof classAdapter !== 'function') {\n          classAdapter = (getClassAdapter as GetClassAdapterByType)[\n            adapterType\n          ];\n        } else {\n          classAdapter = getClassAdapter as GetClassAdapterCallback;\n        }\n        if (classAdapter) {\n          adapter = classAdapter(adapterOptions);\n        }\n      } else {\n        throw `Resource class '${cls}' not yet supported.`;\n      }\n    } else {\n      throw 'Resource item is not found';\n    }\n  }\n\n  if (adapter) {\n    return adapter.then((x) => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        if (item) {\n          resourceAdapter.prototype.item = item;\n          resourceAdapter.prototype.resourceId = item.resource.id;\n          resourceAdapter.prototype.connector = connector;\n        }\n\n        applyMixins(resourceAdapter, [NgwResource], { replace: false });\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { NgwWebmapLayerAdapter as NWLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nimport type { GetClassAdapterOptions } from '../interfaces';\nimport type { Type } from '@nextgis/utils';\n\nexport async function createWebMapAdapter({\n  layerOptions: options,\n  webMap,\n  connector,\n}: GetClassAdapterOptions): Promise<Type<NWLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class NgwWebmapLayerAdapter extends NWLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        url: '',\n        webMap,\n        resourceId,\n        connector,\n      });\n    }\n  };\n}\n","import { QmsKit } from '@nextgis/qms-kit';\n\nimport type { GetClassAdapterOptions } from '../interfaces';\nimport type { Type } from '@nextgis/utils';\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\n\nexport async function createBasemapLayerAdapter({\n  webMap,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  if (item.basemap_layer) {\n    const qms = item.basemap_layer.qms;\n    const url = item.basemap_layer.url;\n    if (qms) {\n      const qms_ = JSON.parse(qms);\n      const adapter = Promise.resolve(\n        QmsKit.utils.createQmsAdapter(webMap, undefined, {\n          qms: qms_,\n          baselayer: true,\n        }),\n      );\n      return adapter;\n    } else if (url) {\n      const TileAdapter = webMap.mapAdapter.layerAdapters.TILE as Type<\n        MainLayerAdapter<any, any, TileAdapterOptions>\n      >;\n      if (TileAdapter) {\n        class BasemapTileAdapter extends TileAdapter {\n          async addLayer(opt: TileAdapterOptions) {\n            return super.addLayer({ ...opt, url });\n          }\n        }\n        return BasemapTileAdapter;\n      }\n    }\n  }\n}\n","import { createAsyncAdapter } from './createAsyncAdapter';\nimport { createOnFirstShowAdapter } from './createOnFirstShowAdapter';\n\nimport type { BasemapWebmapItem } from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { Type } from '@nextgis/utils';\nimport type { MainLayerAdapter, WebMap } from '@nextgis/webmap';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  item: BasemapWebmapItem;\n  adapterOptions?: Record<string, any>;\n  idPrefix?: string;\n}\n\nexport async function createOnFirstShowNgwAdapter({\n  webMap,\n  connector,\n  item,\n  adapterOptions = {},\n  idPrefix = 'first-show-adapter',\n}: CreateOnFirstShowAdapterOptions): Promise<Type<MainLayerAdapter>> {\n  const createAdapter = () => {\n    return createAsyncAdapter(\n      {\n        resource: item.resource_id,\n        adapterOptions: {\n          name: item.display_name,\n          opacity: item.opacity,\n        },\n      },\n      webMap,\n      connector,\n    );\n  };\n  const onLayerAdded = (adapter: MainLayerAdapter) => {\n    adapter.options.baselayer = false;\n    adapter.id = idPrefix + '-' + item.resource_id;\n  };\n\n  const OnFirstNgwShowAdapter = createOnFirstShowAdapter({\n    webMap,\n    adapterOptions,\n    onLayerAdded,\n    createAdapter,\n  });\n\n  return OnFirstNgwShowAdapter;\n}\n","import type { Type } from '@nextgis/utils';\nimport type { AdapterOptions, MainLayerAdapter, WebMap } from '@nextgis/webmap';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  adapterOptions?: Record<string, any>;\n  onLayerAdded?: <L extends MainLayerAdapter = MainLayerAdapter>(\n    layer: L,\n  ) => void;\n  createAdapter: (\n    firstShowAdapter: FirstShowAdapter,\n  ) => Promise<Type<MainLayerAdapter> | undefined>;\n}\n\ninterface FirstShowAdapter extends MainLayerAdapter {\n  loadLayer: () => Promise<MainLayerAdapter[]>;\n  destroyed: () => boolean;\n}\n\nexport async function createOnFirstShowAdapter({\n  webMap,\n  adapterOptions = {},\n  onLayerAdded,\n  createAdapter,\n}: CreateOnFirstShowAdapterOptions): Promise<Type<FirstShowAdapter>> {\n  class OnFirstShowAdapter implements MainLayerAdapter {\n    options: AdapterOptions = {};\n    layer: MainLayerAdapter[] = [];\n    _removed = false;\n    _creatingInProgress = false;\n\n    addLayer() {\n      return this.layer;\n    }\n\n    removeLayer() {\n      this._removed = true;\n      for (const l of this.layer) {\n        webMap.removeLayer(l);\n      }\n    }\n\n    destroyed() {\n      return this._removed;\n    }\n\n    async showLayer() {\n      this.options.visibility = true;\n      if (this.layer.length) {\n        for (const x of this.layer) {\n          await webMap.showLayer(x);\n        }\n      } else {\n        await this.loadLayer();\n      }\n    }\n\n    async hideLayer() {\n      this.options.visibility = false;\n      if (this.layer) {\n        for (const x of this.layer) {\n          await webMap.hideLayer(x);\n        }\n      }\n    }\n\n    async loadLayer() {\n      if (!this.layer.length && !this._creatingInProgress) {\n        this._creatingInProgress = true;\n        const Adapter = await createAdapter(this);\n        if (Adapter) {\n          const adapter = new Adapter(webMap.mapAdapter.map, {\n            ...adapterOptions,\n          });\n          const realLayer: MainLayerAdapter = await adapter.addLayer({\n            order: this.options.order,\n            headers: this.options.headers,\n            baselayer: this.options.baselayer,\n          });\n          if (onLayerAdded) {\n            onLayerAdded(adapter);\n          }\n          Object.assign(adapter.options, adapterOptions);\n          adapter.layer = realLayer;\n          if (this._removed) {\n            webMap.removeLayer(adapter);\n          }\n          this.layer.push(adapter);\n          if (this.options.visibility) {\n            await webMap.showLayer(adapter);\n          }\n          this._creatingInProgress = false;\n        }\n      }\n      return this.layer;\n    }\n  }\n  return OnFirstShowAdapter;\n}\n","import { EventEmitter } from 'events';\n\nimport {\n  WEBMAP_BASELAYER_ID_PREFIX,\n  fetchNgwLayerItems,\n} from '@nextgis/ngw-kit';\nimport { fixUrlStr } from '@nextgis/utils';\n\nimport { BookmarkItem } from './BookmarkItem';\nimport { NgwWebmapItem } from './NgwWebmapItem';\nimport { createOnFirstShowNgwAdapter } from './adapters/createOnFirstShowNgwAdapter';\nimport { getNgwWebmapExtent } from './utils/fetchNgwExtent';\nimport { ngwApiToAdapterOptions } from './utils/ngwApiToAdapterOptions';\nimport { updateImageParams } from './utils/utils';\n\nimport type {\n  NgwLayerAdapterType,\n  NgwWebmapAdapterOptions,\n  NgwWebmapLayerAdapterEvents,\n  ResourceAdapter,\n  TreeGroup,\n  TreeLayer,\n} from './interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { ItemOptions } from '@nextgis/item';\nimport type {\n  BasemapWebmap,\n  ResourceItem,\n  WebmapResource,\n} from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray, Type } from '@nextgis/utils';\nimport type { LayerLegend } from '@nextgis/webmap';\nimport type { RasterAdapterOptions, WebMap } from '@nextgis/webmap';\nimport type StrictEventEmitter from 'strict-event-emitter-types';\n\nexport class NgwWebmapLayerAdapter<M = any> implements ResourceAdapter<M> {\n  layer?: NgwWebmapItem;\n\n  NgwWebmapItem: Type<NgwWebmapItem> = NgwWebmapItem;\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  webmapClassName = 'webmap';\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwWebmapLayerAdapterEvents\n  > = new EventEmitter();\n  protected _extent?: LngLatBoundsArray;\n\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n  private _webmapBaselayersIds: string[] = [];\n  private _lastActiveBaselayer?: string;\n\n  constructor(\n    public map: M,\n    public options: NgwWebmapAdapterOptions,\n  ) {\n    const r = options.resourceId;\n\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: NgwWebmapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n    this.layer = await this._getWebMapLayerItem();\n    const extentConstrained = this.response?.webmap?.extent_constrained;\n    if (\n      this.options.useExtentConstrained &&\n      this._extent &&\n      extentConstrained\n    ) {\n      this.options.webMap.setView({ maxBounds: this._extent });\n    }\n    return this.layer;\n  }\n\n  removeLayer(): void {\n    const mapAdapter = this.options.webMap.mapAdapter;\n\n    this.getDependLayers().forEach((x) => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n\n    if (this._webmapBaselayersIds.length) {\n      for (const b of this._webmapBaselayersIds) {\n        this.options.webMap.removeLayer(b);\n      }\n      if (this._lastActiveBaselayer) {\n        this.options.webMap.showLayer(this._lastActiveBaselayer);\n      }\n    }\n\n    if (this.options.useExtentConstrained && this._extent) {\n      this.options.webMap.setView({ maxBounds: null });\n    }\n\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  async showLayer(): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  async hideLayer(): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  async setOpacity(val: number): Promise<void> {\n    if (this.layer && this.layer.properties) {\n      return this.layer.properties.property('opacity').set(val);\n    }\n  }\n\n  /** @deprecated use {@link NgwWebmapLayerAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getNgwWebmapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<NgwWebmapItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  getBookmarksResourceId(): number | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return webmap.bookmark_resource.id;\n    }\n  }\n\n  fetchBookmarks(): CancelablePromise<BookmarkItem[]> {\n    const bookmarkResId = this.getBookmarksResourceId();\n    const connector = this.options.connector;\n    if (bookmarkResId) {\n      return connector.getResourceOrFail(bookmarkResId).then((item) => {\n        const labelField = item.feature_layer?.fields.find(\n          (x) => x.label_field,\n        );\n        const keyname = labelField && labelField.keyname;\n        return fetchNgwLayerItems({\n          connector,\n          resourceId: bookmarkResId,\n          geom: false,\n          fields: keyname ? [keyname] : undefined,\n        }).then((items) => {\n          const bookmarks: BookmarkItem[] = [];\n          for (const i of items) {\n            const bookmark = new BookmarkItem({\n              item: i,\n              resourceId: bookmarkResId,\n              labelField: keyname,\n              connector,\n            });\n            bookmarks.push(bookmark);\n          }\n          return bookmarks;\n        });\n      });\n    }\n    throw new Error(\n      'Webmap was not loaded correctly, it is impossible to extract bookmarks',\n    );\n  }\n\n  async getLegend(): Promise<LayerLegend[]> {\n    const legends: LayerLegend[] = [];\n\n    let deps = this.getDependLayers();\n    deps = deps.sort((a, b) => b.id - a.id);\n    for (const d of deps) {\n      const layerLegend = await d.getLegend();\n      legends.push(...layerLegend);\n    }\n\n    return legends;\n  }\n\n  async getIdentificationIds(): Promise<number[]> {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => b.id - a.id);\n      deps.forEach((x) => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (\n          parentId !== undefined &&\n          item.item_type === 'layer' &&\n          item.layer_identifiable\n        ) {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  protected async _getWebMapLayerItem(): Promise<NgwWebmapItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<NgwWebmapItem>((resolve) => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.setViewDelay = this.options.setViewDelay;\n          options.order = this.options.order;\n          options.ratio = this.options.ratio;\n          options.crossOrigin = this.options.crossOrigin;\n          options.minZoom = this.options.minZoom;\n          options.maxZoom = this.options.maxZoom;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          options.popupOptions = this.options.popupOptions;\n          const layer = new this.NgwWebmapItem(\n            this.options.webMap,\n            webmap.root_item,\n            options,\n            this.options.connector,\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    const data = await this.options.connector.getResource(id);\n    if (data) {\n      this.response = data;\n      const webmap = data[\n        this.webmapClassName as keyof ResourceItem\n      ] as WebmapResource;\n      this._setupBaselayers(data);\n      if (webmap) {\n        this._extent = [\n          webmap.extent_left,\n          webmap.extent_bottom,\n          webmap.extent_right,\n          webmap.extent_top,\n        ];\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    }\n  }\n\n  private _setupBaselayers(data: ResourceItem) {\n    const webMap = this.options.webMap;\n    const basemap = this.options.useBasemap ?? true;\n    if (basemap) {\n      if (data.basemap_webmap && data.basemap_webmap.basemaps.length) {\n        const activeBaselayer = webMap.getActiveBaseLayer();\n        this._lastActiveBaselayer = activeBaselayer\n          ? activeBaselayer.id\n          : undefined;\n        this._setBasemaps(data.basemap_webmap);\n      } else if (this.options.defaultBasemap) {\n        webMap.addBaseLayer('OSM', {\n          id: 'webmap-default-baselayer',\n          name: 'OpenStreetMap',\n        });\n      }\n    }\n  }\n\n  private _setBasemaps(baseWebmap: BasemapWebmap) {\n    const webMap = this.options.webMap;\n    // to avoid set many basemaps on init\n    let enabledAlreadySet = false;\n    for (const x of baseWebmap.basemaps) {\n      createOnFirstShowNgwAdapter({\n        webMap,\n        connector: this.options.connector,\n        item: x,\n        adapterOptions: { crossOrigin: this.options.crossOrigin },\n      }).then((adapter) => {\n        const visibility = enabledAlreadySet ? false : x.enabled;\n        if (x.enabled) {\n          enabledAlreadySet = true;\n        }\n        return webMap\n          .addBaseLayer(adapter, {\n            id: WEBMAP_BASELAYER_ID_PREFIX + x.resource_id,\n            name: x.display_name,\n            opacity: x.opacity,\n            visibility,\n          })\n          .then((l) => {\n            l.id && this._webmapBaselayersIds.push(l.id);\n          });\n      });\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem,\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map((x) =>\n            this._updateItemsParams(x, webMap, data),\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.connector.options.baseUrl +\n            '/api/component/render/image',\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = (params) =>\n          updateImageParams(params, resourceId);\n        const adapter = item.layer_adapter.toUpperCase() as NgwLayerAdapterType;\n        const layerAdapterOptions = ngwApiToAdapterOptions({\n          options: {\n            adapter,\n            resource: resourceId,\n          },\n          webMap,\n          baseUrl: this.options.connector.options.baseUrl || '',\n        }) as RasterAdapterOptions;\n        item = {\n          ...item,\n          ...layerAdapterOptions,\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      for (const x of layers) {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector.getResource(id).then((y) => {\n            if (y) {\n              const parentId = Number(y.resource.parent.id);\n              item.parentId = parentId;\n              return parentId;\n            }\n          });\n          promises.push(promise);\n        }\n      }\n      const ids = await Promise.all(promises);\n      return ids.filter((x) => x !== undefined);\n    }\n  }\n}\n","export const WEBMAP_BASELAYER_ID_PREFIX = 'webmap-baselayer';\n","import { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type { FetchNgwItemOptions } from '../interfaces';\nimport type CancelablePromise from '@nextgis/cancelable-promise';\nimport type { Feature, Geometry } from 'geojson';\n\nexport function fetchNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>,\n>(options: FetchNgwItemOptions<P>): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerItem<G, P>(options).then((item) => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport { fetchNgwLayerItem, fetchNgwLayerItemExtent } from '.';\n\nimport type { IdentifyItemOptions, NgwFeatureItemResponse } from '.';\nimport type { FetchNgwItemOptions } from './interfaces';\nimport type {\n  FeatureItemExtensions,\n  FeatureResource,\n  LayerFeature,\n  VectorLayerResourceItem,\n} from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureProperties, LngLatBoundsArray } from '@nextgis/utils';\nimport type { Feature, GeoJsonObject, Geometry } from 'geojson';\n\nexport class IdentifyItem<\n  F extends FeatureProperties = FeatureProperties,\n  G extends Geometry = Geometry,\n> implements LayerFeature\n{\n  readonly id: number;\n  readonly label: string;\n  readonly layerId: number;\n  readonly parent: string;\n  readonly fields: FeatureProperties;\n  geom?: GeoJsonObject;\n  extensions?: FeatureItemExtensions;\n\n  private connector: NgwConnector;\n  private _item?: NgwFeatureItemResponse<F, G>;\n  private _geojson?: Feature<G, F>;\n  private _resource?: VectorLayerResourceItem;\n  private _extent?: LngLatBoundsArray;\n\n  constructor(options: IdentifyItemOptions) {\n    const f = options.feature;\n    this.id = f.id;\n    this.geom = f.geom;\n    this.label = f.label;\n    this.parent = f.parent;\n    this.fields = f.fields;\n    this.layerId = f.layerId;\n    this.connector = options.connector;\n  }\n\n  identify(\n    options: Partial<FetchNgwItemOptions<F>> = {},\n  ): CancelablePromise<NgwFeatureItemResponse<F, G>> {\n    if (this._item) {\n      return CancelablePromise.resolve(this._item);\n    }\n    return fetchNgwLayerItem<G, F>({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n      fields: null,\n      extensions: ['attachment', 'description'],\n      ...options,\n    }).then((resp) => {\n      this._item = resp;\n      this.geom = resp.geom;\n      this.extensions = resp.extensions;\n      return resp;\n    });\n  }\n\n  resource(): CancelablePromise<FeatureResource> {\n    if (this._resource) {\n      return CancelablePromise.resolve(this._resource.feature_layer);\n    }\n    return this.connector.getResource(this.layerId).then((resp) => {\n      this._resource = resp as VectorLayerResourceItem;\n      return this._resource.feature_layer;\n    });\n  }\n\n  getBounds(): CancelablePromise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return fetchNgwLayerItemExtent({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n    });\n  }\n\n  geojson(): CancelablePromise<Feature<G, F>> {\n    if (this._geojson) {\n      return CancelablePromise.resolve(this._geojson);\n    }\n    return this.identify().then((resp) => {\n      return resp.toGeojson().then((geojson) => {\n        this._geojson = geojson;\n        return geojson;\n      });\n    });\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  degrees2meters,\n  deprecatedMapClick,\n  getCirclePolygonCoordinates,\n} from '@nextgis/utils';\n\nimport { IdentifyItem } from '../IdentifyItem';\n\nimport { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type {\n  FeatureIdentifyRequestOptions,\n  FeatureLayerIdentifyOptions,\n  GetIdentifyGeoJsonOptions,\n  IdentifyItemOptions,\n  IdentifyRequestOptions,\n  NgwFeatureItemResponse,\n  NgwIdentifyItem,\n} from '../interfaces';\nimport type {\n  FeatureLayersIdentify,\n  LayerFeature,\n} from '@nextgis/ngw-connector';\nimport type { FeatureProperties, JsonMap } from '@nextgis/utils';\nimport type { MapClickEvent } from '@nextgis/webmap';\nimport type { Feature, Geometry, Position } from 'geojson';\n\nexport function getIdentifyItems(\n  identify: FeatureLayersIdentify & { resources?: number[] },\n  multiple = false,\n): NgwIdentifyItem[] {\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort((a, b) => {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const identifyItem = identify[l];\n    if ('features' in identifyItem) {\n      const layerFeatures = identifyItem.features;\n      const resourceId = Number(l);\n      const featureParams: NgwIdentifyItem[] = createParamsFromFeatures(\n        layerFeatures,\n        resourceId,\n        multiple,\n      );\n      if (featureParams.length) {\n        paramsList.push(...featureParams);\n        if (!multiple) {\n          break;\n        }\n      }\n    }\n  }\n  return paramsList;\n}\n\nfunction createParamsFromFeatures(\n  features: LayerFeature[],\n  resourceId: number,\n  multiple: boolean,\n): NgwIdentifyItem[] {\n  const featureParams: NgwIdentifyItem[] = [];\n  for (const feature of features) {\n    const params = {\n      featureId: feature.id,\n      resourceId,\n      feature,\n    };\n    featureParams.push(params);\n    if (!multiple) {\n      break;\n    }\n  }\n  return featureParams;\n}\n\nexport function fetchIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  const { connector, identify, requestOptions } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      if ('features' in item) {\n        const withGeom = item.features.find((x) => x.geom);\n\n        if (withGeom && withGeom.geom) {\n          const geom = withGeom.geom as Geometry;\n          return CancelablePromise.resolve(\n            createGeoJsonFeature({\n              ...withGeom,\n              geom,\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerFeature({ ...requestOptions, connector, ...params[0] });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\nexport function fetchIdentifyItem<\n  G extends Geometry = Geometry,\n  P extends FeatureProperties = FeatureProperties,\n>(\n  options: GetIdentifyGeoJsonOptions<P>,\n): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n  const { connector, identify } = options;\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerItem<G, P>({\n      connector,\n      ...options.requestOptions,\n      ...params[0],\n    });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\n/**\n * @deprecated use {@link fetchIdentifyGeoJson} instead\n */\nexport function getIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap,\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  return fetchIdentifyGeoJson(options);\n}\n\nexport function featureLayerIdentify(\n  options: FeatureLayerIdentifyOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  const { geom, signal, cache, layers } = options;\n\n  const wkt = typeof geom === 'string' ? geom : convertGeomToWKT(geom);\n\n  if (!wkt) {\n    throw new Error('Not valid geometry format to make intersection');\n  }\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers,\n  };\n\n  return options.connector.post('feature_layer.identify', {\n    data,\n    signal,\n    cache,\n  });\n}\n\nfunction convertGeomToWKT(\n  geom: FeatureLayerIdentifyOptions['geom'],\n): string | null {\n  const coordinates = getPolygonCoordinates(geom);\n  if (!coordinates) return null;\n\n  const polygonStr = coordinates.map(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    return `${x} ${y}`;\n  });\n\n  return `POLYGON((${polygonStr.join(',')}))`;\n}\n\nfunction getPolygonCoordinates(\n  geom: FeatureLayerIdentifyOptions['geom'],\n): Position[] | null {\n  if (Array.isArray(geom)) {\n    return geom;\n  }\n\n  if (geom.type === 'Feature') {\n    return geom.geometry?.coordinates[0];\n  }\n\n  if (geom.type === 'Polygon') {\n    return geom.coordinates[0];\n  }\n\n  return null;\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions,\n): CancelablePromise<FeatureLayersIdentify> {\n  deprecatedMapClick(ev);\n  const [lng, lat] = ev.lngLat;\n  const { geom, radius, signal, cache } = options;\n  const geom_ = geom ?? getCirclePolygonCoordinates(lng, lat, radius);\n\n  return featureLayerIdentify({ ...options, geom: geom_, signal, cache });\n}\n\nexport function createIdentifyItem<\n  F extends FeatureProperties = FeatureProperties,\n  G extends Geometry = Geometry,\n>(opt: IdentifyItemOptions): IdentifyItem<F, G> {\n  return new IdentifyItem<F, G>(opt);\n}\n","import type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type { NgwResourceDefinition } from '../interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: Partial<NgwLayerOptions>,\n  overwriteOptions?: Partial<NgwLayerOptions>,\n): void {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resource,\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({\n      ...defOptions,\n      resource: resourceId,\n      id,\n      ...overwriteOptions,\n    });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n","import type { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when...\n */\nexport class NgwError extends Error {\n  name = 'NgwError';\n\n  title!: string;\n  message!: string;\n  detail!: string;\n  exception!: NgwExceptions;\n  status_code!: number | 404 | 500;\n  data?: Record<string, any>;\n  guru_meditation!: string;\n\n  constructor(er?: Partial<NgwError>) {\n    super();\n    Object.assign(this, er);\n    Object.setPrototypeOf(this, NgwError.prototype);\n  }\n}\n","import { NgwError } from './NgwError';\n\nimport type { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class ResourceNotFoundError extends NgwError {\n  name = 'ResourceNotFoundError';\n  exception: NgwExceptions = 'nextgisweb.resource.exception.ResourceNotFound';\n\n  constructor(obj?: ResourceNotFoundError) {\n    super(obj);\n    Object.setPrototypeOf(this, ResourceNotFoundError.prototype);\n  }\n}\n","export function isObject(val: unknown): val is Record<string | number, any> {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n","import { defined } from '@nextgis/utils';\n\nimport { isObject } from './isObject';\n\nimport type { Resource } from '../types/ResourceItem';\nimport type { DeepPartial } from '@nextgis/utils';\n\nconst exclude = ['description'];\n\n/**\n * @remarks\n * https://docs.nextgis.ru/docs_ngweb_dev/doc/developer/resource.html#search-resources\n *\n * ```\n * { keyname, owner_user: { id }} > { keyname, owner_user__id }\n * ```\n *\n * @param resource - Any property from NGW resource item\n */\nexport function resourceToQuery(\n  resource: DeepPartial<Resource>,\n  prefix = '',\n): Record<string, unknown> {\n  prefix = prefix ? prefix + '__' : '';\n  const query: Record<string, any> = {};\n  for (const [key, value] of Object.entries(resource)) {\n    if (exclude.indexOf(key) === -1) {\n      if (isObject(value)) {\n        if (key === 'owner_user') {\n          const children = resourceToQuery(value as DeepPartial<Resource>, key);\n          Object.assign(query, children);\n        } else if (key === 'parent' && 'id' in value) {\n          query.parent_id = value.id;\n        }\n      } else if (defined(value)) {\n        query[prefix + key] = value;\n      }\n    }\n  }\n  return query;\n}\n","import Cache from '@nextgis/cache';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined } from '@nextgis/utils';\n\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\nimport { isObject } from './utils/isObject';\nimport { resourceCompare } from './utils/resourceCompare';\nimport { resourceToQuery } from './utils/resourceToQuery';\n\nimport type { NgwConnector } from './NgwConnector';\nimport type {\n  GetChildrenOfOptions,\n  RequestOptions,\n  ResourceDefinition,\n} from './interfaces';\nimport type { Resource, ResourceItem } from './types/ResourceItem';\nimport type { DeepPartial } from '@nextgis/utils';\n\nexport class ResourcesControl {\n  cache = new Cache<\n    CancelablePromise<ResourceItem | undefined>,\n    { id?: number | string }\n  >();\n\n  constructor(private connector: NgwConnector) {}\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Receive resource from NGW by id, keyname or search-object parameter.\n   * @param resource - Resource id, keyname or search-object\n   *\n   * @remarks\n   * Fetching resource would be cached to speed up next call\n   */\n  getOne(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const cache = new Cache();\n    const forCache: { keyname?: string; id?: number } = {};\n    const opt = { ...requestOptions, cache: false };\n    if (typeof resource === 'string') {\n      forCache.keyname = resource;\n    } else if (typeof resource === 'number') {\n      forCache.id = resource;\n    } else if (isObject(resource)) {\n      if (resource.id !== undefined) {\n        forCache.id = resource.id;\n      } else if (resource.keyname) {\n        forCache.keyname = resource.keyname;\n      }\n    }\n    const makeRequest = () => {\n      if (typeof resource === 'string') {\n        return this._fetchResourceBy({ keyname: resource }, opt);\n      } else if (typeof resource === 'number') {\n        return this._fetchResourceById(resource, opt);\n      } else if (isObject(resource)) {\n        return this._fetchResourceBy(resource, opt);\n      }\n      return CancelablePromise.resolve(undefined);\n    };\n\n    return cache.addFull('resource', makeRequest, forCache);\n  }\n\n  getOneOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem> {\n    return this.getOne(resource, requestOptions).then((res) => {\n      if (res) {\n        return res;\n      }\n      throw new ResourceNotFoundError();\n    });\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * There are situations when exactly the resource id is needed\n   * (for example, to compose the correct request to the api)\n   * then this method will come in handy to facilitate the extraction of the identifier\n   * if the resource is specified through a keyname or other parameters.\n   */\n  getId(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<number | undefined> {\n    if (typeof resource === 'number') {\n      return CancelablePromise.resolve(resource);\n    } else if (typeof resource === 'string' || isObject(resource)) {\n      return this.getOne(resource, requestOptions).then((res) => {\n        if (res) {\n          return res.resource.id;\n        }\n      });\n    }\n    return CancelablePromise.resolve(undefined);\n  }\n\n  /**\n   * A fast way to retrieve resource ID for any resource definition.\n   * @param resource - Any available resource definition\n   *\n   * @remarks\n   * Similar with {@link NgwConnector.getResourceId | getResourceId} but rise error if resource is not exist.\n   * To not make one more checks if the resource is definitely exists\n   */\n  getIdOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<number> {\n    return this.getId(resource, requestOptions).then((resp) => {\n      if (resp === undefined) {\n        throw new Error();\n      }\n      return resp;\n    });\n  }\n\n  getMany(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem[]> {\n    return this._resourceCacheFilter(resource).then((items) => {\n      if (!items.length) {\n        const query: Record<string, unknown> = {};\n        if (resource.keyname) {\n          query.keyname = resource.keyname;\n        } else {\n          Object.assign(query, resourceToQuery(resource));\n        }\n        return this.connector\n          .get('resource.search', requestOptions, {\n            serialization: 'full',\n            ...query,\n          })\n          .then((resources) => {\n            if (resources) {\n              for (const x of resources) {\n                this.cache.add('resource.item', CancelablePromise.resolve(x), {\n                  id: x.resource.id,\n                });\n              }\n            }\n            return resources;\n          });\n      }\n      return items;\n    });\n  }\n\n  getParent(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getOne(resource, requestOptions).then((child) => {\n      if (child) {\n        return this.getOne(child.resource.parent.id, requestOptions);\n      }\n      return CancelablePromise.resolve(undefined);\n    });\n  }\n\n  getChildrenOf(\n    resource: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.getIdOrFail(resource).then((parent) =>\n      this._getChildrenOf(parent, requestOptions),\n    );\n  }\n\n  update(\n    resource: ResourceDefinition,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.put('resource.item', { data }, { id });\n      }\n    });\n  }\n\n  /**\n   * Fast way to delete resource from NGW and clean cache.\n   * @param resource - Resource definition\n   */\n  delete(resource: ResourceDefinition): CancelablePromise<void> {\n    return this.getId(resource).then((id) => {\n      if (id !== undefined) {\n        return this.connector.delete('resource.item', null, { id }).then(() => {\n          this._cleanResourceItemCache(id);\n          return undefined;\n        });\n      }\n    });\n  }\n\n  private _getChildrenOf(\n    parent: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n    _items: ResourceItem[] = [],\n  ): CancelablePromise<ResourceItem[]> {\n    return this.connector\n      .get(\n        'resource.collection',\n        { cache: true, ...requestOptions },\n        {\n          parent,\n        },\n      )\n      .then((items) => {\n        const recursivePromises = [];\n        for (const item of items) {\n          this.cache.add('resource.item', CancelablePromise.resolve(item), {\n            id: item.resource.id,\n          });\n          _items.push(item);\n          if (requestOptions?.recursive && item.resource.children) {\n            recursivePromises.push(\n              this._getChildrenOf(item.resource.id, requestOptions, _items),\n            );\n          }\n        }\n        if (recursivePromises.length) {\n          return CancelablePromise.all(recursivePromises).then(() => {\n            return _items;\n          });\n        }\n        return _items;\n      });\n  }\n\n  private async _cleanResourceItemCache(id: number) {\n    const all = this.cache.all();\n    const toDelete: typeof all = [];\n    for (const c of all) {\n      const cid = c.options && c.options.id;\n      if (['resource.item', 'resource'].includes(c.key) && cid !== undefined) {\n        if (typeof cid === 'number') {\n          if (cid === id) {\n            toDelete.push(c);\n          }\n        } else {\n          const rid = await this.getId(cid);\n          if (rid === id) {\n            toDelete.push(c);\n          }\n        }\n      }\n    }\n    for (const d of toDelete) {\n      this.cache.delete(d);\n    }\n  }\n\n  private _fetchResourceById(\n    id: number,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    const promise = () =>\n      this.connector.get('resource.item', requestOptions, { id });\n\n    return this.cache\n      .add('resource.item', promise, {\n        id,\n      })\n      .catch((er) => {\n        if (!(er instanceof ResourceNotFoundError)) {\n          throw er;\n        }\n        return undefined;\n      });\n  }\n\n  private _fetchResourceBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.getMany(resource, requestOptions).then((resources) => {\n      return resources[0];\n    });\n  }\n\n  private _resourceCacheFilter(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem[]> {\n    return CancelablePromise.all(this.cache.matchAll('resource.item')).then(\n      (resources) => {\n        const items: ResourceItem[] = [];\n        resources.filter((x) => {\n          if (x) {\n            // identical by uniq props\n            if (resource.keyname && x.resource.keyname) {\n              return resource.keyname === x.resource.keyname;\n            }\n            if (defined(resource.id) && defined(x.resource.id)) {\n              return resource.id === x.resource.id;\n            }\n            return resourceCompare(resource, x.resource);\n          }\n        });\n        return items;\n      },\n    );\n  }\n}\n","import { objectDeepEqual } from '@nextgis/utils';\n\nimport type { Resource } from '../types/ResourceItem';\nimport type { DeepPartial } from '@nextgis/utils';\n\nexport function resourceCompare(\n  res1: DeepPartial<Resource>,\n  res2: DeepPartial<Resource>,\n): boolean {\n  return objectDeepEqual(res1, res2);\n}\n","import { objectDeepEqual } from '@nextgis/utils';\n\nimport type { NgwConnector } from './NgwConnector';\nimport type { NgwConnectorOptions } from './interfaces';\n\nexport const CONNECTORS: NgwConnector[] = [];\n\nexport function addConnector(connector: NgwConnector): void {\n  CONNECTORS.push(connector);\n}\n\nexport function findConnector(\n  options: NgwConnectorOptions,\n): NgwConnector | undefined {\n  return CONNECTORS.find((x) => {\n    if (x.options.baseUrl === options.baseUrl) {\n      if (options.auth) {\n        if (x.options.auth) {\n          return objectDeepEqual(x.options.auth, options.auth);\n        }\n      } else {\n        // if auth not in find options; use first connector with same url\n        return true;\n      }\n    }\n  });\n}\n\nexport function removeConnector(connector: NgwConnector): void {\n  const index = CONNECTORS.indexOf(connector);\n  if (index !== -1) {\n    CONNECTORS.splice(index, 1);\n  }\n}\n\nexport function findAndRemoveConnector(options: NgwConnectorOptions): void {\n  const exist = findConnector(options);\n  if (exist) {\n    removeConnector(exist);\n  }\n}\n","import { NgwError } from './NgwError';\n\nimport type { NgwExceptions } from '../interfaces';\n\n/**\n * Thrown when ...\n */\nexport class InsufficientPermissionsError extends NgwError {\n  name = 'InsufficientPermissionsError';\n  exception: NgwExceptions =\n    'nextgisweb.core.exception.InsufficientPermissions';\n\n  constructor(obj: InsufficientPermissionsError) {\n    super(obj);\n    Object.setPrototypeOf(this, InsufficientPermissionsError.prototype);\n  }\n}\n","// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }): string {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","/**\n * Thrown when...\n */\nexport class NetworkError extends Error {\n  name = 'NetworkError';\n\n  constructor(url: string) {\n    super();\n    Object.setPrototypeOf(this, NetworkError.prototype);\n    this.message = `Unable to request ${url}.\n    Possibly invalid NGW URL entered or CORS not configured to get request from ${location.origin}`; // /control-panel/cors\n  }\n}\n","import { NetworkError } from '../errors/NetworkError';\nimport { NgwError } from '../errors/NgwError';\nimport { isError } from '../errors/isError';\n\nimport { isObject } from './isObject';\n\nimport type {\n  RequestOptions as NgwRequestOptions,\n  RequestMethods,\n} from '../interfaces';\n\n// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\ntype LoadData = (\n  url: string,\n  callback: (...args: any[]) => any,\n  options: NgwRequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (cancelHandler: () => void) => void,\n) => void;\n\nlet loadData: LoadData;\n// @ts-ignore\nif (__BROWSER__) {\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): void => {\n    options.method = options.method || 'GET';\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n    if (options.responseType === 'blob') {\n      xhr.responseType = options.responseType;\n    }\n    const getResponseText = () => {\n      try {\n        return JSON.parse(xhr.responseText);\n      } catch (er) {\n        return xhr.responseText;\n      }\n    };\n    const processingResponse = (forError = false) => {\n      const cb = forError ? error : callback;\n      if (options.responseType === 'blob') {\n        cb(xhr.response);\n      } else {\n        if (xhr.responseText) {\n          cb(getResponseText());\n        } else {\n          error({ message: '' });\n        }\n      }\n    };\n    xhr.onload = () => {\n      if ([401, 403, 404, 422, 500].indexOf(xhr.status) !== -1) {\n        error(new NgwError(getResponseText()));\n      }\n      processingResponse();\n    };\n\n    // xhr.onreadystatechange = () => {\n    //   if (\n    //     (xhr.readyState === 4 && xhr.status === 200) ||\n    //     (xhr.readyState === 3 && xhr.status === 201)\n    //   ) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 3 && xhr.status === 400) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 500) {\n    //     processingResponse();\n    //   } else if (xhr.readyState === 4 && xhr.status === 401) {\n    //     error(xhr.statusText);\n    //   } else if (xhr.readyState === 4) {\n    //     error('request error');\n    //   }\n    // };\n\n    xhr.onerror = (er) => {\n      if (xhr.status === 0) {\n        error(new NetworkError(url));\n      } else {\n        error(er);\n      }\n    };\n\n    xhr.upload.onprogress = function (e) {\n      if (e.lengthComputable) {\n        const percentComplete = (e.loaded / e.total) * 100;\n        if (options.onProgress) {\n          options.onProgress(percentComplete, e);\n        }\n        // console.log(percentComplete + '% uploaded');\n      }\n    };\n\n    const headers = options.headers;\n    if (headers) {\n      for (const h in headers) {\n        const header = headers[h];\n        if (typeof header === 'string') {\n          xhr.setRequestHeader(h, header);\n        }\n      }\n    }\n    if (options.withCredentials !== undefined) {\n      xhr.withCredentials = options.withCredentials;\n    }\n\n    let data: FormData | any;\n    if (options.file) {\n      data = new FormData();\n      data.append('file', options.file);\n      if (options.data) {\n        for (const d in options.data) {\n          data.append(d, data[d]);\n        }\n      }\n    } else {\n      data = options.data\n        ? typeof options.data === 'string'\n          ? options.data\n          : JSON.stringify(options.data)\n        : null;\n    }\n    if (onCancel) {\n      onCancel(() => {\n        xhr.abort();\n      });\n    }\n    xhr.send(data);\n  };\n} else {\n  const url = require('url');\n  const http = require('http');\n  const https = require('https');\n  const FormData = require('form-data');\n\n  const adapterFor = (inputUrl: string) => {\n    const adapters: Record<string, any> = {\n      'http:': http,\n      'https:': https,\n    };\n    const protocol = url.parse(inputUrl).protocol || 'https:';\n    return adapters[protocol];\n  };\n\n  loadData = (\n    url: string,\n    callback: (...args: any[]) => any,\n    options: NgwRequestOptions<RequestMethods> = {},\n    error: (reason?: any) => void,\n    onCancel: (cancelHandler: () => void) => void,\n  ): Promise<unknown> => {\n    const { file, headers, method, data, responseType } = options;\n\n    const request = new Promise((resolve, reject) => {\n      const adapter = adapterFor(url);\n      if (adapter) {\n        const requestOpt = {\n          headers: headers || {},\n          method,\n        };\n        const body = typeof data === 'string' ? data : JSON.stringify(data);\n        // https://stackoverflow.com/questions/35589109/node-http-delete-request-no-longer-works-after-upgrading-from-0-10-40\n        let form;\n        let uploadedFile = file;\n        if (file) {\n          const fileMeta = {};\n          if (\n            isObject(file) &&\n            'file' in file &&\n            ('filename' in file || 'name' in file)\n          ) {\n            const {\n              file: file_,\n              name,\n              ...fileMeta_\n            } = file as Record<string, any>;\n            if (name && !fileMeta_.filename) {\n              fileMeta_.filename = name;\n            }\n            Object.assign(fileMeta, fileMeta_);\n            uploadedFile = file_ as File;\n          }\n          form = new FormData();\n          form.append('file', uploadedFile, fileMeta);\n          if (data) {\n            for (const d in data) {\n              form.append(d, data[d]);\n            }\n          }\n          Object.assign(requestOpt.headers, {\n            // 'content-length': form.getLengthSync(),\n            ...form.getHeaders(),\n          });\n        }\n\n        if (body !== undefined) {\n          Object.assign(requestOpt.headers, {\n            'content-type': 'application/json',\n            'content-length': Buffer.byteLength(body),\n          });\n        }\n        const req = adapter.request(url, requestOpt, (resp: any) => {\n          let data = '';\n          resp.on('data', (chunk: any) => {\n            data += chunk;\n          });\n          resp.on('end', () => {\n            if (data) {\n              if (responseType === 'blob') {\n                resolve(data);\n              } else {\n                let json: Record<string, any> | undefined;\n                try {\n                  json = JSON.parse(data);\n                  if (json && json.status_code && json.status_code) {\n                    reject(json.message);\n                  }\n                } catch (er) {\n                  reject(er);\n                }\n                if (json !== undefined) {\n                  if (isError(json)) {\n                    reject('extractError(json)');\n                  } else {\n                    resolve(json);\n                  }\n                }\n              }\n            }\n            reject('no data');\n          });\n        });\n        if (form) {\n          form.pipe(req);\n        }\n        req.on('error', (err: any) => {\n          reject(err);\n        });\n        if (body) {\n          req.write(body);\n        }\n        onCancel(() => {\n          req.abort();\n        });\n        req.end();\n      } else {\n        throw new Error(`Given URL '${url}' is not correct`);\n      }\n    });\n    return request\n      .then((data) => {\n        if (callback) {\n          callback(data);\n        }\n        return data;\n      })\n      .catch((er) => {\n        if (error) {\n          error(er);\n        } else {\n          throw new Error(er);\n        }\n      });\n  };\n}\n\nexport { loadData };\n","import { EventEmitter } from 'events';\n\nimport Cache from '@nextgis/cache';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { objectRemoveEmpty } from '@nextgis/utils';\nimport { fixUrlStr } from '@nextgis/utils';\n\nimport { ResourcesControl } from './ResourcesControl';\nimport {\n  addConnector,\n  findConnector,\n  removeConnector,\n} from './activeConnectors';\nimport { InsufficientPermissionsError } from './errors/InsufficientPermissionsError';\nimport { NgwError } from './errors/NgwError';\nimport { ResourceNotFoundError } from './errors/ResourceNotFoundError';\nimport { apiRequest } from './utils/apiRequest';\nimport { loadData } from './utils/loadData';\nimport { template } from './utils/template';\n\nimport type {\n  Credentials,\n  DeleteRequestItemsResponseMap,\n  GetChildrenOfOptions,\n  GetRequestItemsResponseMap,\n  NgwConnectorOptions,\n  Params,\n  PatchRequestItemsResponseMap,\n  PostRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  PyramidRoute,\n  RequestHeaders,\n  RequestItemKeys,\n  RequestItemsParams,\n  RequestOptions,\n  RequestTransformFunction,\n  ResourceDefinition,\n  ResourceIdKeynameDef,\n  UserInfo,\n} from './interfaces';\nimport type { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport type { Resource, ResourceItem } from './types/ResourceItem';\nimport type { DeepPartial } from '@nextgis/utils';\n\nlet ID = 0;\n\nexport class NgwConnector {\n  static errors = {\n    NgwError,\n    ResourceNotFoundError,\n  };\n  id = ID++;\n\n  emitter = new EventEmitter();\n  user?: UserInfo;\n\n  resources!: ResourcesControl;\n\n  private routeStr = '/api/component/pyramid/route';\n  private activeRequests: CancelablePromise[] = [];\n  private requestTransform?: RequestTransformFunction | null;\n\n  constructor(public options: NgwConnectorOptions) {\n    const exist = findConnector(options);\n    if (exist) {\n      return exist;\n    } else {\n      if (this.options.route) {\n        this.routeStr = this.options.route;\n      }\n      if (this.options.requestTransform) {\n        this.requestTransform = this.options.requestTransform;\n      }\n      this.resources = new ResourcesControl(this);\n      addConnector(this);\n    }\n  }\n\n  static create(options: NgwConnectorOptions): NgwConnector {\n    return new this(options);\n  }\n\n  setRequestTransform(\n    requestTransform: RequestTransformFunction | undefined | null,\n  ) {\n    this.requestTransform = requestTransform;\n  }\n\n  /**\n   * Fast way to specify the connection address to NextGIS Web.\n   * The current connection will be severed.\n   * @param baseUrl - NGW url\n   */\n  setNgw(baseUrl: string): void {\n    this.logout();\n    this.options.baseUrl = baseUrl;\n    addConnector(this);\n  }\n\n  /**\n   * Establishing a connection with NextGIS Web to fulfill all other requests.\n   * @remarks\n   * This method need not be called manually as it is used when forming a request in {@link apiRequest | apiRequest}.\n   * Can be used to check connection.\n   * @example\n   * ```javascript\n   * const connector = new NgwConnector({baseUrl: 'https://demo.nextgis.com'});\n   * connector.connect()\n   *   .then(() => console.log('Ok'))\n   *   .catch((er) => console.log('Connection problem', er));\n   * ```\n   */\n  connect(): CancelablePromise<PyramidRoute> {\n    const cache = new Cache();\n    const auth = this.options.auth;\n    const makeConnect = () =>\n      new CancelablePromise((resolve, reject) => {\n        const makeQuery = () => {\n          return this.makeQuery<PyramidRoute>(this.routeStr, {}, {})\n            .then((route) => {\n              resolve(route);\n            })\n            .catch((er) => {\n              reject(er);\n            });\n        };\n        if (auth) {\n          const { login, password } = auth;\n          if (login && password) {\n            return this._login({ login, password })\n              .then(() => {\n                return makeQuery();\n              })\n              .catch((er) => reject(er));\n          }\n        }\n        return makeQuery();\n      });\n    return cache.add('route', makeConnect, {\n      id: this.id,\n      auth,\n      baseUrl: this.options.baseUrl,\n    });\n  }\n\n  /**\n   * Quick way to change NextGIS Web user.\n   * @param credentials - New user credentials\n   */\n  login(\n    credentials: Credentials,\n    options?: RequestOptions,\n  ): CancelablePromise<UserInfo> {\n    this.logout();\n    addConnector(this);\n    return this._login(credentials, options);\n  }\n\n  /**\n   * Disconnecting a user. Aborting all current requests\n   */\n  logout(): void {\n    this.abort();\n    removeConnector(this);\n    this.options.auth = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n    this.resources.cache.clean();\n  }\n\n  getUserInfo(\n    credentials?: Credentials,\n    options?: RequestOptions,\n  ): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options_: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials),\n      // withCredentials: true\n      ...options,\n    };\n\n    // Do not use apiRequest('auth.current_user') to avoid circular-references\n    return this.makeQuery<UserInfo>(\n      '/api/component/auth/current_user',\n      {},\n      options_,\n    );\n  }\n\n  /**\n   * Obtaining the required Headers for authentication of requests in the NGW.\n   */\n  getAuthorizationHeaders(\n    credentials?: Credentials,\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client,\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials): string | undefined {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      const str = unescape(encodeURIComponent(`${login}:${password}`));\n      // @ts-ignore\n      if (__BROWSER__) {\n        return window.btoa(str);\n      } else {\n        return Buffer.from(str).toString('base64');\n      }\n    }\n  }\n\n  /** Stop all api requests */\n  abort() {\n    for (const req of this.activeRequests) {\n      req.cancel();\n    }\n    this.activeRequests = [];\n  }\n\n  getActiveApiRequests() {\n    return [...this.activeRequests];\n  }\n\n  /**\n   * Send request to NGW api router.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param params - Request item params or query params\n   * @param requestOptions - Request options\n   *\n   * @example\n   * ```javascript\n   *\n   * // there is such an NGW route item\n   * // \"feature_layer.feature.item\": [\n   * //   \"/api/resource/{0}/feature/{1}\",\n   * //   \"id\",\n   * //   \"fid\"\n   * // ],\n   *\n   * const connector = new NgwConnector({ baseUrl: 'https://example.nextgis.com' });\n   * connector.apiRequest('feature_layer.feature.item', {\n   *   // request params for {0} and {1}\n   *   'id': 2011,\n   *   'fid': 101,\n   *   // query params\n   *   'srs': 4326,\n   *   'geom_format': 'geojson',\n   * }, { method: 'GET' });\n   * // send get-request to 'https://example.nextgis.com/api/resource/2011/feature/101?srs=4326&geom_format=geojson'\n   *\n   * ```\n   */\n  apiRequest<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys,\n  >(\n    name: K,\n    params_: RequestItemsParams<K> = {},\n    requestOptions: RequestOptions = {},\n  ): CancelablePromise<P[K]> {\n    const { method, headers, withCredentials, responseType } = requestOptions;\n\n    params_ = requestOptions.params ?? params_;\n    const params = objectRemoveEmpty(params_);\n    const makeApiRequest = () =>\n      apiRequest({ name, params, requestOptions, connector: this });\n    if (requestOptions.cache && method === 'GET') {\n      const cache = new Cache<CancelablePromise<P[K]>>();\n      return cache.add(name, makeApiRequest, {\n        params,\n        ...objectRemoveEmpty({\n          headers,\n          withCredentials,\n          responseType,\n          baseUrl: this.options.baseUrl,\n          userId: this.user?.id,\n        }),\n      });\n    }\n    return makeApiRequest();\n  }\n\n  /**\n   * Shortcut method for send POST request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   *\n   * @example\n   * ```javascript\n   * connector.post('resource.collection', { data: POST_PAYLOAD })\n   *   .then((newResource) => console.log(newResource))\n   *   .catch((error) => console.warn(error));\n   * ```\n   */\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST', K>,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    return this.apiRequest<K, PostRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send GET request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'GET', K> | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    return this.apiRequest<K, GetRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PATCH request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'PATCH', K>,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    return this.apiRequest<K, PatchRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send PUT request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'PUT', K>,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    return this.apiRequest<K, PutRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Shortcut method for send DELETE request to NGW.\n   * @param name - NGW route name from {@link https://docs.nextgis.com/docs_ngweb_dev/doc/developer/resource.html#routes | routes}\n   * @param options - Request options\n   * @param params - Request item params or query params\n   */\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'DELETE', K> | undefined | null,\n    params?: RequestItemsParams<K>,\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    return this.apiRequest<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options,\n    );\n  }\n\n  /**\n   * Send request to NGW.\n   * @param url - URL address to NGW\n   * @param params - Query params\n   * @param options - Request options\n   */\n  makeQuery<R = unknown>(\n    url: string,\n    params?: Params | null,\n    options: RequestOptions = {},\n  ): CancelablePromise<R> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      url = encodeURI(fixUrlStr(url));\n      return this._loadData(url, options);\n    } else {\n      throw new Error('Empty `url` not allowed');\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  // Resource Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * {@link ResourcesControl.getOne}\n   */\n  getResource(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource, requestOptions);\n  }\n\n  /**\n   * {@link ResourcesControl.getOneOrFail}\n   */\n  getResourceOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem> {\n    return this.resources.getOneOrFail(resource, requestOptions);\n  }\n\n  /**\n   * @deprecated - use {@link getResource}\n   */\n  getResourceBy(\n    resource: DeepPartial<Resource>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(resource);\n  }\n\n  /**\n   * @deprecated - use {@link getResource}\n   */\n  getResourceByKeyname(\n    keyname: string,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(keyname);\n  }\n\n  /**\n   * @deprecated - use {@link getResource}\n   */\n  getResourceById(id: number): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getOne(id);\n  }\n\n  /**\n   * {@link ResourcesControl.getId}\n   */\n  getResourceId(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<number | undefined> {\n    return this.resources.getId(resource, requestOptions);\n  }\n\n  /**\n   * {@link ResourcesControl.getIdOrFail}\n   */\n  getResourceIdOrFail(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<number> {\n    return this.resources.getIdOrFail(resource, requestOptions);\n  }\n\n  /**\n   * {@link ResourcesControl.getMany}\n   */\n  getResourcesBy(\n    resource: DeepPartial<Resource>,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getMany(resource, requestOptions);\n  }\n\n  /**\n   * {@link ResourcesControl.getParent}\n   */\n  getResourceParent(\n    resource: ResourceDefinition,\n    requestOptions?: RequestOptions<'GET'>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.getParent(resource, requestOptions);\n  }\n\n  /**\n   * {@link ResourcesControl.getChildrenOf}\n   */\n  getResourceChildren(\n    resource: ResourceDefinition,\n    requestOptions?: GetChildrenOfOptions,\n  ): CancelablePromise<ResourceItem[]> {\n    return this.resources.getChildrenOf(resource, requestOptions);\n  }\n\n  /**\n   * {@link ResourcesControl.update}\n   */\n  updateResource(\n    resource: ResourceIdKeynameDef,\n    data: DeepPartial<ResourceItem>,\n  ): CancelablePromise<ResourceItem | undefined> {\n    return this.resources.update(resource, data);\n  }\n\n  /**\n   * {@link ResourcesControl.delete}\n   */\n  deleteResource(resource: ResourceIdKeynameDef): CancelablePromise<void> {\n    return this.resources.delete(resource);\n  }\n\n  /**\n   * @internal\n   */\n  protected _loadData(\n    url: string,\n    options: RequestOptions,\n  ): CancelablePromise<any> {\n    options.responseType = options.responseType || 'json';\n\n    const request = new CancelablePromise((resolve, reject, onCancel) => {\n      if (this.user) {\n        options = options || {};\n        // options.withCredentials = true;\n        options.headers = {\n          ...this.getAuthorizationHeaders(),\n          ...options.headers,\n        };\n      }\n\n      if (this.requestTransform) {\n        const [transUrl, transOptions] = this.requestTransform(url, options);\n        url = transUrl;\n        options = transOptions;\n      }\n      loadData(url, resolve, options, reject, onCancel);\n    })\n      .then((resp) => {\n        this._cleanActiveRequests(request);\n        return resp;\n      })\n      .catch((httpError) => {\n        this._cleanActiveRequests(request);\n        if (httpError instanceof CancelablePromise.CancelError) {\n          // not need to handle cancel error because onCancel method is used\n        } else {\n          // @ts-ignore\n          if (__DEV__) {\n            console.warn('DEV WARN', httpError);\n          }\n          const er = this._handleHttpError(httpError);\n          if (er) {\n            throw er;\n          }\n        }\n      });\n    if (\n      options.signal &&\n      typeof options.signal.addEventListener === 'function'\n    ) {\n      options.signal.addEventListener('abort', () => {\n        request.cancel();\n        this._cleanActiveRequests(request);\n      });\n    }\n    this.activeRequests.push(request);\n    return request;\n  }\n\n  private _login(\n    credentials: Credentials,\n    options?: RequestOptions,\n  ): CancelablePromise<UserInfo> {\n    return this.getUserInfo(credentials, options)\n      .then((data) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch((er) => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  private _cleanActiveRequests(request: CancelablePromise) {\n    const activeRequestIndex = this.activeRequests.indexOf(request);\n    if (activeRequestIndex !== -1) {\n      this.activeRequests.splice(activeRequestIndex, 1);\n    }\n  }\n\n  private _handleHttpError(er: Error) {\n    if (er) {\n      if (er instanceof NgwError) {\n        if (er.exception === 'nextgisweb.resource.exception.ResourceNotFound') {\n          throw new ResourceNotFoundError(er);\n        } else if (\n          er.exception === 'nextgisweb.core.exception.InsufficientPermissions'\n        ) {\n          throw new InsufficientPermissionsError(er);\n        }\n      }\n    }\n    return er;\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\n\nimport { template } from './template';\n\nimport type { NgwConnector } from '../NgwConnector';\nimport type {\n  RequestItemKeys,\n  RequestItemsParams,\n  RequestOptions,\n} from '../interfaces';\nimport type { RequestItemsParamsMap } from '../types/RequestItemsParamsMap';\n\ninterface ApiRequestOptions<K extends keyof RequestItemsParamsMap> {\n  name: string;\n  connector: NgwConnector;\n  params: RequestItemsParams<K>;\n  requestOptions: RequestOptions;\n}\n\nexport function apiRequest<\n  K extends keyof RequestItemsParamsMap,\n  P extends RequestItemKeys = RequestItemKeys,\n>(opt: ApiRequestOptions<K>): CancelablePromise<P[K]> {\n  const params = opt.params;\n  return new CancelablePromise((resolve, reject) => {\n    opt.connector\n      .connect()\n      .then((apiItems) => {\n        let apiItem = apiItems && apiItems[opt.name];\n        if (apiItem) {\n          apiItem = [...apiItem];\n          let url = apiItem.shift();\n          if (apiItem.length) {\n            const replaceParams: {\n              [num: number]: string;\n            } = {};\n            for (let fry = 0; fry < apiItem.length; fry++) {\n              const arg = apiItem[fry];\n              replaceParams[fry] = '{' + arg + '}';\n              if (params[arg] === undefined) {\n                throw new Error(\n                  '`' + arg + '`' + ' url api argument is not specified',\n                );\n              }\n            }\n            if (url) {\n              url = template(url, replaceParams);\n            }\n          }\n          // Transfer part of the parameters from `params` to the URL string\n          if (params) {\n            const paramArray = [];\n            const paramList = params.paramList;\n            if (Array.isArray(paramList)) {\n              delete params.paramList;\n              paramList.forEach((x) => {\n                paramArray.push(`${x[0]}=${x[1]}`);\n              });\n            }\n            for (const p in params) {\n              if (apiItem.indexOf(p) === -1) {\n                paramArray.push(`${p}=${params[p]}`);\n              }\n            }\n            if (paramArray.length) {\n              url = url + '?' + paramArray.join('&');\n            }\n          }\n          if (url) {\n            resolve(opt.connector.makeQuery(url, params, opt.requestOptions));\n          } else {\n            reject(new Error('request url is not set'));\n          }\n        } else {\n          resolve(undefined);\n        }\n      })\n      .catch((er) => {\n        reject(er);\n      });\n  });\n}\n","/**\n * A lightweight HTTP client optimized for use with {@link http://docs.nextgis.ru/docs_ngweb_dev/doc/developer/toc.html | NextGIS Web} API\n *\n * @remarks\n * Make sure CORS is registered in the {@link https://docs.nextgis.com/docs_ngcom/source/CORS.html | NextGIS Web settings } to be able to send requests.\n *\n * @packageDocumentation\n * @module ngw-connector\n */\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\nexport default NgwConnector;\n","import NgwConnector from '@nextgis/ngw-connector';\n\nimport { NgwWebmapLayerAdapter } from './NgwWebmapLayerAdapter';\nimport { classAdapters } from './adapters/createAsyncAdapter';\nimport { extendNgwWebmapLayerAdapter } from './utils/utils';\n\nimport type {\n  GetClassAdapter,\n  NgwKitOptions,\n  NgwWebmapAdapterOptions,\n} from './interfaces';\nimport type { Type } from '@nextgis/utils';\nimport type { LayerAdapterCreators, StarterKit, WebMap } from '@nextgis/webmap';\n\nexport class NgwKit implements StarterKit {\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl || '';\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth,\n      });\n    }\n  }\n\n  static addClassAdapters(cls: string, adapter: GetClassAdapter): void {\n    classAdapters[cls] = adapter;\n  }\n\n  async onLoadSync(webMap: WebMap): Promise<NgwWebmapLayerAdapter | undefined> {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: Partial<NgwWebmapAdapterOptions> = {\n            resourceId: r,\n            connector: this.connector,\n            webMap,\n          };\n          const layer = (await webMap.addLayer(NgwWebmapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            pixelRadius: this.options.pixelRadius,\n            ...options,\n          })) as NgwWebmapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap)),\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<NgwWebmapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendNgwWebmapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl,\n    });\n  }\n}\n","import { getDefaultControls } from '@nextgis/webmap';\nimport { deepmerge } from '@nextgis/utils';\nimport type { StarterKit, MapOptions } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { NgwKit } from '@nextgis/ngw-kit';\n\nimport type { NgwMapOptions } from '../interfaces';\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  whitlabel: false,\n  controls: getDefaultControls(),\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"https://nextgis.com\" target=\"_blank\">©NextGIS</a>',\n      ],\n    },\n  },\n  pixelRadius: 10,\n};\n\nexport function prepareWebMapOptions(options: NgwMapOptions): MapOptions {\n  const kits: StarterKit[] = [new QmsKit()];\n  if (options.starterKits) {\n    options.starterKits.forEach((x) => {\n      kits.push(x);\n    });\n  }\n\n  if (!options.connector) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl || '',\n      auth: options.auth,\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  options = deepmerge(OPTIONS, options);\n\n  if (!options.center && !options.bounds) {\n    options.bounds = [-179, -90, 180, 90];\n    // options.maxBounds = options.bounds;\n  }\n\n  if (options.connector) {\n    kits.push(\n      new NgwKit({\n        connector: options.connector,\n        auth: options.auth,\n      }),\n    );\n  }\n  options = {\n    ...options,\n    starterKits: kits,\n    create: false,\n  };\n  return options;\n}\n","import type StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined, isObject, getIdentifyRadius } from '@nextgis/utils';\nimport { WebMap } from '@nextgis/webmap';\nimport type NgwConnector from '@nextgis/ngw-connector';\n\nimport {\n  fetchNgwLayerFeatureCollection,\n  createNgwLayerAdapter,\n  fetchNgwLayerFeature,\n  fetchIdentifyGeoJson,\n  sendIdentifyRequest,\n  createIdentifyItem,\n  fetchNgwLayerItems,\n  fetchIdentifyItem,\n  fetchNgwLayerItem,\n  getIdentifyItems,\n  getCompanyLogo,\n  fetchNgwExtent,\n} from '@nextgis/ngw-kit';\nimport { deprecatedWarn } from '@nextgis/utils';\nimport { getIcon } from '@nextgis/icons';\n\nimport { appendNgwResources } from './utils/appendNgwResources';\nimport { prepareWebMapOptions } from './utils/prepareWebMapOptions';\n\nimport type { JsonMap, FeatureProperties } from '@nextgis/utils';\nimport type {\n  FeatureItem,\n  LayerFeature,\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureLayersIdentifyItems,\n} from '@nextgis/ngw-connector';\nimport type {\n  OnLayerMouseOptions,\n  ControlPosition,\n  MapClickEvent,\n  LayerAdapter,\n  WebMapEvents,\n  MapControls,\n  FitOptions,\n  LayerDef,\n  AdapterOptions,\n} from '@nextgis/webmap';\nimport type {\n  NgwIdentify,\n  NgwWebmapItem,\n  ResourceAdapter,\n  FetchNgwItemsOptions,\n  NgwFeatureItemResponse,\n  NgwFeatureRequestOptions,\n} from '@nextgis/ngw-kit';\nimport type { Geometry, Feature, FeatureCollection } from 'geojson';\nimport type { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport type { NgwLayerOptions } from '@nextgis/ngw-kit';\nimport type {\n  NgwIdentifyEvent,\n  NgwMapOptions,\n  NgwMapEvents,\n  NgwLayers,\n} from './interfaces';\nimport type { FetchNgwItemOptions } from '@nextgis/ngw-kit';\n\ntype PromiseGroup = 'select' | 'identify';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import { NgwMap } from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n *   qmsId: 448,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<\n  M = unknown,\n  L = unknown,\n  C extends object = any,\n  O extends NgwMapOptions<M, C> = NgwMapOptions<M, C>,\n> extends WebMap<M, L, C, NgwMapEvents, O> {\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<EventEmitter, NgwMapEvents> =\n    new EventEmitter();\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private $$selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private $$selectFromNgwVector?: (ev: OnLayerMouseOptions) => void;\n  private _promises: Record<PromiseGroup, CancelablePromise[]> = {\n    select: [],\n    identify: [],\n  };\n\n  constructor(options: O) {\n    super(prepareWebMapOptions(options) as O);\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      if (this.options.whitlabel) {\n        this._whiteLabel();\n      }\n    });\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param options - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    await this.onLoad('controls:create');\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource definition.\n   * @param options - set layer identification parameters and render method.\n   *\n   * @example\n   * ```javascript\n   * // Add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resource: 4005 });\n   * // Add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resource: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  async addNgwLayer(\n    options: NgwLayerOptions,\n  ): Promise<ResourceAdapter | undefined> {\n    await this.onMapLoad();\n    // @ts-ignore for backward compatibility\n    const { keyname, resourceId } = options;\n\n    if (keyname || resourceId !== undefined) {\n      deprecatedWarn(\n        'set `resource` options instead of `keyname` or `resourceId`',\n      );\n    }\n\n    const resource = options.resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resource, resourceId or keyname is required parameter to add NGW layer',\n      );\n    }\n    if (defined(this.options.baseUrl)) {\n      try {\n        if (defined(this.options.setViewDelay)) {\n          options.adapterOptions = options.adapterOptions || {};\n          if (!defined(options.adapterOptions.setViewDelay)) {\n            options.adapterOptions.setViewDelay = this.options.setViewDelay;\n          }\n        }\n        const adapter = createNgwLayerAdapter(options, this, this.connector);\n        const adapterOpts = {\n          visibility: true,\n          // TODO: do not merge options, use only `adapterOptions`\n          ...options,\n          ...options.adapterOptions,\n        } as AdapterOptions;\n        const layer = (await this.addLayer(\n          adapter,\n          adapterOpts,\n        )) as ResourceAdapter<M, L, AdapterOptions>;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n          layer.options.name =\n            layer.options.name ||\n            (layer.item && layer.item.resource.display_name);\n          if (layer.options.baselayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n        return layer;\n      } catch (er) {\n        const resId =\n          isObject(resource) && 'id' in resource\n            ? resource.id\n            : keyname || resourceId || resource;\n        console.error(`Can't add NGW layer ${resId}.`, er);\n      }\n    }\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit(): void {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  fetchNgwLayerItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureItem> {\n    return fetchNgwLayerItem<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerItems<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(\n    options: Omit<FetchNgwItemsOptions<F>, 'connector'>,\n  ): CancelablePromise<FeatureItem<F, G>[]> {\n    return fetchNgwLayerItems<G, F>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<Feature<G, P>> {\n    return fetchNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemsOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return fetchNgwLayerFeatureCollection({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchIdentifyItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    identify: NgwIdentify,\n    requestOptions?: NgwFeatureRequestOptions,\n    // multiple = false\n  ): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n    const promise = fetchIdentifyItem<G, P>({\n      identify,\n      connector: this.connector,\n      requestOptions,\n      // multiple,\n    });\n\n    this._addPromise('identify', promise);\n    return promise;\n  }\n\n  fetchIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    const promise = fetchIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple,\n    });\n    if (promise && 'then' in promise) {\n      this._addPromise('identify', promise);\n      return promise;\n    } else {\n      return CancelablePromise.resolve(promise);\n    }\n  }\n\n  /**\n   * @deprecated use {@link fetchIdentifyGeoJson} instead\n   */\n  getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    return this.fetchIdentifyGeoJson(identify, multiple);\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some((x) => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as NgwWebmapItem[];\n        const dependFit = dependLayers.find((x) => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resource: 4005 });\n   * ngwMap.fitLayer(ngwLayer);\n   * ngwMap.fitLayer('ngw_layer_name');\n   * ```\n   */\n  async fitLayer(\n    layerDef: LayerDef | number,\n    options?: FitOptions,\n  ): Promise<void> {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getBounds) {\n        const bounds = await ngwLayer.layer.getBounds();\n        if (bounds) {\n          this.fitBounds(bounds, options);\n        }\n      } else {\n        let item: ResourceItem | undefined;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.getResource(resourceId);\n        }\n        if (item) {\n          fetchNgwExtent({\n            resourceId: item.resource.id,\n            connector: this.connector,\n          }).then((extent) => {\n            if (extent) {\n              this.fitBounds(extent, options);\n            }\n          });\n        }\n      }\n    } else {\n      super.fitLayer(\n        typeof layerDef === 'number' ? String(layerDef) : layerDef,\n        options,\n      );\n    }\n  }\n\n  /** @deprecated use {@link fitLayer} instead */\n  async zoomToLayer(layerDef: string | ResourceAdapter): Promise<void> {\n    return this.fitLayer(layerDef);\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection(): void {\n    if (!this.$$selectFromNgwRaster) {\n      this.$$selectFromNgwRaster = (ev: MapClickEvent) => {\n        const count = this._getSelectListenersCount();\n        if (count) {\n          this.selectFromNgwRaster(ev);\n        }\n      };\n      this.$$selectFromNgwVector = (ev: OnLayerMouseOptions) => {\n        const count = this._getSelectListenersCount();\n        if (count) {\n          this._selectFromNgwVector(ev);\n        }\n      };\n      this.emitter.on('click', this.$$selectFromNgwRaster);\n      this.emitter.on('layer:click', this.$$selectFromNgwVector);\n    }\n  }\n\n  disableSelection(): void {\n    if (this.$$selectFromNgwRaster) {\n      this.emitter.removeListener('click', this.$$selectFromNgwRaster);\n      this.$$selectFromNgwRaster = undefined;\n    }\n    if (this.$$selectFromNgwVector) {\n      this.emitter.removeListener('layer:click', this.$$selectFromNgwVector);\n\n      this.$$selectFromNgwVector = undefined;\n    }\n  }\n\n  /**\n   * @deprecated use {@link fetchNgwLayerItem} instead\n   */\n  getNgwLayerItem<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<FeatureItem> {\n    return this.fetchNgwLayerItem<G, P>(options);\n  }\n\n  /**\n   * @deprecated use {@link fetchNgwLayerItems} instead\n   */\n  getNgwLayerItems<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(\n    options: Omit<FetchNgwItemsOptions<F>, 'connector'>,\n  ): CancelablePromise<FeatureItem<F, G>[]> {\n    return this.fetchNgwLayerItems<F, G>(options);\n  }\n\n  /**\n   * @deprecated use {@link fetchNgwLayerFeature} instead\n   */\n  getNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends FeatureProperties = FeatureProperties,\n  >(\n    options: Omit<FetchNgwItemOptions<P>, 'connector'>,\n  ): CancelablePromise<Feature<G, P>> {\n    return this.fetchNgwLayerFeature<G, P>(options);\n  }\n\n  /**\n   * @deprecated use {@link fetchNgwLayerFeatures} instead\n   */\n  getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends JsonMap = JsonMap,\n  >(\n    options: FetchNgwItemsOptions<P>,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return this.fetchNgwLayerFeatures(options);\n  }\n\n  /** @deprecated use {@link cancelPromises} instead */\n  cancelPromise(...args: PromiseGroup[]): void {\n    this.cancelPromises(...args);\n  }\n\n  cancelPromises(...args: PromiseGroup[]): void {\n    if (!args.length) {\n      args = Object.keys(this._promises) as PromiseGroup[];\n    }\n    args.forEach((name) => {\n      const group = this._promises[name];\n      if (group) {\n        group.forEach((x) => x.cancel());\n        this._promises[name] = [];\n      }\n    });\n  }\n\n  async selectFromNgwRaster(\n    ev: MapClickEvent,\n  ): Promise<NgwIdentifyEvent | undefined> {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    const layers = Object.values(this._ngwLayers);\n    layers.sort((a, b) => {\n      if (a.layer.order && b.layer.order) {\n        return b.layer.order - a.layer.order;\n      }\n      return 1;\n    });\n    for (const l of layers) {\n      const layer = l.layer;\n      const identFunc =\n        typeof layer.getIdentificationIds === 'function'\n          ? layer.getIdentificationIds\n          : false;\n      const interactive = layer.options.interactive ?? true;\n      if (\n        identFunc &&\n        layer.options.selectable &&\n        interactive &&\n        this.isLayerVisible(layer)\n      ) {\n        promises.push(identFunc.call(layer));\n      }\n    }\n    const getIdsPromise = Promise.all(promises);\n    const getIds = await getIdsPromise;\n    const ids: number[] = [];\n    for (const x of getIds) {\n      if (x) {\n        ids.push(...x);\n      }\n    }\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    let zoom = this.getZoom();\n    zoom = zoom !== undefined ? zoom : 20;\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const radius = getIdentifyRadius(center, zoom, pixelRadius);\n\n    const selectPromise = sendIdentifyRequest(ev, {\n      layers: ids,\n      connector: this.connector,\n      radius,\n    }).then((resp) => {\n      const identify: NgwIdentify = {\n        ...resp,\n        resources: ids,\n        sourceType: 'raster',\n        event: ev,\n      };\n      const identifyEvent: NgwIdentifyEvent = this._prepareToIdentify(identify);\n      this._emitStatusEvent('ngw:select', identifyEvent);\n      return identifyEvent;\n    });\n    this._addPromise('select', selectPromise);\n    return selectPromise;\n  }\n\n  private _addPromise(groupName: PromiseGroup, promise: CancelablePromise) {\n    const group = this._promises[groupName];\n    if (group && group.indexOf(promise) === -1) {\n      const removeFromGroup = () => {\n        const index = group.indexOf(promise);\n        if (index !== -1) {\n          group.splice(index, 1);\n        }\n      };\n      promise.then(removeFromGroup);\n      promise.catch(removeFromGroup);\n      group.push(promise);\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create();\n    if (this.options.qmsId) {\n      this._addQmsBaseLayer();\n    }\n    if (this.options.osm) {\n      this._addOsmBaseLayer();\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed,\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      for (const x of this.options.resources) {\n        const overwriteOptions: Partial<NgwLayerOptions> = {};\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      }\n    }\n    for (const r of resources) {\n      try {\n        await this.addNgwLayer(r);\n      } catch (er) {\n        console.warn(er);\n      }\n    }\n    this._emitStatusEvent('ngw-map:create', this);\n    this.enableSelection();\n  }\n\n  private _addOsmBaseLayer() {\n    this.addBaseLayer('OSM');\n  }\n\n  private _addQmsBaseLayer() {\n    let qmsId: number;\n    let qmsLayerName: string | undefined;\n    if (Array.isArray(this.options.qmsId)) {\n      qmsId = this.options.qmsId[0];\n      qmsLayerName = this.options.qmsId[1];\n    } else {\n      qmsId = Number(this.options.qmsId);\n    }\n    const qmsLayerOptions: Partial<QmsAdapterOptions> = {\n      qmsId,\n    };\n    if (qmsLayerName) {\n      qmsLayerOptions.id = qmsLayerName;\n    }\n\n    this.addBaseLayer('QMS', qmsLayerOptions);\n  }\n\n  private _selectFromNgwVector(\n    ev: OnLayerMouseOptions,\n  ): FeatureLayersIdentify | undefined {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    const selectable = layer.options.selectable && this.isLayerVisible(layer);\n    if (!selectable) {\n      return undefined;\n    }\n    // Item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties || {},\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry,\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature],\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items,\n        };\n        this._emitStatusEvent(\n          'ngw:select',\n          this._prepareToIdentify({\n            ...identify,\n            resources: [id],\n            sourceType: 'vector',\n          } as NgwIdentify),\n        );\n        return identify;\n      }\n    }\n  }\n\n  private _prepareToIdentify<\n    F extends FeatureProperties = FeatureProperties,\n    G extends Geometry = Geometry,\n  >(identify: NgwIdentify): NgwIdentifyEvent {\n    const getIdentifyItems_ = () => {\n      return getIdentifyItems(identify, true).map((x) => {\n        return createIdentifyItem<F, G>({\n          feature: x.feature,\n          connector: this.connector,\n        });\n      });\n    };\n    return {\n      ...identify,\n      getIdentifyItems: getIdentifyItems_,\n    };\n  }\n\n  private _getSelectListenersCount() {\n    return this.emitter.listenerCount('ngw:select');\n  }\n\n  private async _whiteLabel() {\n    const container = this.getContainer();\n    if (container) {\n      const logo = await getCompanyLogo(\n        this.connector,\n        this.options.companyLogoOptions,\n      );\n      if (logo) {\n        container.appendChild(logo);\n      }\n    }\n  }\n}\n","import type { CompanyLogoOptions } from '../interfaces';\nimport type NgwConnector from '@nextgis/ngw-connector';\n\nexport async function getCompanyLogo(\n  connector: NgwConnector,\n  options?: CompanyLogoOptions,\n): Promise<HTMLElement | undefined> {\n  const settings = await connector.get('pyramid.settings', null, {\n    component: 'pyramid',\n  });\n  if (settings && settings.company_logo && settings.company_logo.enabled) {\n    const anchor = document.createElement('a');\n    anchor.style.position = 'absolute';\n    anchor.style.bottom = '0';\n    anchor.style.right = '0';\n    anchor.style.padding = options?.padding ?? '10px';\n    anchor.className = 'ngw-map-logo';\n    if (options && options.cssClass) {\n      anchor.className += ' ' + options.cssClass;\n    }\n    const img = new Image();\n    img.style.maxHeight = '100px';\n    img.style.maxWidth = '100px';\n    img.src = '';\n    try {\n      const src = await connector.get('pyramid.company_logo', {\n        responseType: 'blob',\n      });\n      const urlCreator = window.URL || window.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(src as any);\n      img.src = imageUrl;\n    } catch (er) {\n      console.warn(er);\n    }\n\n    if (\n      settings.company_logo.link !== null &&\n      settings.company_logo.link.trim() !== ''\n    ) {\n      anchor.href = settings.company_logo.link;\n      anchor.target = '_blank';\n      if (settings.company_logo.link.search(/:\\/\\/nextgis/) !== -1) {\n        img.alt = 'Get your own Web GIS at nextgis.com';\n      }\n    }\n    anchor.appendChild(img);\n    return anchor;\n  }\n}\n","import type {\n  GeometryPaint,\n  GetPaintCallback,\n  IconPaint,\n  Paint,\n  PropertiesPaint,\n  VectorAdapterLayerPaint,\n} from './interfaces';\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { type Expression, evaluate, isExpression } from '@nextgis/expression';\n\nimport type { GetPaintCallback, VectorAdapterLayerPaint } from './interfaces';\nimport type { Feature } from 'geojson';\n\ntype PropertyExpressionCb = (feature: Feature) => ReturnType<typeof evaluate>;\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    const properties = feature.properties;\n    if (properties) {\n      return evaluate(expression, properties);\n    }\n    return false;\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: Record<string, any>,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type {\n  GeometryPaint,\n  GetCustomPaintOptions,\n  GetPaintCallback,\n  GetPaintFunction,\n  Paint,\n  PropertiesPaint,\n  PropertyPaint,\n  VectorAdapterLayerPaint,\n} from './interfaces';\nimport type { Feature } from 'geojson';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  for (const p of propertiesPaint) {\n    if (p) {\n      if (Array.isArray(p)) {\n        paintsFilters.push(p);\n      } else {\n        mask = p as VectorAdapterLayerPaint;\n      }\n    }\n  }\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nfunction expressionCallback({\n  paint,\n  defaultPaint,\n}: PreparePaintOptions): Paint | VectorAdapterLayerPaint {\n  const expressionCallback = createExpressionCallback(paint);\n  if (expressionCallback) {\n    const expressionPaintCb = (feature: Feature) => {\n      return preparePaint({\n        paint: expressionCallback(feature),\n        defaultPaint,\n      }) as VectorAdapterLayerPaint;\n    };\n    expressionPaintCb.paint = finalizePaint({ paint, defaultPaint });\n    return expressionPaintCb as VectorAdapterLayerPaint;\n  }\n  return finalizePaint({ paint, defaultPaint });\n}\n\nfunction finalizePaint({ paint, defaultPaint }: PreparePaintOptions): Paint {\n  let newPaint: Paint = { ...defaultPaint };\n  newPaint = { ...newPaint, ...paint } as GeometryPaint;\n  newPaint.fill = newPaint.fill ?? true;\n  newPaint.stroke =\n    newPaint.stroke !== undefined\n      ? newPaint.stroke\n      : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  return newPaint;\n}\n\nexport interface PreparePaintOptions {\n  paint: Paint;\n  defaultPaint?: GeometryPaint;\n  getPaintFunctions?: { [name: string]: GetPaintFunction };\n}\n\nexport function preparePaint({\n  paint,\n  defaultPaint,\n  getPaintFunctions,\n}: PreparePaintOptions): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint({\n        paint: paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      }) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint({\n        paint: createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      }) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint({\n        paint: getPaint,\n        defaultPaint,\n        getPaintFunctions,\n      });\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    newPaint = expressionCallback({ paint, defaultPaint });\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import type {\n  Operation,\n  Properties,\n  PropertiesFilter,\n  PropertyFilter,\n} from './interfaces';\nimport type { Feature } from 'geojson';\n\nfunction reEscape(s: string): string {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operation]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function isPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/** @deprecated use {@link isPropertyFilter} instead */\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  return isPropertyFilter(filter);\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter,\n): boolean {\n  const properties: Properties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter<T extends Properties = Properties>(\n  properties: T,\n  filters: PropertiesFilter<T>,\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (isPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n"],"names":["svgPath","brill","circle","rect","marker","cross","star","triangle","plus","minus","asterisk","VIEW_BOX","STROKE","getIcon","_opt$shape","_opt$color","_opt$strokeColor","_opt$size","_opt$rotate","_opt$anchor","opt","arguments","length","undefined","shape","color","strokeColor","size","rotate","anchor","stroke","Number","pathAlias","p","path","svg","DOMParser","parseFromString","documentElement","insertSvg","_ref","width","height","content","s","concat","generateSvg","setAttribute","String","type","iconSize","iconAnchor","html","XMLSerializer","serializeToString","AttributionControl","Control","Attribution","constructor","options","super","customAttribution","attributions","Array","isArray","forEach","x","this","addAttribution","createControl","control","map","extend","onAdd","element","document","createElement","classList","add","bar","addClass","margin","style","marginBottom","marginTop","marginLeft","marginRight","appendChild","DomEvent","disableClickPropagation","onRemove","boundsToArray","bounds","ne","getNorthEast","sw","getSouthWest","lng","lat","findMostFrequentGeomType","arr","counts","fry","maxName","c","maxCount","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","PAINT","opacity","backAliases","a","layerType","backAlias","push","geometryFilter","geometry","indexOf","featuresBounds","features","geoJsonLayer","GeoJSON","f","addData","getBounds","createFeaturePositionOptions","getFeaturesBounds","getCenter","getFeaturesCenter","BaseAdapter","_defineProperty","order","pane","exist","getPane","createPane","zIndex","Math","round","addLayer","Object","assign","convertMapClickEvent","evt","coord","containerPoint","latLng","latlng","lngLat","pixel","left","top","y","source","GeoJsonEvents","layer","handleMouseEvents","onClick","onLayerClick","onMouseOut","onMouseOver","onClick_","_onclick","e","selected","_getSelected","_createMouseEvent","on","_mouseout","_mouseover","stopMouseEvents","off","feature","target","event","createMouseEvent","GeoJsonPaint","setPaintEachLayer","paint","_layers","layerDef","setPaint","isPaintCallback","isPaint","divIcon","_createDivIcon","setTimeout","setIcon","setStyle","preparePaint","paintAliases","aliases","readyPaint","radius","to","from","paintProp","defined","toLowerCase","defineProperty","enumerable","value","icon","className","toLIconOpt","transform","innerHTML","DivIcon","createPaintToLayer","iconClassName","_","Marker","CircleMarker","createPaintOptions","geoJsonOptions","newPaint","pointToLayer","callAjax","src","callback","headers","xhr","XMLHttpRequest","open","responseType","h","setRequestHeader","onload","arrayBufferView","Uint8Array","response","blob","Blob","imageUrl","window","URL","webkitURL","createObjectURL","send","abort","ImageOverlay","LImageOverlay","cancelLoad","_abort","_initImage","img","_image","ImageLayer","Layer","url","service","request","version","layers","styles","format","transparent","crs","uppercase","attribution","isBack","minZoom","viewPortBuffer","setViewDelay","_url","params","opts","Util","setOptions","wmsParams","defaultWmsParams","setParams","update","getAttribution","_currentOverlay","removeLayer","_currentUrl","getEvents","moveend","debounce","_map","updateWmsParams","getImageUrl","pad","overlay","addTo","once","setOpacity","bringToBack","bringToFront","setZIndex","maxZoom","getZoom","getSize","factor","ceil","wmsVersion","parseFloat","projectionKey","nw","project","getNorthWest","se","getSouthEast","code","bbox","CRS","EPSG4326","join","pstr","getParamString","makeRemote","Base","_this","_update","_len","_key","GridLayer","prototype","call","createTile","coords","done","getTileUrl","tile","crossOrigin","alt","_abortLoading","tiles","_tiles","tileZoom","_tileZoom","i","z","el","falseFn","onerror","complete","emptyImageUrl","DomUtil","remove","TileLayerBase","TL","urlTemplate","TileLayer","TileAdapter","tileLayerOptions","nativeOptions","subdomains","WmsLayerBase","WMS","WmsLayer","arrayToBoundsExpression","LeafletMapAdapter","layerAdapters","controlAdapters","EventEmitter","create","zoom","center","maxBounds","mb","mapAdapterOptions","Map","attributionControl","zoomControl","defPane","_addUnselectCb","def","emitter","emit","_addMapListeners","destroy","_stopWatchSizeChangeToUpdateMinZoom","getContainer","getControlContainer","controlContainer","_controlContainer","Error","setCursor","cursor","setView","lngLatOrOpt","animate","setCenter","setZoom","fitBounds","b","setMaxBounds","setMinZoom","getBoundsZoom","_watchSizeChangeToUpdateMinZoom","setMaxZoom","panTo","offset","padding","getLayerAdapter","name","createButtonControl","link","title","href","stop","HTMLElement","stopPropagation","addEventListener","parent","parentNode","removeChild","removeEventListener","addControl","position","replace","removeControl","showLayer","hideLayer","setLayerOpacity","setLayerOrder","onMapClick","converted","locate","events","locationfound","locationerror","locationFound","cb","_unselectCb","container","ResizeObserver","_resizeObserver","observe","disconnect","_universalEvents","_positionEvents","GEOJSON","updateTooltip","unselect","_events","_paint","FeatureGroup","selectedPaint","data","_addMapListener","beforeRemove","_removeMapListener","select","findFeatureFun","filter","_selectLayer","_unSelectLayer","_openedPopup","_removePopup","_selectedLayers","getSelected","getFiltered","_filteredLayers","fun","_filterFun","layer_","filteredLayers","cleanFilter","getLayers","_ref2","visible","clearLayer","splice","clearLayers","setData","detectedType","geojson","geometries","g","detectType","console","warn","_data","filterGeometries","_getGeoJsonOptions","openPopup","_openPopup","closePopup","_updateTooltip","getExtent","isValid","setSelectedPaint","l","updatePaint","updateSelectedPaint","find","label","labelField","labelOnHover","message","unbindTooltip","properties","permanent","bindTooltip","sticky","minWidth","autoPan","maxWidth","closeButton","closeButton_","selectOnHover","popup","_closeHandlers","close","createPopupContent","onClose","handler","popupContent","_this$options$popupOp","_this$options$popupOp2","popupOptions","closeOnClick","autoClose","bindPopup","unselectOnClose","getPopup","unbindPopup","index","findIndex","_this$options$popupOp3","_this$options$popupOp4","closeHandlers","lopt","iconOpt","onEachFeature","_onEachFeature","ok","selectable","interactive","_selectOnLayerClick","isSelected","unselectOnSecondClick","multiselect","popupOnSelect","onSelect","_addMapClickListener","unselectOnClick","$unselect","_removeMapClickListener","$updateTooltip","IMAGE","updateWmsParamsFromOpt","TILE","layerOptions","OSM","ZOOM","Zoom","ATTRIBUTION","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","item","geom","id","fields","updateItemRequestParam","extensions","ilike","like","extensionsStr","createFeatureFieldFilterQueries","queries","getQueries","CancelablePromise","all","then","itemsParts","ids","items","part","includes","limit","createParam","pf","field","operation","isFldStr","vStart","vEnd","field_","trim","m","v","_queries","_parentAllParams","filters","logic","filters_","isPropertyFilter","fetchNgwLayerItemsRequest","paramList","propertiesFilterList","cache","signal","orderBy","connector","geomFormat","intersects","resourceId","POSITIVE_INFINITY","order_by","coordinates","isLngLatBoundsArray","getBoundsCoordinates","polygon","degrees2meters","createWktFromCoordArray","reqParams","get","fetchNgwLayerItems","_options$clientFilter","clientFilterValidate","isFilterWithAnyCase","prepareNgwFieldsToPropertiesFilter","propertiesFilter","isObject","date","year","month","day","dt","hour","minute","second","Date","toISOString","split","fetchNgwLayerItem","queryParams","fid","featureId","resp","toGeojson","resolve","onlyGeomItem","BookmarkItem","extent","_extent","minLat","minLon","maxLat","maxLon","lonLat","geoJson","treeSome","relation","itemPrepare","treeWrapper","treeFind_","treeFilter","treeFilter_","getChildren","children","relChild","filterFunction","filterFunc","_filtered","relChildren","result","treeEvery_","TreeHelper","setParent","_parent","addChild","child","_children","getParent","getParents","tree","getRoot","toReturn","every","some","getDescendants","BaseProperty","_value","getProperty","isGroup","isBlocked","_blocked","parents","_calculateBlockedStatus","set","_prepareValue","_fireChangeEvent","getValue","_callOnSet","_container","_removeEventsListener","onSet","prop","property","_parent$properties","parentProp","CheckProperty","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","getHierarchyValue","block","_block","_unBlock","blockChild","_blockChild","unblockChild","_unBlockChild","turnOff","hierarchy","turnOn","ItemProperties","propertiesList","_setPropertyHandler","bind","propOpt","list","_properties","_propertiesList","Handler","_getHandler","handlers","ID","Item","initProperties","NgwWebmapItem","webMap","noInit","item_type","_rootDescendantsCount","_sumUp","root","_init","static","ngwWebmapItem","initItem","initGroupItem","initLayerItem","fit","getLayer","async","_this$layer","layerId","legend","display_name","symbol","getItemOptions","transparency","layer_transparency","visibility","resource","subOrder","drawOrderEnabled","draw_order_position","subLevel","padStart","_getZoomRange","ratio","minScale","layer_min_scale_denom","maxScale","layer_max_scale_denom","layer_identifiable","reverse","_mapScaleToZoomLevel","scale","centerLat","crsScale","_pixelsInMeter","div","cssText","body","px","offsetWidth","pixelsInMeterWidth","PI","cos","getMapWidthForLanInMeters","log","LN2","getZoomFromScale","setScaleRatio","group","childItem","Promise","setNewLayer","_layer","adapter","layer_adapter","toUpperCase","GetAdapterFromLayerType","getAdapter","newLayer","reject","minZoomWebmap","maxZoomWebmap","minZoomLayer","maxZoomLayer","minZooms","Boolean","maxZooms","max","min","totalValue","layer_enabled","val","reduce","getNgwWebmapExtent","webmap","bottom","right","fetchNgwLayerExtent","fetchNgwExtent","getResource","fetchNgwResourceExtent","cls","res","NgwResource","resourceIdFromLayerOptions","keyname","resourceItem","alias","tms","updateQmsOptions","qms","protocol","location","serviceUrl","y_origin_top","copyright_text","z_max","z_min","createQmsAdapter","webMapOrOptions","createOpt","webMap_","url_","adapterOptions","QmsAdapter","baselayer","qmsId","xmlHttp","onreadystatechange","readyState","status","responseText","JSON","parse","er","fixUrlStr","loadJson","error","WebMapAdapter","mapAdapter","mixinProperties","origin_url","originUrl","submodules","getSubdomainsOriginUrl","QmsKit","getLayerAdapters","createAdapter","_createAdapter","fetchNgwLayerFeatureCollection","fetchNgwLayerFeatures","filterOptionsKeys","getLayerFilterOptions","filterOptions","createGeoJsonAdapter","props","_options$adapterOptio","Adapter","addLayerOptionsPriority","alop","GeoJsonAdapter","_loadedIds","_lastFilterArgs","_dataPromise","_fullDataLoad","fromProperties","feature_layer","grid_visibility","propElem","getData","filterOpt","removed","cancel","needUpdate","waitFullLoad","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","keys","strategy","updatePromise","updateLayer","startsWith","_addBboxEventListener","hasData","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","__onMapMoveStart","getCount","total_count","fetchNgwLayerCount","filterArgs","_this$options$strateg","onLoad","_emitLayerEvent","newData","count","addLayerData","setLayerData","isFull","props_","removeFilter","_addMoveEventListener","removeListener","ngwApiToAdapterOptions","baseUrl","isImageAllowed","nd","tileNoData","params_","updateImageParams","getImageAdapterOptions","_options$simplificati","simplification","sourceLayer","featureIdName","createRasterAdapter","resourceCls","wmsserver_service","tmsclient_layer","AdapterClass","_options","layerAdapterOptions","addOptions","ngwLegend","classAdapters","supportCls","createAdapterFromFirstStyle","childrenStyles","getResourceChildren","firstStyle","createAsyncAdapter","adapterType","itemFromResOpt","NWLayerAdapter","createWebMapAdapter","adapterOptions_","basemap_layer","qms_","utils","BasemapTileAdapter","createBasemapLayerAdapter","parentItem","parentOptions","getClassAdapter","classAdapter","resourceAdapter","applyMixins","createOnFirstShowNgwAdapter","idPrefix","OnFirstNgwShowAdapter","onLayerAdded","_removed","destroyed","loadLayer","_creatingInProgress","realLayer","createOnFirstShowAdapter","resource_id","NgwWebmapLayerAdapter","r","_this$response","_getWebMapLayerItem","extentConstrained","extent_constrained","useExtentConstrained","getDependLayers","_webmapBaselayersIds","_lastActiveBaselayer","_webmapLayersIds","getBookmarksResourceId","bookmark_resource","fetchBookmarks","bookmarkResId","getResourceOrFail","_item$feature_layer","label_field","bookmarks","bookmark","legends","deps","sort","d","layerLegend","getLegend","visibleLayers","_getWebMapIds","parentId","getWebMapConfig","root_item","auth","getAuthorizationHeaders","draw_order_enabled","webmapClassName","_setupBaselayers","extent_left","extent_bottom","extent_right","extent_top","_updateItemsParams","_this$options$useBase","useBasemap","basemap_webmap","basemaps","activeBaselayer","getActiveBaseLayer","_setBasemaps","defaultBasemap","addBaseLayer","baseWebmap","enabledAlreadySet","enabled","layer_style_id","webMapItem","promises","promise","timestamp","now","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","fetchNgwLayerFeature","IdentifyItem","identify","_item","_resource","fetchNgwLayerItemExtent","_geojson","getIdentifyItems","multiple","resources","paramsList","isNaN","sortingArr","identifyItem","featureParams","createParamsFromFeatures","appendNgwResources","defOptions","overwriteOptions","NgwError","setPrototypeOf","ResourceNotFoundError","obj","toString","exclude","resourceToQuery","prefix","query","key","entries","parent_id","ResourcesControl","Cache","getOne","requestOptions","forCache","addFull","makeRequest","_fetchResourceBy","_fetchResourceById","getOneOrFail","getId","getIdOrFail","getMany","_resourceCacheFilter","serialization","getChildrenOf","_getChildrenOf","put","delete","_cleanResourceItemCache","_items","recursivePromises","recursive","toDelete","cid","catch","matchAll","res1","res2","objectDeepEqual","CONNECTORS","addConnector","InsufficientPermissionsError","templateRe","template","str","NetworkError","origin","loadData","onCancel","method","getResponseText","processingResponse","upload","onprogress","lengthComputable","percentComplete","loaded","total","onProgress","header","withCredentials","file","FormData","append","stringify","NgwConnector","findConnector","route","routeStr","requestTransform","setRequestTransform","setNgw","logout","connect","makeConnect","makeQuery","login","password","_login","credentials","removeConnector","user","clean","getUserInfo","options_","client","makeClientId","Authorization","unescape","encodeURIComponent","btoa","req","activeRequests","getActiveApiRequests","apiRequest","_requestOptions$param","objectRemoveEmpty","makeApiRequest","apiItems","apiItem","shift","replaceParams","arg","paramArray","_this$user","userId","post","patch","encodeURI","_loadData","getResourceBy","getResourceByKeyname","getResourceById","getResourceId","getResourceIdOrFail","getResourcesBy","getResourceParent","updateResource","deleteResource","transUrl","transOptions","_cleanActiveRequests","httpError","_handleHttpError","activeRequestIndex","exception","NgwKit","resourceIds","pixelRadius","_getLayerAdapter","OPTIONS","whitlabel","controls","getDefaultControls","controlsOptions","NgwMap","WebMap","kits","starterKits","deepmerge","prepareWebMapOptions","_createWebMap","_whiteLabel","controlDef","onMapLoad","deprecatedWarn","createNgwLayerAdapter","adapterOpts","getLayerId","_ngwLayers","resId","fetchIdentifyItem","_addPromise","fetchIdentifyGeoJson","withGeom","getIdentifyGeoJson","n","mem","getIdentificationIds","dependFit","ngwLayer","fitLayer","enableSelection","$$selectFromNgwRaster","ev","_getSelectListenersCount","selectFromNgwRaster","$$selectFromNgwVector","_selectFromNgwVector","disableSelection","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","cancelPromise","cancelPromises","args","_promises","_emitStatusEvent","values","_layer$options$intera","identFunc","isLayerVisible","getIdsPromise","getIds","getIdentifyRadius","selectPromise","deprecatedMapClick","geom_","getCirclePolygonCoordinates","wkt","_geom$geometry","getPolygonCoordinates","polygonStr","convertGeomToWKT","featureLayerIdentify","sendIdentifyRequest","sourceType","identifyEvent","_prepareToIdentify","groupName","removeFromGroup","_isFitFromResource","_initMapState","_addQmsBaseLayer","osm","_addOsmBaseLayer","layerFitAllowed","webmapId","addNgwLayer","qmsLayerName","qmsLayerOptions","featureCount","getIdentifyItems_","listenerCount","logo","settings","component","company_logo","_options$padding","cssClass","Image","maxHeight","search","getCompanyLogo","companyLogoOptions","createPropertyExpressionCb","expression","evaluate","excludeExpressionList","createPropertiesPaint","propertiesPaint","mask","paintsFilters","featureFilter","finalizePaint","_newPaint$fill","defaultPaint","fill","strokeOpacity","_ref3","getPaintFunctions","getPaintFunction","getPaint","isPropertiesPaint","updatePaintOptionFromCallback","expressionCallback","withExpression","expressions","p_","isExpression","fromCb","createExpressionCallback","expressionPaintCb","fillColor","fillOpacity","iLike","re","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","in","notin","$id","operationExec","value_","match","cleanField"],"sourceRoot":""}