{"version":3,"file":"main-4aa8b69d29735b2.js","mappings":"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","sources":["webpack://clear_horizon/./@nextgis/packages/icons/src/index.ts","webpack://clear_horizon/./@nextgis/packages/item/src/TreeHelper.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/BaseProperty.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/CheckProperty.ts","webpack://clear_horizon/./@nextgis/packages/item/src/properties/ItemProperties.ts","webpack://clear_horizon/./@nextgis/packages/item/src/Item.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/convertMapClickEvent.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/createControl.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/Attribution.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/boundsToArray.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/geometries.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/detectType.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/createMouseEvent.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/callAjax.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageOverlay.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/ImageAdapter/ImageAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/makeRemoteTileLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/TileAdapter/TileLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/TileAdapter/TileAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/WmsAdapter/WmsLayer.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/WmsAdapter/WmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/utils/arrayToBoundsExpression.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/LeafletMapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/controls/createButtonControl.ts","webpack://clear_horizon/./@nextgis/packages/leaflet-map-adapter/src/index.ts"],"sourcesContent":["/**\n * @module icons\n */\n\nimport { IconPaint } from '@nextgis/paint';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star: '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>',\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'rect'\n    | 'star'\n    | 'plus'\n    | 'minus'\n    | 'brill'\n    | 'circle'\n    | 'marker'\n    | 'triangle'\n    | 'asterisk';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string,\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): IconPaint {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg,\n  };\n}\n","import { treeFind, treeFilter, treeEvery, treeSome } from '@nextgis/tree';\nimport { Item } from './Item';\nimport { ItemOptions } from './interfaces';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  setParent(parent: Item): void {\n    this._parent = parent;\n  }\n\n  addChild(child: Item): void {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return treeFilter<I>(\n        parent,\n        filterFunc,\n        (x: I) => x.tree.getParent() as I,\n      );\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n\n  find(filterFunc?: (item: Item) => boolean): Item<ItemOptions> | undefined {\n    return treeFind(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  every<I extends Item = Item>(filterFunc?: (item: I) => boolean): boolean {\n    return treeEvery(this._children as I[], filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  some<I extends Item = Item>(filterFunc?: (item: I) => boolean): boolean {\n    return treeSome(this._children as I[], filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return treeFilter(this._children, filterFunc, (x) => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return [...this._children] as T[];\n  }\n}\n","import { EventEmitter } from 'events';\nimport type { Item } from '../Item';\nimport type { ItemBasePropertyOptions, ItemOptions } from '../interfaces';\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>,\n  I extends Item = Item,\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = new EventEmitter();\n  name: string;\n\n  item: I;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: I, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty(): V | undefined {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent(): Item<ItemOptions> | undefined {\n    return this.item.tree.getParent();\n  }\n\n  getChildren(): Item<ItemOptions>[] {\n    return this.item.tree.getChildren();\n  }\n\n  isGroup(): number {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked(): boolean {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O): void {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O): void {\n    this._callOnSet(value, options);\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this._container;\n  }\n\n  destroy(): void {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O): void {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O): void {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach((x) => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', {\n            value,\n            options,\n            item: this.item,\n          });\n        }\n      });\n    }\n  }\n}\n","import { BaseProperty } from './BaseProperty';\n\nimport type { Item } from '../Item';\nimport type { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\ntype PreparedValue = any;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>,\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle',\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O): void {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false }),\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue(): boolean | undefined {\n    return (\n      this.get() &&\n      this.getParents().every((x) => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  block(options?: O): void {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  unBlock(options?: O): void {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  blockChild(options?: O): void {\n    this.item.tree\n      .getDescendants()\n      .forEach((x) => this._blockChild(x, options));\n  }\n\n  unblockChild(options?: O): void {\n    this.item.tree.getChildren().forEach((x) => this._unBlockChild(x, options));\n  }\n\n  protected _prepareValue(value?: PreparedValue): V | undefined {\n    return value;\n  }\n\n  private _turnOff(options?: O): void {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChild(options);\n    }\n  }\n\n  private _turnOn(options?: O): void {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChild(options);\n    }\n  }\n\n  private _block(options?: O): void {\n    this._turnOff(options);\n  }\n\n  private _unBlock(options?: O): void {\n    this._turnOn(options);\n  }\n\n  private _blockChild(item: Item, options?: O): void {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  private _unBlockChild(item: Item, options?: O): void {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  private _propagation(value?: V, options?: O): void {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false,\n            },\n          });\n        }\n      }\n    }\n  }\n}\n","import { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes,\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty,\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[],\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>): void {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(\n    propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>,\n  ): void {\n    const handlers = ItemProperties.handlers;\n    let Handler = propOpt.handler;\n    if (!Handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          Handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          Handler = handlers.BaseProperty;\n          break;\n        default:\n          Handler = handlers.BaseProperty;\n      }\n    }\n    if (Handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new Handler(\n        propOpt.name,\n        this.item,\n        options,\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update(): void {\n    this.list().forEach((x) => {\n      x.update();\n    });\n  }\n\n  get(name: string): any {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>,\n  ): void {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string): BaseProperty<any, ItemBasePropertyOptions<any>> {\n    return this._properties[name];\n  }\n\n  list(): BaseProperty<any, ItemBasePropertyOptions<any>>[] {\n    return this._propertiesList.map((x) => this._properties[x]);\n  }\n\n  destroy(): void {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","import { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties(): void {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","import type { LeafletMouseEvent } from 'leaflet';\n\nimport type { MapClickEvent } from '@nextgis/webmap';\n\nexport function convertMapClickEvent(evt: LeafletMouseEvent): MapClickEvent {\n  const coord = evt.containerPoint;\n  const latLng = evt.latlng;\n  const { lat, lng } = latLng;\n  return {\n    latLng,\n    lngLat: [lng, lat],\n    pixel: { left: coord.x, top: coord.y },\n    source: evt,\n  };\n}\n","import { Control, DomEvent } from 'leaflet';\nimport type {\n  MapControl,\n  CreateControlOptions,\n  MapAdapter,\n} from '@nextgis/webmap';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {},\n  map: MapAdapter,\n): Control {\n  const C = Control.extend({\n    onAdd() {\n      const element = document.createElement('div');\n      const content = control.onAdd(map);\n      element.classList.add('leaflet-control');\n      if (options.bar) {\n        element.classList.add('leaflet-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      if (!options.margin && !options.bar) {\n        element.style.marginBottom = '0px';\n        element.style.marginTop = '0px';\n        element.style.marginLeft = '0px';\n        element.style.marginRight = '0px';\n      }\n      if (content) {\n        element.appendChild(content);\n      }\n\n      DomEvent.disableClickPropagation(element);\n\n      return element;\n    },\n    onRemove() {\n      control.onRemove();\n    },\n  });\n  return new C();\n}\n","import { Control, ControlOptions } from 'leaflet';\nimport { AttributionControlOptions } from '@nextgis/webmap';\n\nexport class AttributionControl extends Control.Attribution {\n  // options: AttributionControlOptions\n  constructor(options: AttributionControlOptions & ControlOptions) {\n    super(options);\n    const customAttribution = options && options.customAttribution;\n    if (customAttribution) {\n      let attributions: string[] = [];\n      if (Array.isArray(customAttribution)) {\n        attributions = customAttribution;\n      } else if (customAttribution) {\n        attributions = [customAttribution];\n      }\n      attributions.forEach((x) => this.addAttribution(x));\n    }\n  }\n}\n","import type { LatLngBounds } from 'leaflet';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\nexport function boundsToArray(bounds: LatLngBounds): LngLatBoundsArray {\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  return [sw.lng, sw.lat, ne.lng, ne.lat];\n}\n","import { GeoJSON } from 'leaflet';\nimport { boundsToArray } from './boundsToArray';\n\nimport type {\n  Feature,\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeoJsonGeometryTypes,\n} from 'geojson';\nimport type { LatLngBounds } from 'leaflet';\nimport type { FeaturePosition, VectorAdapterLayerType } from '@nextgis/webmap';\nimport type { LngLatArray, LngLatBoundsArray } from '@nextgis/utils';\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'point',\n  LineString: 'line',\n  MultiPoint: 'point',\n  Polygon: 'polygon',\n  MultiLineString: 'line',\n  MultiPolygon: 'polygon',\n  GeometryCollection: 'polygon',\n};\n\nexport const PAINT = {\n  stroke: false,\n  opacity: 1,\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType,\n): boolean {\n  const geoJsonGeometry = backAliases[type] || [];\n  return geoJsonGeometry.indexOf(geometry) !== -1;\n}\n\nexport function filterGeometries(\n  data: GeoJsonObject,\n  type: VectorAdapterLayerType,\n): GeoJsonObject | false {\n  if (data.type === 'FeatureCollection') {\n    const _data = data as FeatureCollection;\n    _data.features = _data.features.filter((f) =>\n      geometryFilter(f.geometry.type, type),\n    );\n  } else if (data.type === 'Feature') {\n    const allow = geometryFilter((data as Feature).geometry.type, type);\n    if (!allow) {\n      return false;\n    }\n  } else if (data.type === 'GeometryCollection') {\n    const _data = data as GeometryCollection;\n    _data.geometries = _data.geometries.filter((g) =>\n      geometryFilter(g.type, type),\n    );\n  }\n  return data;\n}\n\nfunction featuresBounds(features: Feature | Feature[]): LatLngBounds {\n  const geoJsonLayer = new GeoJSON();\n  const features_ = Array.isArray(features) ? features : [features];\n  features_.forEach((f) => geoJsonLayer.addData(f));\n  return geoJsonLayer.getBounds();\n}\n\nexport function getFeaturesBounds(\n  features: Feature | Feature[],\n): LngLatBoundsArray {\n  return boundsToArray(featuresBounds(features));\n}\n\nexport function getFeaturesCenter(features: Feature | Feature[]): LngLatArray {\n  const { lat, lng } = featuresBounds(features).getCenter();\n  return [lng, lat];\n}\n\nexport function createFeaturePositionOptions(\n  features: Feature | Feature[],\n): FeaturePosition {\n  return {\n    getBounds: () => getFeaturesBounds(features),\n    getCenter: () => getFeaturesCenter(features),\n  };\n}\n","import type {\n  GeoJsonObject,\n  GeoJsonGeometryTypes,\n  FeatureCollection,\n  Feature,\n  GeometryCollection,\n} from 'geojson';\n\nfunction findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[],\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      (f) => f.geometry.type,\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      (g) => g.type,\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n","import type { MainLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport type { Map } from 'leaflet';\n\nexport class BaseAdapter<O extends AdapterOptions = AdapterOptions, L = any>\n  implements MainLayerAdapter<Map, L, O>\n{\n  layer?: L;\n  protected pane = 'order-0';\n\n  constructor(public map: Map, public options: O) {\n    if (options.order !== undefined) {\n      const pane = 'order-' + options.order;\n      let exist = map.getPane(pane);\n      if (!exist) {\n        exist = map.createPane(pane);\n      }\n      exist.style.zIndex = String(Math.round(options.order * 100));\n      this.pane = pane;\n    }\n  }\n\n  addLayer(options: O): L | Promise<L> | undefined {\n    Object.assign(this.options, options);\n    return undefined;\n  }\n}\n","import {\n  CircleMarker,\n  FeatureGroup,\n  DomEvent,\n  GeoJSON,\n  DivIcon,\n  Marker,\n  Layer,\n} from 'leaflet';\nimport { debounce, defined } from '@nextgis/utils';\n\nimport { isPaintCallback, isPaint } from '@nextgis/paint';\nimport {\n  PAINT,\n  typeAlias,\n  filterGeometries,\n  createFeaturePositionOptions,\n} from '../utils/geometries';\nimport { createMouseEvent } from '../utils/createMouseEvent';\nimport { boundsToArray } from '../utils/boundsToArray';\nimport { detectType } from '../utils/detectType';\nimport { BaseAdapter } from './BaseAdapter';\n\nimport type { GeoJsonObject, Feature, Point } from 'geojson';\nimport type {\n  PopupOptions as LPopupOptions,\n  CircleMarkerOptions,\n  LeafletMouseEvent,\n  LatLngExpression,\n  GeoJSONOptions,\n  LeafletEvent,\n  PathOptions,\n  LatLng,\n  Path,\n  Map,\n} from 'leaflet';\nimport type {\n  Paint,\n  IconPaint,\n  PathPaint,\n  VectorAdapterLayerPaint,\n} from '@nextgis/paint';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\nimport type {\n  VectorAdapterLayerType,\n  GeoJsonAdapterOptions,\n  PopupOnCloseFunction,\n  OnLayerMouseOptions,\n  VectorLayerAdapter,\n  OnLayerSelectType,\n  LayerDefinition,\n  DataLayerFilter,\n  PopupOptions,\n} from '@nextgis/webmap';\n\nexport type LayerDef = LayerDefinition<Feature, Layer>;\n\nexport class GeoJsonAdapter\n  extends BaseAdapter<GeoJsonAdapterOptions>\n  implements VectorLayerAdapter<Map>\n{\n  layer?: FeatureGroup;\n  selected = false;\n\n  private paint?: Paint;\n  private selectedPaint?: Paint;\n  private type?: VectorAdapterLayerType;\n\n  private _layers: LayerDef[] = [];\n  private _selectedLayers: LayerDef[] = [];\n  private _filteredLayers: LayerDef[] = [];\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _openedPopup: [Layer, PopupOnCloseFunction[], LayerDef][] = [];\n\n  private $updateTooltip = debounce(() => {\n    this.updateTooltip();\n  }, 300);\n\n  constructor(map: Map, options: GeoJsonAdapterOptions) {\n    super(map, options);\n  }\n\n  addLayer(options: GeoJsonAdapterOptions): FeatureGroup<any> | undefined {\n    Object.assign(this.options, options);\n    this.paint = options.paint;\n    this.layer = new FeatureGroup([], {\n      ...options.nativeOptions,\n      pane: this.pane,\n    });\n    this.selectedPaint = options.selectedPaint;\n    options.paint = this.paint;\n\n    if (options.data) {\n      this.addData(options.data);\n    }\n\n    this._addMapListener();\n\n    return this.layer;\n  }\n\n  beforeRemove(): void {\n    this._removeMapListener();\n  }\n\n  select(findFeatureFun?: DataLayerFilter): void {\n    this.unselect();\n    if (findFeatureFun) {\n      const def = this._layers.filter(findFeatureFun);\n      for (const x of def) {\n        this._selectLayer(x, 'api');\n      }\n    } else if (!this.selected) {\n      this.selected = true;\n      if (this.selectedPaint) {\n        this._setPaintEachLayer(this.selectedPaint);\n      }\n    }\n  }\n\n  unselect(findFeatureFun?: DataLayerFilter): void {\n    if (findFeatureFun) {\n      const feature = this._layers.filter(findFeatureFun);\n      feature.forEach((x) => {\n        this._unSelectLayer(x);\n      });\n    } else if (this.selected) {\n      for (const p of this._openedPopup) {\n        this._removePopup(p[0]);\n      }\n      if (this.paint) {\n        this._setPaintEachLayer(this.paint);\n      }\n      this._selectedLayers.length = 0;\n      this.selected = false;\n    }\n  }\n\n  getSelected(): LayerDefinition<Feature, LayerDef>[] {\n    return this._selectedLayers.map((x) => {\n      return {\n        target: this,\n        feature: x.feature,\n        layer: x,\n        ...createFeaturePositionOptions(x.feature),\n      };\n    });\n  }\n\n  getFiltered(): LayerDef[] {\n    return this._filteredLayers;\n  }\n\n  filter(fun?: DataLayerFilter): LayerDef[] {\n    // Some optimization\n    this._filterFun = fun;\n    const layer_ = this.layer;\n    const map = layer_ && (layer_ as any)._map;\n    if (layer_ && map) {\n      layer_.remove();\n\n      const filteredLayers: LayerDef[] = [];\n      this._layers.forEach(({ feature, layer }) => {\n        if (layer) {\n          const ok = fun\n            ? fun({\n                target: this,\n                feature,\n                layer,\n                ...createFeaturePositionOptions(feature),\n              })\n            : true;\n          if (ok) {\n            layer_.addLayer(layer);\n            filteredLayers.push({\n              target: this,\n              feature,\n              layer,\n              ...createFeaturePositionOptions(feature),\n            });\n          } else {\n            layer_.removeLayer(layer);\n          }\n        }\n      });\n      this._filteredLayers = filteredLayers;\n\n      layer_.addTo(map);\n    }\n    return this._filteredLayers;\n  }\n\n  cleanFilter(): void {\n    this.filter();\n  }\n\n  getLayers(): LayerDef[] {\n    return this._layers.map(({ layer, feature }) => {\n      const visible = layer && !!(layer as any)._map;\n      return {\n        feature,\n        layer,\n        visible,\n        target: this,\n        ...createFeaturePositionOptions(feature),\n      };\n    });\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean): void {\n    this.unselect();\n    const layer_ = this.layer;\n    if (layer_) {\n      if (cb) {\n        for (let fry = this._layers.length; fry--; ) {\n          const def = this._layers[fry];\n          if (def) {\n            const { feature, layer } = def;\n            if (feature && layer) {\n              const exist = cb(feature);\n              if (exist) {\n                layer_.removeLayer(layer);\n                this._layers.splice(fry, 1);\n              }\n            }\n          }\n        }\n      } else {\n        layer_.clearLayers();\n        this._layers = [];\n      }\n    }\n  }\n\n  setData(data: GeoJsonObject): void {\n    this.clearLayer();\n    this.addData(data);\n  }\n\n  addData(data: GeoJsonObject | false): void {\n    const options = this.options;\n    let geoJsonOptions: GeoJSONOptions | undefined;\n    if (options) {\n      if (data) {\n        let type: VectorAdapterLayerType;\n\n        if (!options.type) {\n          const detectedType = detectType(data);\n          type = typeAlias[detectedType];\n        } else {\n          type = options.type;\n        }\n        if (this.type && this.type !== type) {\n          console.warn('no other data type than layer can be added');\n          return;\n        }\n        this.type = type;\n\n        data = filterGeometries(data, type);\n        if (data) {\n          geoJsonOptions = this._getGeoJsonOptions(options, type);\n        }\n      }\n      new GeoJSON(data || undefined, geoJsonOptions);\n    }\n  }\n\n  openPopup(findFeatureFun: DataLayerFilter, options?: PopupOptions): void {\n    if (findFeatureFun) {\n      const def = this._layers.filter(findFeatureFun);\n      def.forEach((x) => {\n        this._openPopup(x, options, 'api');\n      });\n    }\n  }\n\n  closePopup(findFeatureFun?: DataLayerFilter): void {\n    const popupToClose = findFeatureFun\n      ? this._openedPopup.filter((x) => findFeatureFun(x[2]))\n      : this._openedPopup;\n\n    popupToClose.forEach((x) => {\n      this._removePopup(x[0]);\n    });\n  }\n\n  updateTooltip(layerDef?: LayerDefinition): void {\n    if (layerDef) {\n      this._updateTooltip(layerDef);\n    } else {\n      this.getLayers().forEach((x) =>\n        this._updateTooltip({ feature: x.feature, layer: x.layer }),\n      );\n    }\n  }\n\n  /** @deprecated use {@link GeoJsonAdapter.getBounds} instead */\n  getExtent(): LngLatBoundsArray | undefined {\n    return this.getBounds();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.layer) {\n      const bounds = this.layer.getBounds();\n      if (bounds.isValid()) {\n        return boundsToArray(bounds);\n      }\n    }\n  }\n\n  setOpacity(value: number): void {\n    this.options.opacity = value;\n    this.setPaint(this.paint);\n    this.setSelectedPaint(this.selectedPaint);\n  }\n\n  setPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.paint = paint;\n      for (const l of this._layers) {\n        this._setPaint(l, paint);\n      }\n    }\n  }\n  setSelectedPaint(paint?: Paint | null): void {\n    if (paint) {\n      this.selectedPaint = paint;\n      for (const l of this._selectedLayers) {\n        this._setPaint(l, paint);\n      }\n    }\n  }\n  updatePaint(paint: Partial<Paint>): void {\n    this.paint = { ...this.paint, ...paint } as Paint;\n    for (const l of this._layers) {\n      this._setPaint(l, this.paint);\n    }\n  }\n  updateSelectedPaint(paint: Partial<Paint>): void {\n    this.selectedPaint = { ...this.selectedPaint, ...paint } as Paint;\n    for (const l of this._selectedLayers) {\n      this._setPaint(l, this.selectedPaint);\n    }\n  }\n\n  private $unselect = () => {\n    this.unselect();\n  };\n\n  private _updateTooltip(layerDef: Pick<LayerDef, 'feature' | 'layer'>) {\n    const { feature, layer } = layerDef;\n    if (feature && layer && feature.properties && this.options.labelField) {\n      layer.unbindTooltip();\n      const message = feature.properties[this.options.labelField];\n      if (message !== undefined) {\n        const permanent = !this.options.labelOnHover;\n\n        layer.bindTooltip(String(message), { permanent, sticky: false });\n      }\n    }\n  }\n\n  private async _openPopup(\n    def: LayerDef,\n    options: PopupOptions = {},\n    type: OnLayerSelectType,\n    latLng?: LatLngExpression,\n  ) {\n    const { feature, layer } = def;\n    const {\n      minWidth,\n      autoPan,\n      maxWidth,\n      closeButton: closeButton_,\n    } = {\n      minWidth: 300,\n      ...options,\n    };\n    const closeButton = closeButton_ ?? !this.options.selectOnHover;\n    let popup: Layer;\n    const _closeHandlers: PopupOnCloseFunction[] = [];\n    const onClose = (handler: PopupOnCloseFunction) => {\n      _closeHandlers.push(handler);\n    };\n    const close = () => {\n      if (popup) {\n        this._removePopup(popup);\n      }\n    };\n    let content;\n    if (options.createPopupContent) {\n      content = await options.createPopupContent({\n        layer,\n        feature,\n        target: this,\n        type,\n        close,\n        onClose,\n        ...createFeaturePositionOptions(feature),\n      });\n    } else {\n      content = options.popupContent;\n    }\n\n    if (content && layer) {\n      const popupOptions: LPopupOptions = {\n        minWidth,\n        autoPan,\n        // maxWidth,\n        closeButton,\n        closeOnClick: false,\n        autoClose: false,\n      };\n      if (defined(maxWidth)) {\n        popupOptions.maxWidth = maxWidth;\n      }\n      popup = layer.bindPopup(content, popupOptions);\n\n      const unselectOnClose =\n        this.options.popupOptions?.unselectOnClose ?? true;\n      if (unselectOnClose) {\n        const p = layer.getPopup();\n        p &&\n          p.once(\n            'remove',\n            () => {\n              close();\n            },\n            this,\n          );\n      }\n      this._openedPopup.push([popup, _closeHandlers, def]);\n      popup.openPopup(latLng);\n    }\n  }\n\n  private _removePopup(popup: Layer) {\n    const map = this.map;\n    if (map) {\n      popup.closePopup().unbindPopup();\n      const index = this._openedPopup.findIndex((x) => x[0] === popup);\n      if (index !== -1) {\n        const unselectOnClose =\n          this.options.popupOptions?.unselectOnClose ?? true;\n        const [, closeHandlers, def] = this._openedPopup[index];\n        for (const h of closeHandlers) {\n          h(def);\n        }\n        closeHandlers.length = 0;\n        if (unselectOnClose) {\n          this._unSelectLayer(def);\n        }\n        this._openedPopup.splice(index, 1);\n      }\n    }\n  }\n\n  private _setPaintEachLayer(paint: Paint) {\n    this._layers.forEach((l) => {\n      this._setPaint(l, paint);\n    });\n  }\n\n  private _setPaint(def: LayerDef, paint: Paint) {\n    let style: VectorAdapterLayerPaint | undefined = undefined;\n    const { layer, feature } = def;\n    if (layer && feature) {\n      if (isPaintCallback(paint)) {\n        style = paint(feature);\n      } else if (isPaint(paint)) {\n        style = paint;\n      }\n      if (style) {\n        if (this.type === 'point' && style.type === 'icon') {\n          const marker = layer as Marker;\n          const divIcon = this._createDivIcon(style);\n          marker.setIcon(divIcon);\n        } else if ('setStyle' in layer) {\n          (layer as Path).setStyle(this._preparePaint(style));\n        }\n      }\n    }\n  }\n\n  private _preparePaint(paint: VectorAdapterLayerPaint): PathOptions {\n    if (paint.type !== 'get-paint') {\n      // const path: CircleMarkerOptions | PathOptions = paint as CircleMarkerOptions | PathOptions;\n      // if (path.opacity) {\n      //   path.fillOpacity = path.opacity;\n      // }\n\n      const paintAliases: [keyof PathOptions, keyof PathPaint][] = [\n        // ['color', 'color'],\n        ['color', 'strokeColor'],\n        ['opacity', 'strokeOpacity'],\n        ['stroke', 'stroke'],\n        ['fillColor', 'fillColor'],\n        ['fillOpacity', 'fillOpacity'],\n        ['fill', 'fill'],\n        ['weight', 'weight'],\n      ];\n      const aliases: [keyof PathOptions, keyof PathPaint][] =\n        this.type === 'line'\n          ? [\n              ['color', 'strokeColor'],\n              ['opacity', 'strokeOpacity'],\n              ['weight', 'weight'],\n            ]\n          : paintAliases;\n\n      const readyPaint: PathOptions & CircleMarkerOptions = {};\n\n      if ('radius' in paint && typeof paint.radius === 'number') {\n        readyPaint.radius = paint.radius;\n      }\n      for (const [to, from] of aliases) {\n        let paintProp = (paint as PathPaint)[from];\n        if (\n          defined(this.options.opacity) &&\n          from.toLowerCase().indexOf('opacity') !== -1\n        ) {\n          paintProp = Number(paintProp) * this.options.opacity;\n        }\n\n        if (paintProp !== undefined) {\n          Object.defineProperty(readyPaint, to, {\n            enumerable: true,\n            value: paintProp,\n          });\n        }\n      }\n\n      return readyPaint;\n    }\n    return PAINT;\n  }\n\n  private _getGeoJsonOptions(\n    options: GeoJsonAdapterOptions,\n    type: VectorAdapterLayerType,\n  ): GeoJSONOptions {\n    const paint = options.paint;\n    let lopt: GeoJSONOptions = {};\n\n    if (typeof paint === 'function') {\n      if (type === 'point') {\n        // TODO: fix types (@geoman-io/leaflet-geoman-free)\n        (lopt as any).pointToLayer = (\n          feature: Feature<Point, any>,\n          latLng: LatLng,\n        ) => {\n          const iconOpt = paint(feature);\n          const pointToLayer = this._createPaintToLayer(iconOpt as IconPaint);\n          return pointToLayer(feature, latLng);\n        };\n      } else {\n        lopt = {\n          style: (feature) => {\n            if (feature) {\n              return this._preparePaint({ ...PAINT, ...paint(feature) });\n            } else {\n              return this._preparePaint({ ...PAINT, type: 'path' });\n            }\n          },\n        };\n      }\n    } else {\n      lopt = this._createPaintOptions(paint as VectorAdapterLayerPaint, type);\n    }\n\n    lopt.onEachFeature = (feature: Feature, layer) => {\n      this._onEachFeature(feature, layer);\n    };\n\n    return lopt;\n  }\n\n  private _onEachFeature(feature: Feature, layer: Layer) {\n    const layer_ = this.layer;\n    if (layer_) {\n      const def = {\n        target: this,\n        feature,\n        layer,\n        ...createFeaturePositionOptions(feature),\n      };\n\n      // @ts-ignore\n      layer.options.pane = this.pane;\n      this._layers.push(def);\n      let ok = true;\n      if (this._filterFun) {\n        ok = this._filterFun(def);\n      }\n      if (ok) {\n        const { popup, popupOptions, selectable, interactive, selectOnHover } =\n          this.options;\n        // @ts-ignore\n        layer.options.interactive = defined(interactive) ? interactive : true;\n        layer_.addLayer(layer);\n        if (selectable) {\n          if (selectOnHover) {\n            layer.on('mouseover', () => {\n              this._selectLayer(def, 'hover');\n            });\n            layer.on('mouseout', () => {\n              this._unSelectLayer(def);\n            });\n          } else {\n            layer.on(\n              'click',\n              (e) => this._selectOnLayerClick(e as LeafletMouseEvent),\n              this,\n            );\n          }\n        }\n        this._handleMouseEvents(layer);\n        // The timeout is needed to display the popup immediately when adding a layer to the map.\n        // Without a timeout, the layer may not yet have a _map object\n        setTimeout(() => {\n          if (popup) {\n            this._openPopup(\n              {\n                target: this,\n                layer,\n                feature,\n                ...createFeaturePositionOptions(feature),\n              },\n              popupOptions,\n              'api',\n            );\n          }\n          this._updateTooltip({ layer, feature });\n        });\n      }\n    }\n  }\n\n  private _handleMouseEvents(layer: Layer) {\n    const { onClick, onLayerClick, onMouseOut, onMouseOver } = this.options;\n    // TODO: remove backward compatibility for onLayerClick\n    const onClick_ = onClick || onLayerClick;\n    if (onClick_) {\n      layer.on(\n        'click',\n        (e) => {\n          const selected = !!this._getSelected(layer);\n          onClick_({\n            selected,\n            ...this._createMouseEvent(e),\n          });\n        },\n        this,\n      );\n    }\n    if (onMouseOut) {\n      layer.on(\n        'mouseout',\n        (e) => {\n          onMouseOut(this._createMouseEvent(e));\n        },\n        this,\n      );\n    }\n    if (onMouseOver) {\n      layer.on(\n        'mouseover',\n        (e) => {\n          onMouseOver(this._createMouseEvent(e));\n        },\n        this,\n      );\n    }\n  }\n\n  private _createMouseEvent(source: LeafletEvent): OnLayerMouseOptions {\n    return createMouseEvent({\n      layer: this,\n      source: source as LeafletMouseEvent,\n    });\n  }\n\n  private _getSelected(layer: LayerDef['layer']) {\n    return this._selectedLayers.find((x) => x.layer === layer);\n  }\n\n  private _selectOnLayerClick(e: LeafletMouseEvent) {\n    DomEvent.stopPropagation(e);\n    const layer = e.target as Layer;\n    const feature = (layer as any).feature;\n    const def: LayerDef = {\n      target: this,\n      layer,\n      feature,\n      ...createFeaturePositionOptions(feature),\n    };\n    const isSelected = this._getSelected(layer);\n    if (isSelected) {\n      if (this.options && this.options.unselectOnSecondClick) {\n        this._unSelectLayer(isSelected);\n      }\n    } else {\n      this._selectLayer(def, 'click', e.latlng);\n    }\n  }\n\n  private _selectLayer(\n    def: LayerDef,\n    type: OnLayerSelectType,\n    latlng?: LatLngExpression,\n  ) {\n    const { multiselect } = this.options;\n    if (!multiselect) {\n      // To unselect layer on another layer click\n      (this.map as any)._addUnselectCb(() => {\n        this._unSelectLayer(def);\n      });\n      this._selectedLayers.forEach((x) => this._unSelectLayer(x));\n    }\n    this._selectedLayers.push(def);\n    this.selected = true;\n    const { selectedPaint, popupOnSelect, popupOptions } = this.options;\n\n    if (selectedPaint && def.layer) {\n      this._setPaint(def, selectedPaint);\n    }\n    if (popupOnSelect) {\n      this._openPopup(def, popupOptions, type, latlng);\n    }\n    if (this.options.onSelect) {\n      const features = def.feature ? [def.feature] : [];\n      this.options.onSelect({\n        type,\n        layer: this,\n        features,\n        ...createFeaturePositionOptions(features),\n      });\n    }\n  }\n\n  private _unSelectLayer(def: LayerDef) {\n    const index = this._selectedLayers.indexOf(def);\n    if (index !== -1) {\n      this._selectedLayers.splice(index, 1);\n      if (this.options) {\n        if (this.options.paint) {\n          this._setPaint(def, this.options.paint);\n        }\n\n        if (this.options.popupOnSelect && def.layer) {\n          this._removePopup(def.layer);\n        }\n      }\n    }\n    this.selected = this._selectedLayers.length > 0;\n  }\n\n  private _createDivIcon(icon: IconPaint) {\n    const { ...toLIconOpt } = icon;\n    return new DivIcon({ className: '', ...toLIconOpt });\n  }\n\n  private _createPaintToLayer(icon: IconPaint) {\n    if (icon && icon.type) {\n      if (icon.type === 'icon') {\n        const iconClassName = icon.className;\n        const html = icon.html;\n        if (iconClassName || html) {\n          return (geoJsonPoint: any, latlng: LatLngExpression) => {\n            const divIcon = this._createDivIcon(icon);\n            return new Marker(latlng, { icon: divIcon });\n          };\n        }\n      } else if (icon.type === 'pin') {\n        return (geoJsonPoint: any, latlng: LatLngExpression) => {\n          // const divIcon = this.createDivIcon(icon);\n          return new Marker(latlng);\n        };\n      }\n    }\n    return (geoJsonPoint: any, latlng: LatLngExpression) => {\n      const p: any = PAINT;\n      return new CircleMarker(latlng, this._preparePaint({ ...p, ...icon }));\n    };\n  }\n\n  private _createPaintOptions(\n    paintOptions: VectorAdapterLayerPaint,\n    type: VectorAdapterLayerType,\n  ): GeoJSONOptions {\n    const geoJsonOptions: GeoJSONOptions = {};\n    const paint = (paintOptions && this._preparePaint(paintOptions)) || {};\n    if (paintOptions) {\n      geoJsonOptions.style = () => {\n        return paint;\n      };\n    }\n    if (type === 'point') {\n      (geoJsonOptions as any).pointToLayer = this._createPaintToLayer(\n        paintOptions as IconPaint,\n      );\n    } else if (type === 'line') {\n      paint.stroke = true;\n    }\n    return geoJsonOptions;\n  }\n\n  private _addMapClickListener() {\n    const map = this.map;\n    if (map) {\n      const { unselectOnClick } = this.options;\n      const uoc = unselectOnClick ?? true;\n      if (uoc) {\n        map.on('click', this.$unselect);\n      }\n    }\n  }\n\n  private _removeMapClickListener() {\n    this.map.off('zoomend', this.$updateTooltip);\n    this.map.off('moveend', this.$updateTooltip);\n    this.map.off('click', this.$unselect);\n  }\n\n  private _addMapListener() {\n    const map = this.map;\n    if (map) {\n      const { labelField, labelOnHover } = this.options;\n      this._addMapClickListener();\n      if (labelField && !labelOnHover) {\n        map.on('zoomend', this.$updateTooltip);\n        map.on('moveend', this.$updateTooltip);\n      }\n    }\n  }\n\n  private _removeMapListener() {\n    this._removeMapClickListener();\n    this.map.off('zoomend', this.$updateTooltip);\n    this.map.off('moveend', this.$updateTooltip);\n  }\n}\n","import { convertMapClickEvent } from './convertMapClickEvent';\nimport { createFeaturePositionOptions } from './geometries';\n\nimport type { LeafletMouseEvent } from 'leaflet';\nimport type { LayerAdapter, OnLayerMouseOptions } from '@nextgis/webmap';\nimport type { LayerDef } from '../layer-adapters/GeoJsonAdapter';\n\nexport interface CreateMouseEventOptions {\n  layer: LayerAdapter;\n  source: LeafletMouseEvent;\n}\n\nexport function createMouseEvent({\n  layer,\n  source,\n}: CreateMouseEventOptions): OnLayerMouseOptions {\n  const layer_ = source.target as LayerDef;\n  const feature = layer_.feature;\n  const opt: OnLayerMouseOptions = {\n    layer,\n    feature,\n    event: convertMapClickEvent(source),\n    source,\n    ...createFeaturePositionOptions(feature),\n  };\n  return opt;\n}\n","export function callAjax(\n  src: string,\n  callback: (resp: any) => any,\n  headers: Record<string, any>,\n): () => void {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', src);\n  xhr.responseType = 'arraybuffer';\n  for (const h in headers) {\n    xhr.setRequestHeader(h, headers[h]);\n  }\n  xhr.onload = function () {\n    const arrayBufferView = new Uint8Array(this.response);\n    const blob = new Blob([arrayBufferView], { type: 'image/png' });\n    // @ts-ignore for typedoc\n    const urlCreator = window.URL || window.webkitURL;\n    const imageUrl = urlCreator.createObjectURL(blob);\n    callback(imageUrl);\n  };\n  xhr.send();\n  return () => {\n    xhr.abort();\n  };\n}\n","import {\n  ImageOverlay as LImageOverlay,\n  LatLngBoundsExpression,\n  ImageOverlayOptions,\n} from 'leaflet';\nimport { callAjax } from '../../utils/callAjax';\n\ntype IOptions = ImageOverlayOptions & { headers?: any };\n\nexport class ImageOverlay extends LImageOverlay {\n  private _abort: (() => void)[] = [];\n\n  constructor(\n    imageUrl: string,\n    bounds: LatLngBoundsExpression,\n    options?: IOptions,\n  ) {\n    super(imageUrl, bounds, options);\n  }\n\n  cancelLoad(): void {\n    if (this._abort) {\n      this._abort.forEach((x) => x());\n      this._abort = [];\n    }\n  }\n\n  _initImage(): void {\n    // @ts-ignore\n    super._initImage();\n    // @ts-ignore\n    const headers = this.options.headers;\n    if (headers) {\n      // @ts-ignore\n      const img: HTMLImageElement = this._image;\n      const src = img.src;\n      img.src = '';\n      this._abort.push(\n        callAjax(\n          src,\n          (response) => {\n            img.src = response;\n          },\n          headers,\n        ),\n      );\n    }\n  }\n}\n","/*!\n * leaflet.wms.js\n * A collection of Leaflet utilities for working with Web Mapping services.\n * (c) 2014-2016, Houston Engineering, Inc.\n * MIT License\n */\n\nimport { debounce } from '@nextgis/utils';\nimport { Layer, Util, CRS } from 'leaflet';\nimport { ImageOverlay } from './ImageOverlay';\n\nimport type { Map } from 'leaflet';\n\ninterface OverlayOptions {\n  crs?: null;\n  uppercase?: boolean;\n  attribution?: string;\n  opacity?: number;\n  isBack?: boolean;\n  minZoom?: number;\n  maxZoom?: number;\n  zIndex?: number;\n  pane?: string;\n  headers?: any;\n  viewPortBuffer?: number;\n  setViewDelay?: number;\n}\n\n/*\n * Overlay:\n * \"Single Tile\" WMS image overlay that updates with map changes.\n * Portions of wms.Overlay are directly extracted from L.TileLayer.WMS.\n * See Leaflet license.\n */\nexport class ImageLayer extends Layer {\n  defaultWmsParams = {\n    service: 'WMS',\n    request: 'GetMap',\n    version: '1.1.1',\n    layers: '',\n    styles: '',\n    format: 'image/jpeg',\n    transparent: false,\n  };\n\n  options: OverlayOptions = {\n    crs: null,\n    uppercase: false,\n    attribution: '',\n    opacity: 1,\n    isBack: false,\n    minZoom: 0,\n    pane: 'tilePane',\n    headers: null,\n    viewPortBuffer: 0,\n    setViewDelay: 100,\n  };\n\n  private wmsParams: any;\n  private _url?: string;\n  private _currentUrl?: string;\n  private _currentOverlay?: ImageOverlay;\n\n  constructor(url: string, options: OverlayOptions) {\n    super(options);\n    this._url = url;\n\n    // Move WMS parameters to params object\n    const params: any = {};\n    const opts: any = {};\n    let opt: keyof OverlayOptions;\n    for (opt in options) {\n      if (opt in this.options) {\n        opts[opt] = options[opt];\n      } else {\n        params[opt] = options[opt];\n      }\n    }\n    Util.setOptions(this, opts);\n    this.wmsParams = Util.extend({}, this.defaultWmsParams, params);\n  }\n\n  setParams(params: Record<string, any>): void {\n    Util.extend(this.wmsParams, params);\n    this.update();\n  }\n\n  getAttribution(): string {\n    return this.options.attribution || '';\n  }\n\n  onAdd(): this {\n    this.update();\n    return this;\n  }\n\n  onRemove(map: Map): this {\n    if (this._currentOverlay) {\n      this._currentOverlay.cancelLoad();\n      map.removeLayer(this._currentOverlay);\n      delete this._currentOverlay;\n    }\n    if (this._currentUrl) {\n      delete this._currentUrl;\n    }\n    return this;\n  }\n\n  getEvents(): {\n    moveend: () => void;\n  } {\n    return {\n      moveend: debounce(this.update, this.options.setViewDelay),\n    };\n  }\n\n  update(): void {\n    if (!this._map) {\n      return;\n    }\n    // Determine image URL and whether it has changed since last update\n    this.updateWmsParams();\n    const url = this.getImageUrl();\n    if (this._currentUrl === url) {\n      return;\n    }\n    this._currentUrl = url;\n\n    // Keep current image overlay in place until new one loads\n    // (inspired by esri.leaflet)\n    const viewPortBuffer = this.options.viewPortBuffer || 0;\n    const bounds = this._map.getBounds().pad(viewPortBuffer);\n\n    const overlay = new ImageOverlay(url, bounds, {\n      opacity: 0,\n      pane: this.options.pane,\n      headers: this.options.headers,\n    });\n    overlay.addTo(this._map);\n    if (this._currentOverlay) {\n      this._currentOverlay.cancelLoad();\n    }\n    overlay.once(\n      'load',\n      () => {\n        if (!this._map) {\n          return;\n        }\n        // @ts-ignore\n        if (overlay._url !== this._currentUrl) {\n          this._map.removeLayer(overlay);\n          return;\n        } else if (this._currentOverlay) {\n          this._map.removeLayer(this._currentOverlay);\n        }\n        this._currentOverlay = overlay;\n        overlay.setOpacity(\n          this.options.opacity !== undefined ? this.options.opacity : 1,\n        );\n        if (this.options.isBack === true) {\n          overlay.bringToBack();\n        }\n        if (this.options.isBack === false) {\n          overlay.bringToFront();\n        }\n        if (this.options.zIndex !== undefined) {\n          overlay.setZIndex(this.options.zIndex);\n        }\n      },\n      this,\n    );\n    const { minZoom, maxZoom } = this.options;\n    if (\n      (minZoom && this._map.getZoom() < minZoom) ||\n      (maxZoom && this._map.getZoom() > maxZoom)\n    ) {\n      this._map.removeLayer(overlay);\n    }\n  }\n\n  setOpacity(opacity: number): void {\n    this.options.opacity = opacity;\n    if (this._currentOverlay) {\n      this._currentOverlay.setOpacity(opacity);\n    }\n  }\n\n  bringToBack(): void {\n    this.options.isBack = true;\n    if (this._currentOverlay) {\n      this._currentOverlay.bringToBack();\n    }\n  }\n\n  bringToFront(): void {\n    this.options.isBack = false;\n    if (this._currentOverlay) {\n      this._currentOverlay.bringToFront();\n    }\n  }\n\n  setZIndex(zIndex: number): void {\n    this.options.zIndex = zIndex;\n    if (this._currentOverlay) {\n      this._currentOverlay.setZIndex(zIndex);\n    }\n  }\n\n  // See L.TileLayer.WMS: onAdd() & getTileUrl()\n  updateWmsParams(map?: Map): void {\n    if (!map) {\n      map = this._map;\n    }\n    // Compute WMS options\n    const viewPortBuffer = this.options.viewPortBuffer || 0;\n    const bounds = map.getBounds().pad(viewPortBuffer);\n    const size = map.getSize();\n    if (this.options.viewPortBuffer !== 0) {\n      const factor = viewPortBuffer + 1;\n      size.x = Math.ceil(size.x * factor);\n      size.y = Math.ceil(size.y * factor);\n    }\n    const wmsVersion = parseFloat(this.wmsParams.version);\n    const crs = this.options.crs || map.options.crs;\n    const projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';\n    if (crs) {\n      const nw = crs.project(bounds.getNorthWest());\n      const se = crs.project(bounds.getSouthEast());\n\n      // Assemble WMS parameter string\n      const params: any = {\n        width: size.x,\n        height: size.y,\n      };\n      params[projectionKey] = crs.code;\n      params.bbox = (\n        wmsVersion >= 1.3 && crs === CRS.EPSG4326\n          ? [se.y, nw.x, nw.y, se.x]\n          : [nw.x, se.y, se.x, nw.y]\n      ).join(',');\n\n      Util.extend(this.wmsParams, params);\n    }\n  }\n\n  getImageUrl(): string {\n    const uppercase = this.options.uppercase || false;\n    const pstr = Util.getParamString(this.wmsParams, this._url, uppercase);\n    return this._url + pstr;\n  }\n}\n","import { MainLayerAdapter } from '@nextgis/webmap';\nimport { ImageLayer } from './ImageLayer';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport type { Map } from 'leaflet';\nimport type { ImageAdapterOptions } from '@nextgis/webmap';\n\nexport class ImageAdapter\n  extends BaseAdapter<ImageAdapterOptions>\n  implements MainLayerAdapter<Map>\n{\n  layer: any;\n\n  addLayer(options: ImageAdapterOptions): any {\n    const url = options && options.url;\n    if (url) {\n      options = { transparent: true, ...options };\n      const updateWmsParamsFromOpt = options.updateWmsParams;\n      this.layer = new ImageLayer(url, {\n        pane: this.pane,\n        headers: options.headers,\n        setViewDelay: options.setViewDelay,\n        /**\n         * TODO: safe remove, use only options.nativeOptions\n         */\n        ...options,\n        ...options.params,\n        ...options.nativeOptions,\n      });\n      if (updateWmsParamsFromOpt) {\n        const updateWmsParams = this.layer.updateWmsParams;\n        this.layer.updateWmsParams = function (map: Map) {\n          updateWmsParams.call(this, map);\n          this.wmsParams = updateWmsParamsFromOpt(this.wmsParams);\n        };\n      }\n      return this.layer;\n    }\n  }\n}\n","import { DomUtil, GridLayer, Util } from 'leaflet';\nimport { debounce } from '../../../utils/src';\nimport { callAjax } from './callAjax';\n\n// import type { TileLayerOptionsExtended } from './TileAdapter/TileLayer';\n\ntype Constructor = new (...args: any[]) => any;\n\nexport function makeRemote<\n  TBase extends Constructor,\n  // O extends TileLayerOptionsExtended = TileLayerOptionsExtended\n>(Base: TBase): TBase {\n  return class RemoteTileLayer extends Base {\n    constructor(...args: any[]) {\n      super(...args);\n      if (this.options.setViewDelay) {\n        // @ts-ignore\n        this._update = debounce((...a: any[]) => {\n          // @ts-ignore\n          GridLayer.prototype._update.call(this, ...a);\n        }, this.options.setViewDelay);\n      }\n    }\n\n    createTile(\n      coords: Record<string, unknown>,\n      done: (error: any, tile: HTMLImageElement) => void,\n    ): HTMLImageElement {\n      // @ts-ignore\n      const url = this.getTileUrl(coords);\n\n      const tile = document.createElement('img');\n      (tile as any).abort = callAjax(\n        url,\n        (response) => {\n          tile.src = response;\n          done(null, tile);\n        },\n        // @ts-ignore\n        this.options.headers,\n      );\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin =\n          this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      tile.alt = '';\n      tile.setAttribute('role', 'presentation');\n\n      return tile;\n    }\n\n    _abortLoading() {\n      // @ts-ignore\n      const tiles = this._tiles;\n      // @ts-ignore\n      const tileZoom = this._tileZoom;\n      for (const i in tiles) {\n        if (tiles[i].coords.z !== tileZoom) {\n          const tile = tiles[i].el;\n\n          tile.onload = Util.falseFn;\n          tile.onerror = Util.falseFn;\n          if (!tile.complete) {\n            if (tile.abort) {\n              tile.abort();\n            }\n            tile.src = Util.emptyImageUrl;\n            DomUtil.remove(tile);\n            delete tiles[i];\n          }\n        }\n      }\n    }\n  };\n}\n","import { TileLayer as TL } from 'leaflet';\nimport { makeRemote } from '../../utils/makeRemoteTileLayer';\n\nimport type { TileLayerOptions } from 'leaflet';\n\nexport type TileLayerOptionsExtended = TileLayerOptions & {\n  headers: Record<string, any>;\n  setViewDelay?: number;\n};\n\nclass TileLayerBase extends TL {\n  constructor(urlTemplate: string, options?: TileLayerOptionsExtended) {\n    super(urlTemplate, options);\n    Object.assign(this.options, options);\n  }\n}\n\nexport const TileLayer = makeRemote(TileLayerBase);\n","import { TileLayer } from 'leaflet';\nimport { TileLayer as TL } from './TileLayer';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport type { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport type { TileLayerOptions } from 'leaflet';\n\nexport class TileAdapter\n  extends BaseAdapter<TileAdapterOptions, TileLayer>\n  implements MainLayerAdapter\n{\n  addLayer(options: TileAdapterOptions): TileLayer | undefined {\n    this.options = Object.assign(this.options, options);\n    if (options) {\n      const { url, ...opt } = options;\n      if (url) {\n        const tileLayerOptions: TileLayerOptions = {\n          pane: this.pane,\n          attribution: opt.attribution,\n          minZoom: opt.minZoom,\n          maxZoom: opt.maxZoom,\n\n          ...opt.nativeOptions,\n        };\n        if (opt.subdomains) {\n          tileLayerOptions.subdomains = opt.subdomains;\n        }\n        let layer;\n        if (opt.headers) {\n          layer = new TL(url, {\n            ...tileLayerOptions,\n            headers: opt.headers,\n            setViewDelay: opt.setViewDelay,\n          });\n        } else {\n          layer = new TileLayer(url, tileLayerOptions);\n        }\n        return layer;\n      }\n    }\n  }\n}\n","import { TileLayer } from 'leaflet';\nimport { makeRemote } from '../../utils/makeRemoteTileLayer';\nimport type { WMSOptions } from 'leaflet';\n\ntype LayerOptions = WMSOptions & { headers: any };\n\nclass WmsLayerBase extends TileLayer.WMS {\n  constructor(urlTemplate: string, options: LayerOptions) {\n    super(urlTemplate, options);\n  }\n}\n\nexport const WmsLayer = makeRemote(WmsLayerBase);\n","import { TileLayer } from 'leaflet';\nimport { WmsLayer as WMS } from './WmsLayer';\nimport { BaseAdapter } from '../BaseAdapter';\n\nimport type { MainLayerAdapter, WmsAdapterOptions } from '@nextgis/webmap';\nimport type { WMSOptions } from 'leaflet';\n\nexport class WmsAdapter\n  extends BaseAdapter<WmsAdapterOptions, TileLayer.WMS>\n  implements MainLayerAdapter\n{\n  addLayer(options: WmsAdapterOptions): TileLayer.WMS | undefined {\n    Object.assign(this.options, options);\n    const { url, ...opt } = options;\n    if (url) {\n      const layerOptions: WMSOptions = {\n        pane: this.pane,\n        attribution: opt.attribution,\n        minZoom: opt.minZoom,\n        maxZoom: opt.maxZoom,\n        layers: options.layers,\n        format: options.format,\n        ...options.nativeOptions,\n      };\n      let layer;\n      if (opt.headers) {\n        layer = new WMS(url, { ...layerOptions, headers: opt.headers });\n      } else {\n        layer = new TileLayer.WMS(url, layerOptions);\n      }\n      return layer;\n    }\n  }\n}\n","import { MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileLayer } from 'leaflet';\n\nimport { TileAdapter } from './TileAdapter/TileAdapter';\n\nexport class OsmAdapter extends TileAdapter implements MainLayerAdapter {\n  addLayer(options: Omit<TileAdapterOptions, 'url'>): TileLayer | undefined {\n    const url = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    return super.addLayer({\n      name: 'OpenStreetMap',\n      attribution:\n        '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n      ...options,\n      url,\n    });\n  }\n}\n","import type { LatLngBoundsExpression } from 'leaflet';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\nexport function arrayToBoundsExpression(\n  bounds: LngLatBoundsArray,\n): LatLngBoundsExpression {\n  const e = bounds;\n  // top, left, bottom, right\n  return [\n    [e[3], e[0]],\n    [e[1], e[2]],\n  ];\n}\n","import { EventEmitter } from 'events';\nimport {\n  Map,\n  Control,\n  FitBoundsOptions,\n  LatLngBoundsExpression,\n} from 'leaflet';\nimport { convertMapClickEvent } from './utils/convertMapClickEvent';\nimport { createButtonControl } from './controls/createButtonControl';\nimport { AttributionControl } from './controls/Attribution';\nimport { createControl } from './controls/createControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { ImageAdapter } from './layer-adapters/ImageAdapter/ImageAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter/TileAdapter';\nimport { WmsAdapter } from './layer-adapters/WmsAdapter/WmsAdapter';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\n\nimport type {\n  Layer,\n  GridLayer,\n  LeafletEvent,\n  LocationEvent,\n  ControlPosition,\n  LeafletMouseEvent,\n} from 'leaflet';\nimport type { LngLatBoundsArray, LngLatArray } from '@nextgis/utils';\nimport type {\n  CreateControlOptions,\n  ButtonControlOptions,\n  LocationEvents,\n  LocateOptions,\n  MainMapEvents,\n  LayerAdapter,\n  ViewOptions,\n  MapAdapter,\n  MapOptions,\n  FitOptions,\n  MapControl,\n  Locate,\n} from '@nextgis/webmap';\nimport { arrayToBoundsExpression } from './utils/arrayToBoundsExpression';\n\nexport type Type<T> = new (...args: any[]) => T;\nexport type UnselectCb = () => void;\nexport type UnselectDef = UnselectCb;\nexport class LeafletMapAdapter implements MapAdapter<Map, any, Control> {\n  static layerAdapters: {\n    [name: string]: Type<LayerAdapter<Map, any, any>>;\n  } = {\n    GEOJSON: GeoJsonAdapter,\n    IMAGE: ImageAdapter,\n    TILE: TileAdapter,\n    WMS: WmsAdapter,\n    // // MVT: MvtAdapter,\n    OSM: OsmAdapter,\n  };\n\n  static controlAdapters = {\n    ZOOM: Control.Zoom,\n    ATTRIBUTION: AttributionControl,\n  };\n\n  static Map = Map;\n\n  options: MapOptions<Map> = { target: 'map' };\n\n  layerAdapters = LeafletMapAdapter.layerAdapters;\n  controlAdapters = LeafletMapAdapter.controlAdapters;\n  emitter = new EventEmitter();\n  map?: Map;\n\n  private _resizeObserver?: ResizeObserver;\n  private _unselectCb: UnselectDef[] = [];\n  private _universalEvents: (keyof MainMapEvents)[] = [\n    'move',\n    'zoom',\n    'zoomend',\n    'zoomstart',\n    'moveend',\n    'movestart',\n  ];\n  private _positionEvents: (keyof MainMapEvents)[] = [\n    'mousemove',\n    'mouseout',\n    'mouseover',\n  ];\n\n  create(options: MapOptions<Map>): void {\n    this.options = { ...options };\n    if (this.options.target) {\n      const {\n        zoom,\n        center,\n        maxZoom,\n        minZoom,\n        maxBounds: mb,\n        mapAdapterOptions,\n      } = this.options;\n\n      this.map =\n        this.options.map ||\n        new Map(this.options.target, {\n          attributionControl: false,\n          zoomControl: false,\n          maxBounds: mb ? arrayToBoundsExpression(mb) : undefined,\n          maxZoom,\n          minZoom,\n          center: center && [center[1], center[0]],\n          zoom,\n          ...mapAdapterOptions,\n        });\n      // create default pane\n      const defPane = this.map.createPane('order-0');\n      (this.map as any)._addUnselectCb = (def: UnselectDef) => {\n        this._addUnselectCb(def);\n      };\n      defPane.style.zIndex = String(0);\n      this.emitter.emit('create', this);\n      this._addMapListeners();\n    }\n  }\n\n  destroy(): void {\n    if (this.map) {\n      this.map.remove();\n    }\n    this._stopWatchSizeChangeToUpdateMinZoom();\n  }\n\n  getContainer(): HTMLElement | undefined {\n    return this.map && this.map.getContainer();\n  }\n\n  getControlContainer(): HTMLElement {\n    const controlContainer = this.map && (this.map as any)._controlContainer;\n    if (controlContainer) {\n      return controlContainer;\n    }\n    throw new Error('Leaflet Map is not initialized yet');\n  }\n\n  setCursor(cursor: string): void {\n    if (this.map) {\n      this.map.getContainer().style.cursor = cursor;\n    }\n  }\n\n  setView(lngLat: LngLatArray, zoom?: number): void;\n  setView(options: ViewOptions): void;\n  setView(lngLatOrOpt: LngLatArray | ViewOptions, zoom?: number): void {\n    const map = this.map;\n    if (!map) return;\n    if (Array.isArray(lngLatOrOpt)) {\n      const lngLat = lngLatOrOpt;\n      const [lng, lat] = lngLat;\n      if (this.map) {\n        if (typeof zoom === 'number') {\n          this.map.setView([lat, lng], zoom, { animate: false });\n        } else {\n          this.setCenter([lng, lat]);\n        }\n      }\n    } else {\n      const { zoom, center, maxBounds, bounds, minZoom, maxZoom } = lngLatOrOpt;\n      if (center && zoom !== undefined) {\n        this.setView(center, zoom);\n      } else {\n        if (zoom !== undefined) {\n          this.setZoom(zoom);\n        }\n        if (center) {\n          this.setCenter(center);\n        }\n      }\n      if (bounds) {\n        this.fitBounds(bounds);\n      }\n      if (maxBounds !== undefined) {\n        if (maxBounds) {\n          const b = arrayToBoundsExpression(maxBounds);\n          map.setMaxBounds(b);\n          map.setMinZoom(map.getBoundsZoom(b));\n          this._watchSizeChangeToUpdateMinZoom(b);\n        } else {\n          // @ts-ignore `null` works for unset maxBounds, but not in typing\n          map.setMaxBounds(null);\n          this._stopWatchSizeChangeToUpdateMinZoom();\n        }\n      }\n      if (maxZoom !== undefined) {\n        map.setMaxZoom(maxZoom);\n      }\n      if (minZoom !== undefined) {\n        this._stopWatchSizeChangeToUpdateMinZoom();\n        map.setMinZoom(minZoom);\n      }\n    }\n  }\n\n  setCenter(lngLat: LngLatArray): void {\n    const [lng, lat] = lngLat;\n    if (this.map) {\n      this.map.panTo([lat, lng]);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    const map = this.map;\n    if (map) {\n      const bounds = map.getBounds();\n      const center = bounds.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom);\n    }\n  }\n\n  getZoom(): number | undefined {\n    return (this.map && this.map.getZoom()) ?? undefined;\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (!this.map) return undefined;\n    const b = this.map.getBounds();\n    const sw = b.getSouthWest();\n    const ne = b.getNorthEast();\n    return [sw.lng, sw.lat, ne.lng, ne.lat];\n  }\n\n  // [west, south, east, north]\n  fitBounds(bounds: LngLatBoundsArray, options: FitOptions = {}): void {\n    if (this.map) {\n      const { maxZoom, offset, padding } = options;\n      const opt: FitBoundsOptions = {};\n      if (maxZoom) {\n        opt.maxZoom = maxZoom;\n      }\n      if (padding) {\n        opt.padding = [padding, padding];\n      }\n      if (offset) {\n        opt.padding = offset;\n      }\n\n      this.map.fitBounds(arrayToBoundsExpression(bounds), opt);\n    }\n  }\n\n  getLayerAdapter(name: string): Type<LayerAdapter<Map, any, any>> {\n    return LeafletMapAdapter.layerAdapters[name];\n  }\n\n  createControl(control: MapControl, options: CreateControlOptions): Control {\n    return createControl(control, options, this);\n  }\n\n  createButtonControl(options: ButtonControlOptions): Control {\n    return createButtonControl(options, this);\n  }\n\n  addControl(control: Control, position: string): Control | undefined {\n    control.options.position = position.replace('-', '') as ControlPosition;\n    if (this.map) {\n      this.map.addControl(control);\n      return control;\n    }\n  }\n\n  removeControl(control: Control): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  removeLayer(layer: Layer): void {\n    layer && layer.remove && layer.remove();\n  }\n\n  showLayer(layer: Layer): void {\n    if (this.map) {\n      layer.addTo(this.map);\n    }\n  }\n\n  hideLayer(layer: Layer): void {\n    layer.remove();\n  }\n\n  setLayerOpacity(layer: GridLayer | Layer, value: number): void {\n    if ('setOpacity' in layer) {\n      layer.setOpacity(value);\n    }\n  }\n\n  setLayerOrder(\n    layer: Layer,\n    order: number,\n    layers: { [x: string]: LayerAdapter },\n  ): void {\n    //\n  }\n\n  onMapClick(evt: LeafletMouseEvent): void {\n    const converted = convertMapClickEvent(evt);\n    this.emitter.emit('preclick', converted);\n    this.emitter.emit('click', converted);\n  }\n\n  locate(opt: LocateOptions, events?: LocationEvents): Locate {\n    const map = this.map;\n    if (map) {\n      map.locate(opt);\n      if (events) {\n        const { locationfound, locationerror } = events;\n        const locationFound = (e: LeafletEvent) => {\n          const event = e as LocationEvent;\n          const lngLat: [number, number] = [event.latlng.lng, event.latlng.lat];\n          locationfound({ lngLat });\n        };\n        if (locationfound !== undefined) {\n          map.on('locationfound', locationFound, this);\n        }\n        if (locationerror) {\n          map.on('locationerror', locationerror, this);\n        }\n        const stop = () => {\n          if (locationfound !== undefined) {\n            map.off('locationfound', locationFound);\n          }\n          if (locationerror) {\n            map.off('locationerror', locationerror);\n          }\n        };\n        return { stop };\n      }\n    }\n    const stop = () => void 'fake function';\n    return { stop };\n  }\n\n  private _addUnselectCb(cb: UnselectDef) {\n    for (const p of this._unselectCb) {\n      p();\n    }\n    this._unselectCb.length = 0;\n    this._unselectCb.push(cb);\n  }\n\n  private _watchSizeChangeToUpdateMinZoom(bounds: LatLngBoundsExpression) {\n    this._stopWatchSizeChangeToUpdateMinZoom();\n    const container = this.getContainer();\n    const map = this.map;\n    if (container && map && window.ResizeObserver) {\n      this._resizeObserver = new ResizeObserver(() => {\n        map.setMinZoom(map.getBoundsZoom(bounds));\n      });\n      this._resizeObserver.observe(container);\n    }\n  }\n\n  private _stopWatchSizeChangeToUpdateMinZoom() {\n    const map = this.map;\n    if (map) {\n      map.setMinZoom(0);\n    }\n    if (this._resizeObserver) {\n      this._resizeObserver.disconnect();\n      this._resizeObserver = undefined;\n    }\n  }\n\n  private _addMapListeners() {\n    const map = this.map;\n    if (map) {\n      map.on('click', (evt) => {\n        this.onMapClick(evt as LeafletMouseEvent);\n      });\n      for (const e of this._universalEvents) {\n        map.on(e, () => this.emitter.emit(e, this), map);\n      }\n\n      for (const e of this._positionEvents) {\n        map.on(\n          e,\n          (evt) =>\n            this.emitter.emit(\n              e,\n              convertMapClickEvent(evt as LeafletMouseEvent),\n            ),\n          map,\n        );\n      }\n    }\n  }\n}\n","import { ButtonControlOptions, MapAdapter } from '@nextgis/webmap';\nimport { createControl } from './createControl';\nimport { DomEvent, Control } from 'leaflet';\n\nexport function createButtonControl(\n  options: ButtonControlOptions,\n  map: MapAdapter,\n): Control {\n  const link = document.createElement('a');\n\n  const title = options.title || '';\n  link.href = '#';\n  link.title = title;\n\n  link.setAttribute('role', 'button');\n  link.setAttribute('aria-label', title);\n\n  if (options.addClass) {\n    link.classList.add(options.addClass);\n  }\n\n  DomEvent.disableClickPropagation(link);\n  DomEvent.on(link, 'click', DomEvent.stop);\n\n  if (options.html instanceof HTMLElement) {\n    link.appendChild(options.html);\n  } else if (typeof options.html === 'string') {\n    link.innerHTML = options.html;\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n\n  return createControl(\n    {\n      onAdd() {\n        if (options.onClick !== undefined) {\n          link.addEventListener('click', onClick);\n        }\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      },\n    },\n    { bar: true },\n    map,\n  );\n}\n","/**\n * @module leaflet-map-adapter\n */\n\nimport { LeafletMapAdapter } from './LeafletMapAdapter';\n\nexport default LeafletMapAdapter;\n"],"names":["svgPath","brill","circle","rect","marker","cross","star","triangle","plus","minus","asterisk","insertSvg","width","height","stroke","content","s","svg","oParser","DOMParser","oDOM","parseFromString","documentElement","getIcon","opt","shape","color","strokeColor","size","anchor","defSize","scale","pathAlias","path","fistChild","firstChild","transform","setAttribute","String","XMLSerializer","type","iconSize","iconAnchor","html","serializeToString","TreeHelper","item","this","parent","_parent","child","_children","push","filterFunc","getParent","treeFilter","x","tree","toReturn","treeFind","getChildren","treeEvery","treeSome","getDescendants","BaseProperty","name","options","EventEmitter","Object","assign","_value","getProperty","call","value","getParents","length","undefined","_blocked","parents","isBlocked","find","parentProp","properties","property","get","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_container","parentNode","removeChild","_removeEventsListener","onSet","emitter","emit","forEach","prop","CheckProperty","set","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","every","_block","_unBlock","_blockChild","_unBlockChild","turnOff","hierarchy","isGroup","blockChild","turnOn","unblockChild","block","children","fry","label","ItemProperties","propertiesList","_propertiesList","_setPropertyHandler","bind","propOpt","handlers","Handler","handler","_properties","list","map","p","destroy","ID","Item","convertMapClickEvent","evt","coord","containerPoint","latLng","latlng","lat","lngLat","lng","pixel","left","top","y","source","createControl","control","C","Control","onAdd","element","document","createElement","classList","add","bar","addClass","margin","style","marginBottom","marginTop","marginLeft","marginRight","appendChild","DomEvent","onRemove","AttributionControl","customAttribution","attributions","Array","isArray","addAttribution","boundsToArray","bounds","ne","getNorthEast","sw","getSouthWest","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","PAINT","opacity","backAliases","a","layerType","backAlias","geometryFilter","geometry","indexOf","featuresBounds","features","geoJsonLayer","GeoJSON","f","addData","getBounds","createFeaturePositionOptions","getFeaturesBounds","getCenter","getFeaturesCenter","findMostFrequentGeomType","arr","counts","maxName","c","maxCount","BaseAdapter","order","pane","exist","getPane","createPane","zIndex","Math","round","GeoJsonAdapter","debounce","updateTooltip","unselect","paint","layer","FeatureGroup","nativeOptions","selectedPaint","data","_addMapListener","_removeMapListener","findFeatureFun","_layers","filter","_selectLayer","selected","_setPaintEachLayer","_unSelectLayer","_openedPopup","_removePopup","_selectedLayers","target","feature","_filteredLayers","fun","_filterFun","layer_","_map","remove","filteredLayers","addLayer","removeLayer","addTo","visible","cb","def","splice","clearLayers","clearLayer","geoJsonOptions","geojson","detectedType","geometries","g","console","warn","_data","filterGeometries","_getGeoJsonOptions","_openPopup","layerDef","_updateTooltip","getLayers","isValid","setPaint","setSelectedPaint","l","_setPaint","labelField","unbindTooltip","message","permanent","labelOnHover","bindTooltip","sticky","minWidth","autoPan","maxWidth","closeButton_","closeButton","selectOnHover","_closeHandlers","onClose","close","popup","createPopupContent","popupContent","popupOptions","closeOnClick","autoClose","defined","bindPopup","unselectOnClose","getPopup","once","openPopup","closePopup","unbindPopup","index","findIndex","closeHandlers","h","isPaintCallback","isPaint","divIcon","_createDivIcon","setIcon","setStyle","_preparePaint","aliases","readyPaint","radius","to","from","paintProp","toLowerCase","Number","defineProperty","enumerable","lopt","pointToLayer","iconOpt","_createPaintToLayer","_createPaintOptions","onEachFeature","_onEachFeature","ok","selectable","interactive","on","e","_selectOnLayerClick","_handleMouseEvents","setTimeout","onClick","onLayerClick","onMouseOut","onMouseOver","onClick_","_getSelected","_createMouseEvent","event","createMouseEvent","isSelected","unselectOnSecondClick","multiselect","_addUnselectCb","popupOnSelect","onSelect","icon","toLIconOpt","DivIcon","className","iconClassName","geoJsonPoint","Marker","CircleMarker","paintOptions","unselectOnClick","$unselect","off","$updateTooltip","_addMapClickListener","_removeMapClickListener","callAjax","src","callback","headers","xhr","XMLHttpRequest","open","responseType","setRequestHeader","onload","arrayBufferView","Uint8Array","response","blob","Blob","imageUrl","window","URL","webkitURL","createObjectURL","send","abort","ImageOverlay","_abort","img","_image","LImageOverlay","ImageLayer","url","service","request","version","layers","styles","format","transparent","crs","uppercase","attribution","isBack","minZoom","viewPortBuffer","setViewDelay","_url","params","opts","Util","wmsParams","defaultWmsParams","_currentOverlay","cancelLoad","_currentUrl","moveend","updateWmsParams","getImageUrl","pad","overlay","setOpacity","bringToBack","bringToFront","setZIndex","maxZoom","getZoom","getSize","factor","ceil","wmsVersion","parseFloat","projectionKey","nw","project","getNorthWest","se","getSouthEast","code","bbox","CRS","join","pstr","Layer","ImageAdapter","updateWmsParamsFromOpt","makeRemote","Base","args","_update","GridLayer","coords","done","getTileUrl","tile","crossOrigin","alt","tiles","_tiles","tileZoom","_tileZoom","i","z","el","onerror","complete","DomUtil","TileLayer","TileLayerBase","urlTemplate","TL","TileAdapter","tileLayerOptions","subdomains","WmsLayer","WmsLayerBase","WmsAdapter","layerOptions","WMS","OsmAdapter","arrayToBoundsExpression","LeafletMapAdapter","layerAdapters","controlAdapters","zoom","center","mb","maxBounds","mapAdapterOptions","Map","attributionControl","zoomControl","defPane","_addMapListeners","_stopWatchSizeChangeToUpdateMinZoom","getContainer","controlContainer","_controlContainer","Error","cursor","lngLatOrOpt","setView","animate","setCenter","setZoom","fitBounds","b","setMaxBounds","setMinZoom","getBoundsZoom","_watchSizeChangeToUpdateMinZoom","setMaxZoom","panTo","offset","padding","link","title","href","HTMLElement","innerHTML","stopPropagation","addEventListener","removeEventListener","createButtonControl","position","replace","addControl","removeControl","converted","events","locate","locationfound","locationerror","locationFound","stop","_unselectCb","container","ResizeObserver","_resizeObserver","observe","disconnect","onMapClick","_universalEvents","_positionEvents","GEOJSON","IMAGE","TILE","OSM","ZOOM","ATTRIBUTION"],"sourceRoot":""}