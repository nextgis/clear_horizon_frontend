{"version":3,"sources":["webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeature.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerItems.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatureCollection.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwLayerFeatures.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/fetchNgwExtent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createGeoJsonAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/createPopupContent.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getLayerAdapterOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createRasterAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/utils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/BookmarkItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwWebmapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createOnFirstShowNgwAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwResource.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createAsyncAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createNgwWebmapAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/adapters/createBasemapLayerAdapter.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/NgwKit.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/IdentifyItem.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/identifyUtils.ts","webpack://clear_horizon/./@nextgis/packages/ngw-kit/src/utils/getCompanyLogo.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/appendNgwResources.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/utils/prepareWebMapOptions.ts","webpack://clear_horizon/./@nextgis/packages/ngw-map/src/NgwMap.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/typeHelpers.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/fromPaintExpression.ts","webpack://clear_horizon/./@nextgis/packages/paint/src/preparePaint.ts","webpack://clear_horizon/./@nextgis/packages/properties-filter/src/propertiesFilter.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/updateQmsOptions.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/loadJson.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/utils/getSubmodulesFromOriginUrl.ts","webpack://clear_horizon/./@nextgis/packages/qms-kit/src/QmsKit.ts"],"names":["filterOptionsKeys","getLayerFilterOptions","options","filterOptions","forEach","x","opt","undefined","resourceIdFromLayerOptions","connector","resource","item","keyname","resourceId","id","getResource","resourceItem","params","FEATURE_REQUEST_PARAMS","updateItemRequestParam","get","fid","featureId","then","resp","toGeojson","geom","createGeoJsonFeature","fields","extensions","onlyGeomItem","srs","geom_format","geometry","type","properties","join","Array","isArray","idFilterWorkAround","value","filterById","featureIds","split","map","Number","Error","promises","createFeatureFieldFilterQueries","_queries","_parentAllParams","filters","logic","filters_","filter","createParam","pf","f","push","fetchNgwLayerItemsRequest","paramList","find","length","itemsParts","items","reduce","a","b","concat","offset","limit","splice","intersects","orderBy","order_by","data","y","features","fetchNgwLayerFeatures","getNgwWebmapExtent","webmap","bottom","left","top","right","extent","fetchNgwLayerExtent","maxLat","maxLon","minLat","fetchNgwResourceExtent","cls","indexOf","parent","res","createGeoJsonAdapter","webMap","addLayerOptionsPriority","layerOptions","GeoJsonAdapter","Adapter","mapAdapter","layerAdapters","GEOJSON","_fullDataLoad","adapterOptions","popupOptions","fromProperties","createPopupContent","feature","document","createElement","feature_layer","grid_visibility","propElem","appendChild","innerHTML","display_name","p","geoJsonAdapterCb","abort","_lastFilterArgs","_dataPromise","removed","cancel","emitter","EventEmitter","addLayer","opt_","needUpdate","waitFullLoad","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","Object","keys","layer","this","strategy","propertiesFilter","updatePromise","updateLayer","_addBboxEventListener","getExtent","hasData","getLayers","beforeRemove","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","__onMapMoveStart","getCount","_count","total_count","filterArgs","onLoad","_getMapBbox","setLayerData","emit","name","e","setData","clearLayer","removeFilter","_addMoveEventListener","on","removeListener","bounds","getBounds","s","w","n","lng","lat","getLayerAdapterOptions","baseUrl","url","adapter","getLayerAdapters","isImageAllowed","IMAGE","nd","tileNoData","headers","updateWmsParams","updateImageParams","format","version","layers","simplification","console","log","createRasterAdapter","resourceCls","clsAdapterAlias","wmsserver_service","tmsclient_layer","adapterClass","_options","layerAdapterOptions","setViewDelay","String","addOptions","getIdentificationIds","noInit","NgwWebmapItem","_rootDescendantsCount","tree","setParent","item_type","_sumUp","children","root","getRoot","initProperties","_init","create","ngwWebmapItem","initItem","i","getItemOptions","setNewLayer","l","_layer","set","opacity","setLayerOpacity","getChildren","addChild","Promise","resolve","layer_adapter","toUpperCase","GetAdapterFromLayerType","getAdapter","newLayer","reject","bringToFront","fit","transparency","layer_transparency","visibility","crossOrigin","order","subOrder","drawOrderEnabled","draw_order_position","subLevel","padStart","maxZoom","layer_max_scale_denom","_mapScaleToZoomLevel","minZoom","layer_min_scale_denom","ratio","minScale","maxScale","reverse","scale","centerLat","Math","LN2","getZoomFromScale","_pixelsInMeter","div","style","cssText","body","px","offsetWidth","removeChild","pixelsInMeterWidth","PI","cos","getMapWidthForLanInMeters","setScaleRatio","totalValue","child","getProperty","layer_enabled","onSet","showLayer","hideLayer","labelField","_extent","minLon","lonLat","geoJson","pixelRadius","webmapClassName","r","_getWebMapLayerItem","removeLayer","getDependLayers","response","_webmapLayersIds","property","getDescendants","getBookmarksResourceId","bookmark_resource","fetchBookmarks","bookmarkResId","getResourceOrFail","label_field","bookmarks","bookmark","BookmarkItem","visibleLayers","ids","_getWebMapIds","sort","parentId","visible","isBlocked","getWebMapConfig","root_item","auth","getAuthorizationHeaders","draw_order_enabled","basemap_webmap","basemaps","_setBasemaps","defaultBasemap","addBaseLayer","extent_left","extent_bottom","extent_right","extent_top","_updateItemsParams","baseWebmap","enabledAlreadySet","idPrefix","_removed","createAsyncAdapter","resource_id","baselayer","assign","createOnFirstShowNgwAdapter","enabled","layer_style_id","webMapItem","promise","all","classAdapters","supportCls","createAdapterFromFirstStyle","childrenStyles","firstStyle","adapterType","itemFromResOpt","createWebMapAdapter","basemap_layer","qms","qms_","JSON","parse","prototype","TileAdapter","TILE","createBasemapLayerAdapter","parentItem","parentOptions","getClassAdapter","classAdapter","resourceAdapter","NgwResource","replace","bbox","width","height","size","timestamp","Date","now","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","addNgwLayer","addClassAdapters","onLoadSync","resourceIds","NgwWebmapLayerAdapter","_getLayerAdapter","createAdapter","_createAdapter","label","layerId","identify","_item","_resource","geojson","_geojson","getIdentifyItems","multiple","resources","paramsList","isNaN","sortingArr","fry","identifyItem","layerFeatures","fetchIdentifyGeoJson","withGeom","fetchIdentifyItem","requestOptions","sendIdentifyRequest","ev","lngLat","coordinates","radius","polygon","post","createIdentifyItem","IdentifyItem","getCompanyLogo","component","settings","company_logo","anchor","position","padding","className","cssClass","img","Image","maxHeight","maxWidth","src","responseType","urlCreator","window","URL","webkitURL","imageUrl","createObjectURL","link","trim","href","target","search","alt","appendNgwResources","defOptions","overwriteOptions","OPTIONS","whitlabel","controls","controlsOptions","ZOOM","ATTRIBUTION","customAttribution","kits","starterKits","center","maxBounds","prepareWebMapOptions","_ngwLayers","_promises","select","_createWebMap","container","getContainer","classList","add","_whiteLabel","addControl","controlDef","onMapLoad","getLayerId","getActiveBaseLayer","resId","error","zoom","setCenter","setZoom","fitBounds","fetchNgwLayerItem","fetchNgwLayerItems","fetchNgwLayerFeature","_addPromise","getIdentifyGeoJson","getNgwLayers","getNgwLayerByResourceId","mem","some","dependLayers","dependFit","fitLayer","layerDef","ngwLayer","zoomToLayer","event","getLayer","enableSelection","$$selectFromNgwRaster","listenerCount","_selectFromNgwRaster","$$selectFromNgwVector","_selectFromNgwVector","disableSelection","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","cancelPromise","cancelPromises","args","group","groupName","removeFromGroup","index","catch","_isFitFromResource","_initMapState","qmsId","addQmsBaseLayer","osm","addOsmBaseLayer","layerFitAllowed","webmapId","_emitStatusEvent","qmsLayerName","qmsLayerOptions","identifyFeature","featureCount","_prepareToIdentify","sourceType","values","identFunc","selectable","isLayerVisible","call","getIds","getCenter","getZoom","metresPerPixel","abs","pow","selectPromise","companyLogoOptions","logo","getIcon","isPaint","paint","toString","isPaintCallback","expressions","field","match","lookup","cases","featureExpression","defValue","expression","expressionFun","createPropertyExpressionCb","excludeExpressionList","preparePaint","defaultPaint","getPaintFunctions","newPaint","getPaintFunction","getPaint","isPropertiesPaint","mask","paintsFilters","from","updatePaintOptionFromCallback","withExpression","p_","val","fromCb","createExpressionCallback","fill","stroke","strokeColor","strokeOpacity","color","fillColor","fillOpacity","like","iLike","re","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","ilike","checkIfPropertyFilter","featureFilter","$id","filterFunction","operation","operationExec","value_","cleanField","every","alias","tms","loadJson","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","er","open","send","createQmsAdapter","webMapAdapter","QmsAdapter","protocol","location","serviceUrl","y_origin_top","attribution","copyright_text","z_max","z_min","updateQmsOptions","origin_url","originUrl","submodules","m","subdomains","utils"],"mappings":"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","file":"main-7db0a515a224d2b.js","sourcesContent":["import { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy',\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions,\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach((x) => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions,\n  ResourceNgwLayerOptions,\n} from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector,\n): Promise<number> {\n  const resource = (options as ResourceNgwLayerOptions).resource;\n  const item = resource as ResourceItem;\n\n  // @ts-ignore @deprecated\n  let keyname = (options as KeynamedNgwLayerOptions).keyname;\n  // @ts-ignore @deprecated\n  let resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else if (\n      item.resource &&\n      item.resource !== undefined &&\n      'resmeta' in item\n    ) {\n      resourceId = (resource as ResourceItem).resource.id;\n    } else {\n      resourceId = await resourceIdFromLayerOptions(\n        resource as ResourceNgwLayerOptions,\n        connector,\n      );\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResource(keyname);\n    if (resourceItem) {\n      resourceId = resourceItem.resource.id;\n    }\n  }\n  return resourceId;\n}\n","import { Geometry, GeoJsonProperties } from 'geojson';\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport {\n  FeatureRequestParams,\n  NgwFeatureItemResponse,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\nimport {\n  createGeoJsonFeature,\n  FEATURE_REQUEST_PARAMS,\n  updateItemRequestParam,\n} from './featureLayerUtils';\n\nexport function fetchNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & NgwFeatureRequestOptions,\n): CancelablePromise<NgwFeatureItemResponse<P, G>> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  updateItemRequestParam(params, options);\n  return options.connector\n    .get('feature_layer.feature.item', null, {\n      id: options.resourceId,\n      fid: options.featureId,\n      ...params,\n    })\n    .then((resp) => {\n      return {\n        ...resp,\n        toGeojson: () => {\n          if (resp.geom) {\n            return CancelablePromise.resolve(createGeoJsonFeature<G, P>(resp));\n          } else {\n            return fetchNgwLayerItem({\n              ...options,\n              geom: true,\n              fields: null,\n              extensions: null,\n            }).then((onlyGeomItem) => {\n              const geom = onlyGeomItem.geom;\n              return createGeoJsonFeature<G, P>({ ...resp, geom });\n            });\n          }\n        },\n      } as NgwFeatureItemResponse<P, G>;\n    });\n}\n","import { Geometry, Feature } from 'geojson';\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport { NgwFeatureRequestOptions } from '../interfaces';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nexport function fetchNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & NgwFeatureRequestOptions,\n): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerItem<G, P>(options).then((item) => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n","import {\n  Geometry,\n  Feature,\n  FeatureCollection,\n  GeoJsonProperties,\n} from 'geojson';\n\nimport NgwConnector, {\n  FeatureItem,\n  RequestItemAdditionalParams,\n  FeatureLayerField,\n} from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  checkIfPropertyFilter,\n  PropertyFilter,\n  PropertiesFilter,\n} from '@nextgis/properties-filter';\nimport {\n  FeatureRequestParams,\n  GetNgwLayerItemsOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\nimport { defined, JsonMap } from '@nextgis/utils';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerFeatureCollection } from './fetchNgwLayerFeatureCollection';\nimport { fetchNgwLayerItems } from './fetchNgwLayerItems';\n\nexport const FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson',\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry,\n  };\n  return feature;\n}\n\n/**\n * @deprecated use {@link fetchNgwLayerItem} instead\n */\nexport function getNgwLayerItem<\n  G extends Geometry = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & NgwFeatureRequestOptions,\n): CancelablePromise<FeatureItem<P, G>> {\n  return fetchNgwLayerItem(options);\n}\n\n/**\n * @deprecated use {@link fetchNgwLayerFeature} instead\n */\nexport function getNgwLayerFeature<\n  G extends Geometry = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & NgwFeatureRequestOptions,\n): CancelablePromise<Feature<G, P>> {\n  return fetchNgwLayerFeature(options);\n}\n\n/**\n * @deprecated use {@link fetchNgwLayerFeatures} instead\n */\n\nexport function getNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any }\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & NgwFeatureRequestOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatureCollection(options);\n}\n\n/**\n * @deprecated use {@link fetchNgwLayerItems} instead\n */\nexport function getNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap\n>(\n  options: GetNgwLayerItemsOptions & NgwFeatureRequestOptions<P>,\n): CancelablePromise<FeatureItem<P, G>[]> {\n  return fetchNgwLayerItems(options);\n}\n\nexport function updateItemRequestParam(\n  params: FeatureRequestParams,\n  options: NgwFeatureRequestOptions,\n): void {\n  const { extensions, geom, fields, srs } = options;\n  params.extensions = extensions ? extensions.join(',') : '';\n  if (fields !== undefined) {\n    params.fields = Array.isArray(fields) ? fields.join(',') : '';\n  }\n  if (geom !== undefined) {\n    params.geom = geom ? 'yes' : 'no';\n    if (!geom) {\n      delete params.srs;\n      delete params.geom_format;\n    }\n  }\n  if (defined(srs)) {\n    params.srs = srs;\n  }\n}\n\nexport function idFilterWorkAround<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap\n>(options: {\n  filterById: PropertyFilter;\n  resourceId: number;\n  connector: NgwConnector;\n}): CancelablePromise<FeatureItem<P, G>[]> {\n  const value = options.filterById[2];\n  const featureIds: number[] =\n    typeof value === 'number'\n      ? [value]\n      : value.split(',').map((x: string) => Number(x));\n  if (options.filterById[1] !== 'eq' && options.filterById[1] !== 'in') {\n    throw new Error(\n      'Unable to filter by object id. Except `eq` or `in` operator',\n    );\n  }\n  const promises: Promise<FeatureItem<P, G>>[] = featureIds.map((featureId) => {\n    return fetchNgwLayerItem<G, P>({\n      connector: options.connector,\n      resourceId: options.resourceId,\n      featureId,\n    });\n  });\n  return CancelablePromise.all(promises);\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nexport function createFeatureFieldFilterQueries<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any }\n>(\n  opt: Required<GetNgwLayerItemsOptions> & NgwFeatureRequestOptions<P>,\n  _queries: CancelablePromise<FeatureItem<P, G>[]>[] = [],\n  _parentAllParams: [string, any][] = [],\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const { filters, connector, resourceId } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter((x) => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    return [`fld_${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach((f) => {\n      if (f[0] === 'id') {\n        _queries.push(\n          idFilterWorkAround({ filterById: f, connector, resourceId }),\n        );\n      }\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)],\n          }),\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f,\n          },\n          _queries,\n          [..._parentAllParams],\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filterById = filters_.find((x) => x[0] === 'id');\n    if (filterById) {\n      _queries.push(idFilterWorkAround({ filterById, connector, resourceId }));\n    } else {\n      const filters: [string, any][] = [];\n      const propertiesFilterList: PropertiesFilter[] = [];\n      filters_.forEach((f) => {\n        if (checkIfPropertyFilter(f)) {\n          filters.push(createParam(f));\n        } else {\n          propertiesFilterList.push(f);\n        }\n      });\n\n      if (propertiesFilterList.length) {\n        propertiesFilterList.forEach((x) => {\n          createFeatureFieldFilterQueries(\n            {\n              ...opt,\n              filters: x,\n            },\n            _queries,\n            [..._parentAllParams, ...filters],\n          );\n        });\n      } else {\n        _queries.push(\n          fetchNgwLayerItemsRequest<G, P>({\n            ...opt,\n            paramList: [..._parentAllParams, ...filters],\n          }),\n        );\n      }\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    const offset = opt.offset !== undefined ? opt.offset : 0;\n    const limit = opt.limit !== undefined ? opt.limit : items.length;\n    if (opt.offset || opt.limit) {\n      return items.splice(offset, limit);\n    }\n    return items;\n  });\n}\n\nexport function fetchNgwLayerItemsRequest<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any }\n>(\n  options: GetNgwLayerItemsOptions &\n    NgwFeatureRequestOptions<P> & { paramList?: [string, any][] },\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS,\n  };\n  const {\n    connector,\n    limit,\n    offset,\n    intersects,\n    orderBy,\n    resourceId,\n    paramList,\n  } = options;\n  if (limit) {\n    params.limit = limit;\n  }\n  if (offset) {\n    params.offset = offset;\n  }\n  // TODO: fix type for options\n  updateItemRequestParam(params, options as { [field: string]: any });\n\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  if (intersects) {\n    params.intersects = intersects;\n  }\n\n  if (paramList) {\n    params.paramList = paramList;\n  }\n\n  return connector.get('feature_layer.feature.collection', null, {\n    id: resourceId,\n    ...params,\n  }) as CancelablePromise<FeatureItem<P, G>[]>;\n}\n\nexport function prepareFieldsToNgw<T extends GeoJsonProperties>(\n  item: T,\n  resourceFields: Pick<FeatureLayerField, 'keyname' | 'datatype'>[],\n): Record<keyof T, any> {\n  const fields = {} as Record<keyof T, any>;\n  if (item) {\n    resourceFields.forEach((x) => {\n      if (x.keyname in item) {\n        const keyname = x.keyname;\n        const prop = item[keyname];\n        let value: any;\n        if (prop !== undefined) {\n          if (x.datatype === 'STRING') {\n            value = prop ? String(prop) : null;\n            // TODO: remove after v 3.0.0. For backward compatibility\n            if (value === 'null') {\n              value = null;\n            }\n          } else if (x.datatype === 'BIGINT' || x.datatype === 'INTEGER') {\n            value = typeof prop === 'string' ? parseInt(prop, 10) : prop;\n          } else if (x.datatype === 'REAL') {\n            value = typeof prop === 'string' ? parseFloat(prop) : prop;\n          } else if (x.datatype === 'BOOLEAN') {\n            value =\n              typeof prop === 'boolean' || typeof prop === 'number'\n                ? Number(!!prop)\n                : null;\n          } else if (x.datatype === 'DATE' || x.datatype === 'DATETIME') {\n            let dt: Date | undefined;\n            if (typeof prop === 'object' && !((prop as any) instanceof Date)) {\n              value = prop;\n            } else {\n              if ((prop as any) instanceof Date) {\n                dt = prop as any;\n              } else {\n                const parse = Date.parse(String(prop));\n                if (parse) {\n                  dt = new Date(parse);\n                }\n              }\n              if (dt) {\n                value = {\n                  year: dt.getFullYear(),\n                  month: dt.getMonth(),\n                  day: dt.getDay(),\n                };\n                if (x.datatype === 'DATETIME') {\n                  value.hour = dt.getHours();\n                  value.minute = dt.getMinutes();\n                  value.second = dt.getSeconds();\n                }\n              }\n            }\n          }\n        }\n        fields[keyname as keyof T] = value ?? null;\n      }\n    });\n  }\n  return fields;\n}\n","import { Geometry } from 'geojson';\nimport { FeatureItem } from '@nextgis/ngw-connector';\nimport { propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  GetNgwLayerItemsOptions,\n  NgwFeatureRequestOptions,\n} from '../interfaces';\nimport {\n  createFeatureFieldFilterQueries,\n  fetchNgwLayerItemsRequest,\n} from './featureLayerUtils';\n\nexport function fetchNgwLayerItems<\n  G extends Geometry = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any }\n>(\n  options: GetNgwLayerItemsOptions & NgwFeatureRequestOptions<P>,\n): CancelablePromise<FeatureItem<P, G>[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({\n      ...options,\n      filters,\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  } else {\n    return fetchNgwLayerItemsRequest<G, P>(options).then((data) => {\n      if (filters) {\n        // client-side filter check\n        return data.filter((y) => {\n          const fields = y.fields;\n          if (fields) {\n            propertiesFilter(fields, filters);\n          }\n        });\n      }\n      return data;\n    }) as CancelablePromise<FeatureItem<P, G>[]>;\n  }\n}\n","import { Geometry, FeatureCollection } from 'geojson';\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { PropertiesFilter } from '@nextgis/properties-filter';\nimport { NgwFeatureRequestOptions } from '../interfaces';\n\nimport { fetchNgwLayerFeatures } from './fetchNgwLayerFeatures';\n\nexport function fetchNgwLayerFeatureCollection<\n  G extends Geometry | null = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any }\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & NgwFeatureRequestOptions<P>,\n): CancelablePromise<FeatureCollection<G, P>> {\n  return fetchNgwLayerFeatures<G, P>(options).then((features) => {\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features,\n    };\n    return featureCollection;\n  });\n}\n","import { Geometry, Feature } from 'geojson';\n\nimport NgwConnector, { FeatureItem } from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { PropertiesFilter } from '@nextgis/properties-filter';\nimport { NgwFeatureRequestOptions } from '../interfaces';\nimport { fetchNgwLayerItems } from './fetchNgwLayerItems';\nimport { createGeoJsonFeature } from './featureLayerUtils';\n\nexport function fetchNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends { [field: string]: any } = { [field: string]: any }\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & NgwFeatureRequestOptions<P>,\n): CancelablePromise<Feature<G, P>[]> {\n  return fetchNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach((y) => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    return features;\n  });\n}\n","import { LngLatBoundsArray } from '@nextgis/webmap';\nimport NgwConnector, {\n  WebmapResource,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\n\nexport function getNgwWebmapExtent(\n  webmap: WebmapResource,\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function fetchNgwLayerExtent(\n  id: number,\n  connector: NgwConnector,\n): Promise<LngLatBoundsArray | undefined> {\n  return connector.get('layer.extent', null, { id }).then((resp) => {\n    if (resp) {\n      const { maxLat, maxLon, minLat, minLon } = resp.extent;\n      const extenrArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n      return extenrArray;\n    }\n  });\n}\n\nexport async function fetchNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n): Promise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return getNgwWebmapExtent(item.webmap);\n  } else {\n    const resource = item.resource;\n    if (resource.cls && resource.cls.indexOf('style') !== -1) {\n      return connector.getResource(resource.parent.id).then((res) => {\n        if (res) {\n          return fetchNgwLayerExtent(res.resource.id, connector);\n        }\n      });\n    } else {\n      return fetchNgwLayerExtent(resource.id, connector);\n    }\n  }\n}\n\n/**\n * @deprecated use {@link fetchNgwLayerExtent} instead\n */\nexport function getNgwLayerExtent(\n  id: number,\n  connector: NgwConnector,\n): Promise<LngLatBoundsArray | undefined> {\n  return fetchNgwLayerExtent(id, connector);\n}\n/**\n * @deprecated use {@link fetchNgwResourceExtent} instead\n */\nexport async function getNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector,\n): Promise<LngLatBoundsArray | undefined> {\n  return fetchNgwResourceExtent(item, connector);\n}\n","import { EventEmitter } from 'events';\nimport {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  FilterOptions,\n  LayerAdapter,\n} from '@nextgis/webmap';\nimport { debounce, degrees2meters } from '@nextgis/utils';\nimport { PropertiesFilter, propertiesFilter } from '@nextgis/properties-filter';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { vectorLayerGeomToPaintTypeAlias } from '../utils/utils';\nimport { createPopupContent } from '../utils/createPopupContent';\nimport { getLayerFilterOptions } from '../utils/getLayerFilterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { NgwLayerOptions, GetClassAdapterOptions } from '../interfaces';\nimport { fetchNgwLayerFeatureCollection } from '../utils/fetchNgwLayerFeatureCollection';\nimport { fetchNgwResourceExtent } from '../utils/fetchNgwExtent';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  opt: GetClassAdapterOptions,\n): Promise<Type<VectorLayerAdapter>> {\n  const { webMap, connector, item } = opt;\n  const addLayerOptionsPriority =\n    opt.addLayerOptionsPriority !== undefined\n      ? opt.addLayerOptionsPriority\n      : true;\n  const options = opt.layerOptions as NgwLayerOptions<'GEOJSON'>;\n  const GeoJsonAdapter =\n    (opt.Adapter as Type<VectorLayerAdapter>) ||\n    (webMap.mapAdapter.layerAdapters.GEOJSON as Type<VectorLayerAdapter>);\n\n  let _dataPromise: CancelablePromise<any> | undefined;\n  const _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (\n    options.adapterOptions &&\n    options.adapterOptions.popupOptions &&\n    options.adapterOptions.popupOptions.fromProperties\n  ) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const geoJsonAdapterCb = async (\n    filters?: PropertiesFilter,\n    opt?: FilterOptions,\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: opt };\n    _dataPromise = fetchNgwLayerFeatureCollection({\n      resourceId,\n      filters,\n      connector,\n      ...opt,\n      // strict restriction on loading data from large layers\n      limit: opt?.limit !== undefined ? opt.limit : 3000,\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  class NgwGeoJsonAdapter extends GeoJsonAdapter {\n    emitter = new EventEmitter();\n    _count?: number;\n    __onMapMove?: () => void;\n    __onMapMoveStart?: () => void;\n    __enableMapMoveListener?: (e: LayerAdapter) => void;\n    __disableMapMoveListener?: (e: LayerAdapter) => void;\n\n    async addLayer(opt_: GeoJsonAdapterOptions) {\n      let needUpdate = !opt_.data;\n      const waitFullLoad =\n        opt_.waitFullLoad !== undefined ? opt_.waitFullLoad : true;\n      if (options.id !== undefined) {\n        opt_.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt_.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (options.adapterOptions) {\n        // TODO: remove addLayerOptionsPriority options/\n        // in some cases, addLayer options must be used,\n        // but in others factory method options needs first\n        if (addLayerOptionsPriority) {\n          opt_ = {\n            ...options.adapterOptions,\n            ...opt_,\n          };\n        } else {\n          opt_ = {\n            ...opt_,\n            ...options.adapterOptions,\n          };\n        }\n      }\n      if (opt_.data && Object.keys(opt_.data).length === 0) {\n        opt_.data = undefined;\n        needUpdate = false;\n      }\n      const layer = super.addLayer(opt_);\n      this.options.strategy = opt_.strategy || undefined;\n\n      _lastFilterArgs = {\n        filters: opt_.propertiesFilter,\n        options: getLayerFilterOptions(opt_),\n      };\n      let updatePromise: Promise<any> | undefined;\n      if (needUpdate) {\n        updatePromise = this.updateLayer();\n      }\n      if (waitFullLoad && updatePromise) {\n        await updatePromise;\n      }\n      if (this.options.strategy === 'BBOX') {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    getExtent() {\n      const hasData = this.getLayers && this.getLayers().length;\n      if (this.options.strategy === 'BBOX' || hasData) {\n        return fetchNgwResourceExtent(item, connector);\n      } else {\n        if (super.getExtent) {\n          return super.getExtent();\n        }\n      }\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      this.__onMapMoveStart = undefined;\n      abort();\n    }\n\n    getCount() {\n      if (this._count !== undefined) {\n        return this._count;\n      }\n      return connector\n        .get('feature_layer.feature.count', null, {\n          id: resourceId,\n        })\n        .then((resp) => {\n          if (resp) {\n            this._count = resp.total_count;\n          }\n        });\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy === 'BBOX') {\n        await webMap.onLoad('create');\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = this._getMapBbox();\n      }\n      if (removed) {\n        return;\n      }\n      try {\n        const data = await geoJsonAdapterCb(\n          filterArgs.filters,\n          filterArgs.options,\n        );\n        await webMap.setLayerData(this, data);\n        this.emitter.emit('updated');\n      } catch (er) {\n        if (er.name !== 'CancelError') {\n          throw er;\n        }\n      }\n      if (super.updateLayer) {\n        super.updateLayer();\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter((e) => {\n          if (e.feature && e.feature.properties) {\n            return propertiesFilter(e.feature.properties, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await geoJsonAdapterCb(filters, opt);\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    _addBboxEventListener() {\n      this.__enableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = (e: LayerAdapter) => {\n        if (e === this) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener(this);\n    }\n\n    _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      this.__onMapMoveStart = abort;\n      webMap.emitter.on('movestart', this.__onMapMoveStart);\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.removeListener('moveend', this.__onMapMove);\n      }\n      if (this.__onMapMoveStart) {\n        webMap.emitter.removeListener('movestart', this.__onMapMoveStart);\n      }\n    }\n\n    _getMapBbox(): string | undefined {\n      const bounds = webMap.getBounds();\n      if (bounds) {\n        const [s, w, n, e] = bounds;\n        const polygon = [\n          [s, w],\n          [n, w],\n          [n, e],\n          [s, e],\n          [s, w],\n        ].map(([lng, lat]) => {\n          const [x, y] = degrees2meters(lng, lat);\n          return x + ' ' + y;\n        });\n        return `POLYGON((${polygon.join(', ')}))`;\n      }\n    }\n  };\n\n  return NgwGeoJsonAdapter;\n}\n","import { Feature } from 'geojson';\nimport { ResourceItem } from '@nextgis/ngw-connector';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem,\n): HTMLElement | string {\n  if (__BROWSER__) {\n    const element = document.createElement('div');\n    if (item && item.feature_layer) {\n      item.feature_layer.fields.forEach((x) => {\n        if (x.grid_visibility) {\n          const value = feature.properties && feature.properties[x.keyname];\n          if (value) {\n            const propElem = document.createElement('div');\n            element.appendChild(propElem);\n            propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n          }\n        }\n      });\n    } else if (feature.properties) {\n      for (const p in feature.properties) {\n        const propElem = document.createElement('div');\n        element.appendChild(propElem);\n        propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n      }\n    }\n    return element;\n  } else {\n    return '';\n  }\n}\n","import {\n  WebMap,\n  RasterAdapterOptions,\n  ImageAdapterOptions,\n  WmsAdapterOptions,\n} from '@nextgis/webmap';\n\nimport { NgwLayerOptions, TileNoData } from '../interfaces';\nimport { updateImageParams } from './utils';\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n): RasterAdapterOptions | ImageAdapterOptions | undefined {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = options.resource;\n  const nd: TileNoData = options.tileNoData ? options.tileNoData : 200;\n\n  if (typeof resourceId === 'number') {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          params: { resource: resourceId, nd: nd },\n          updateWmsParams: (params: Record<string, any>) =>\n            updateImageParams({ nd: nd, ...params }, resourceId),\n        } as ImageAdapterOptions;\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      const adapterOptions = options.adapterOptions as WmsAdapterOptions;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: adapterOptions && adapterOptions.layers,\n        headers: options.headers,\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url,\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'MODEL_3D') {\n      url = baseUrl + `/api/component/model_3d/${resourceId}/data.glb`;\n      return { url };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId +\n        '&nd=' +\n        nd;\n      return { url, adapter };\n    }\n  } else if (resourceId !== undefined) {\n    throw new Error(\n      'Option `resource` must be number, not ' + typeof resourceId,\n    );\n  } else {\n    console.log('Option `resource` not set');\n  }\n}\n","import {\n  ResourceAdapter,\n  NgwLayerAdapterType,\n  GetClassAdapterOptions,\n} from '../interfaces';\nimport { MainLayerAdapter, Type, ImageAdapterOptions } from '@nextgis/webmap';\nimport { defined } from '@nextgis/utils';\nimport { ResourceItem, ResourceCls } from '@nextgis/ngw-connector';\n\nimport { getLayerAdapterOptions } from '../utils/getLayerAdapterOptions';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nexport async function createRasterAdapter({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  const resourceCls = item.resource.cls;\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    tmsclient_layer: 'IMAGE',\n  };\n  let adapter =\n    layerOptions.adapter ||\n    (resourceCls && clsAdapterAlias[resourceCls]) ||\n    'IMAGE';\n  if (adapter !== undefined) {\n    layerOptions.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const adapterClass = webMap.mapAdapter.layerAdapters[\n    adapter\n  ] as Type<MainLayerAdapter>;\n  if (adapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(\n      layerOptions,\n      connector,\n    );\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem = item;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(\n          layerOptions,\n          webMap,\n          connector.options.baseUrl || '',\n        );\n        if (opt) {\n          const layerAdapterOptions: ImageAdapterOptions = {\n            ...opt,\n            setViewDelay: layerOptions.adapterOptions?.setViewDelay,\n            params: { resource: resourceId },\n            // @deprecated\n            layers: String(resourceId),\n            resourceId: resourceId,\n          };\n          if (\n            layerOptions.adapterOptions &&\n            defined(layerOptions.adapterOptions.setViewDelay)\n          ) {\n            layerAdapterOptions.setViewDelay =\n              layerOptions.adapterOptions.setViewDelay;\n          }\n          this.options = { ...this.options, ...layerAdapterOptions };\n          // if (__DEV__) {\n          //   Object.defineProperty(this.options, 'layers', {\n          //     get: () => {\n          //       console.warn('Do not use `layers` in ImageAdapterOptions');\n          //       return String(resourceId);\n          //     },\n          //   });\n          //   Object.defineProperty(this.options, 'resourceId', {\n          //     get: () => {\n          //       console.warn('Do not use `resourceId` in ImageAdapterOptions');\n          //       return resourceId;\n          //     },\n          //   });\n          // }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (id) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","import { EventEmitter } from 'events';\nimport { ItemOptions, Item } from '@nextgis/item';\nimport { treeSome } from '@nextgis/tree';\nimport {\n  WebMap,\n  LayerAdapter,\n  LayerAdapterDefinition,\n  ImageAdapterOptions,\n} from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { objectAssign } from '@nextgis/utils';\n\nimport { setScaleRatio } from './utils/utils';\nimport { TreeGroup, TreeLayer, TreeItem } from './interfaces';\n\nexport class NgwWebmapItem extends Item<ItemOptions> {\n  static GetAdapterFromLayerType: {\n    [layerType: string]: (\n      item: TreeItem,\n      options: any,\n      webMap: WebMap,\n      connector?: NgwConnector,\n    ) => LayerAdapterDefinition;\n  } = {};\n\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: NgwWebmapItem): boolean {\n          if (item) {\n            if (\n              item.item.item_type === 'group' ||\n              item.item.item_type === 'root'\n            ) {\n              return treeSome<TreeGroup | TreeLayer>(\n                item.item,\n                (i) => ('layer_enabled' in i ? i.layer_enabled : false),\n                (i) => (i as TreeGroup).children,\n              );\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            }\n            // else if (item.item.item_type === 'root') {\n            //   return true;\n            // }\n          }\n          return false;\n        },\n        onSet(\n          value: boolean,\n          options?: Record<string, any>,\n          item?: NgwWebmapItem,\n        ): void {\n          if (item && item.item.item_type === 'layer') {\n            if (item.layer) {\n              if (value) {\n                item.webMap.showLayer(item.layer);\n              } else {\n                item.webMap.hideLayer(item.layer);\n              }\n            }\n            item.item['layer_enabled'] = value;\n          }\n        },\n      },\n    ],\n  };\n\n  item: TreeGroup | TreeLayer;\n  connector?: NgwConnector;\n  layer?: LayerAdapter;\n  readonly emitter = new EventEmitter();\n\n  protected _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n    noInit?: boolean,\n  ) {\n    super({ ...NgwWebmapItem.options, ...options });\n    if (connector) {\n      this.connector = connector;\n    }\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n    this.initProperties();\n    if (!noInit) {\n      this._init(item);\n    }\n  }\n\n  static async create(\n    webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    connector?: NgwConnector,\n    parent?: NgwWebmapItem,\n  ): Promise<NgwWebmapItem> {\n    const ngwWebmapItem = new NgwWebmapItem(\n      webMap,\n      item,\n      options,\n      connector,\n      parent,\n      true,\n    );\n    await ngwWebmapItem._init(item);\n    return ngwWebmapItem;\n  }\n\n  initItem(item: TreeGroup | TreeLayer): Promise<void> {\n    const i = item;\n    const options: Partial<ImageAdapterOptions> = this.getItemOptions(item);\n    const setNewLayer = (l: LayerAdapter) => {\n      i._layer = l;\n      this.layer = l;\n      const enabled = this.properties.get('visibility');\n      if (enabled) {\n        this.properties.set('visibility', true);\n      }\n\n      if (options.opacity !== undefined) {\n        this.webMap.setLayerOpacity(l, options.opacity);\n      }\n    };\n\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        this.getChildren(item).forEach((x) => {\n          const children = new NgwWebmapItem(\n            this.webMap,\n            x,\n            this.options,\n            this.connector,\n            this,\n          );\n          this.tree.addChild(children);\n        });\n      }\n      return Promise.resolve();\n    } else {\n      let adapter: LayerAdapterDefinition | undefined;\n      if (item.item_type === 'layer') {\n        adapter = item.adapter || item.layer_adapter.toUpperCase();\n      } else if (NgwWebmapItem.GetAdapterFromLayerType[item.item_type]) {\n        const getAdapter =\n          NgwWebmapItem.GetAdapterFromLayerType[item.item_type];\n        adapter = getAdapter(item, options, this.webMap, this.connector);\n      }\n\n      if (adapter) {\n        return this.webMap.addLayer(adapter, options).then((newLayer) => {\n          setNewLayer(newLayer);\n        });\n      }\n    }\n    if (item._layer) {\n      return Promise.resolve(setNewLayer(item._layer));\n    }\n    return Promise.reject('No layer added');\n  }\n\n  bringToFront(): void {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      // console.log(this.item);\n    }\n  }\n\n  protected getItemOptions(item: TreeGroup | TreeLayer): Record<string, any> {\n    const transparency = item.item_type === 'layer' && item.layer_transparency;\n    const opacity =\n      typeof transparency === 'number' ? (100 - transparency) / 100 : undefined;\n    const options: Partial<ImageAdapterOptions> = {\n      visibility: false,\n      headers: this.options.headers,\n      crossOrigin: this.options.crossOrigin,\n      setViewDelay: this.options.setViewDelay,\n      params: { resource: this.item.resourceId },\n    };\n    if (this.options.order) {\n      const subOrder =\n        this.options.drawOrderEnabled && 'draw_order_position' in item\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n\n      // 9 > 0009, 11 > 0011\n      // TODO: find better way to set order in sub level, not limit by 1000 layer in group\n      const subLevel = String(subOrder).padStart(4, '0');\n      options.order = Number((this.options.order | 0) + '.' + subLevel);\n    }\n    if (item.item_type === 'layer') {\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      objectAssign(options, {\n        updateWmsParams: item.updateWmsParams,\n        url: item.url,\n        headers: this.options.headers,\n        ratio: this.options.ratio,\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n      });\n    }\n    if (opacity !== undefined) {\n      options.opacity = opacity;\n    }\n    return options;\n  }\n\n  protected getChildren(item: TreeGroup): (TreeGroup | TreeLayer)[] {\n    return [...item.children].reverse();\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private _init(item: TreeGroup | TreeLayer) {\n    this.initItem(item).then(() => {\n      this.emitter.emit('init');\n    });\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import { WebMap, Type, VectorAdapterLayerType } from '@nextgis/webmap';\nimport NgwConnector, { GeometryType } from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  NgwWebmapAdapterOptions,\n  ResourceAdapter,\n} from '../interfaces';\nimport { createAsyncAdapter } from '../adapters/createAsyncAdapter';\nimport { NgwWebmapLayerAdapter } from '../NgwWebmapLayerAdapter';\n\nexport function updateImageParams(\n  params: Record<string, any>,\n  resourceId: number,\n): Record<string, any> {\n  const { bbox, width, height, nd } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now(),\n    nd,\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'point',\n  LINESTRING: 'line',\n  POLYGON: 'polygon',\n  MULTIPOINT: 'point',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'polygon',\n  POINTZ: 'point',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'polygon',\n  MULTIPOINTZ: 'point',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'polygon',\n};\n\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, connector);\n}\n\nexport interface ExtendNgwWebmapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendNgwWebmapLayerAdapter(\n  opt: ExtendNgwWebmapLayerAdapterOptions,\n): Type<NgwWebmapLayerAdapter> {\n  class A extends NgwWebmapLayerAdapter {\n    constructor(map: any, options: NgwWebmapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth(): number {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number): number {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 0): number {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n\n  const centerLat = lat;\n  const crsScale =\n    (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n  const zoom = getZoomFromScale(crsScale);\n  return zoom;\n\n  // return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { Feature, Point } from 'geojson';\nimport { createGeoJsonFeature, fetchNgwLayerItem } from '@nextgis/ngw-kit';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type NgwConnector from '@nextgis/ngw-connector';\nimport type { FeatureItem } from '@nextgis/ngw-connector';\nimport type { LngLatBoundsArray } from '@nextgis/utils';\n\ninterface BookmarkItemOptions {\n  connector: NgwConnector;\n  resourceId: number;\n  item: FeatureItem;\n  labelField?: string;\n}\n\nexport class BookmarkItem {\n  readonly name: string;\n  readonly resourceId: number;\n  readonly item: FeatureItem;\n\n  private _extent?: LngLatBoundsArray;\n\n  constructor(private options: BookmarkItemOptions) {\n    this.resourceId = options.resourceId;\n    const item = options.item;\n    this.item = item;\n    if (options.labelField && item.fields) {\n      this.name = item.fields[options.labelField];\n    } else {\n      this.name = String(item.id);\n    }\n  }\n\n  extent(): CancelablePromise<LngLatBoundsArray> {\n    if (this._extent) {\n      return CancelablePromise.resolve(this._extent);\n    }\n    return this.options.connector\n      .get('feature_layer.feature.item_extent', null, {\n        id: this.resourceId,\n        fid: this.item.id,\n      })\n      .then((resp) => {\n        const { minLat, minLon, maxLat, maxLon } = resp.extent;\n        const lonLat = [minLon, minLat, maxLon, maxLat];\n        this._extent = lonLat;\n        return lonLat;\n      });\n  }\n\n  geoJson(): CancelablePromise<Feature<Point, any>> {\n    if (this.item.geom) {\n      return CancelablePromise.resolve(createGeoJsonFeature(this.item));\n    } else {\n      return fetchNgwLayerItem({\n        resourceId: this.resourceId,\n        featureId: this.item.id,\n        connector: this.options.connector,\n        geom: true,\n        fields: null,\n        extensions: null,\n      }).then((onlyGeomItem) => {\n        const geom = onlyGeomItem.geom;\n        this.item.geom = geom;\n        return createGeoJsonFeature(this.item);\n      });\n    }\n  }\n}\n","import { EventEmitter } from 'events';\n\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { fixUrlStr } from '@nextgis/utils';\nimport { fetchNgwLayerItems } from '@nextgis/ngw-kit';\n\nimport { NgwWebmapItem } from './NgwWebmapItem';\nimport { createOnFirstShowNgwAdapter } from './adapters/createOnFirstShowNgwAdapter';\nimport { getLayerAdapterOptions } from './utils/getLayerAdapterOptions';\nimport { getNgwWebmapExtent } from './utils/fetchNgwExtent';\nimport { updateImageParams } from './utils/utils';\nimport { BookmarkItem } from './BookmarkItem';\n\nimport type { Type } from '@nextgis/utils';\nimport type { ItemOptions } from '@nextgis/item';\nimport type StrictEventEmitter from 'strict-event-emitter-types';\nimport type {\n  ResourceItem,\n  WebmapResource,\n  BasemapWebmap,\n} from '@nextgis/ngw-connector';\nimport type {\n  WebMap,\n  LngLatBoundsArray,\n  RasterAdapterOptions,\n} from '@nextgis/webmap';\nimport type {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  NgwWebmapAdapterOptions,\n  NgwWebmapLayerAdapterEvents,\n  ResourceAdapter,\n} from './interfaces';\n\nexport class NgwWebmapLayerAdapter<M = any> implements ResourceAdapter<M> {\n  layer?: NgwWebmapItem;\n\n  NgwWebmapItem: Type<NgwWebmapItem> = NgwWebmapItem;\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  webmapClassName = 'webmap';\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwWebmapLayerAdapterEvents\n  > = new EventEmitter();\n  protected _extent?: LngLatBoundsArray;\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  constructor(public map: M, public options: NgwWebmapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: NgwWebmapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n    this.layer = await this._getWebMapLayerItem();\n    return this.layer;\n  }\n\n  removeLayer(): void {\n    const mapAdapter = this.options.webMap.mapAdapter;\n\n    this.getDependLayers().forEach((x) => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    // delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer(): void {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer(): void {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getNgwWebmapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<NgwWebmapItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  getBookmarksResourceId(): number | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return webmap.bookmark_resource.id;\n    }\n  }\n\n  fetchBookmarks(): CancelablePromise<BookmarkItem[]> {\n    const bookmarkResId = this.getBookmarksResourceId();\n    const connector = this.options.connector;\n    if (bookmarkResId) {\n      return connector.getResourceOrFail(bookmarkResId).then((item) => {\n        const labelField = item.feature_layer?.fields.find(\n          (x) => x.label_field,\n        );\n        const keyname = labelField && labelField.keyname;\n        return fetchNgwLayerItems({\n          connector,\n          resourceId: bookmarkResId,\n          geom: false,\n          fields: keyname ? [keyname] : undefined,\n        }).then((items) => {\n          const bookmarks: BookmarkItem[] = [];\n          for (const i of items) {\n            const bookmark = new BookmarkItem({\n              item: i,\n              resourceId: bookmarkResId,\n              labelField: keyname,\n              connector,\n            });\n            bookmarks.push(bookmark);\n          }\n          return bookmarks;\n        });\n      });\n    }\n    throw new Error(\n      'Webmap was not loaded correctly, it is impossible to extract bookmarks',\n    );\n  }\n\n  async getIdentificationIds(): Promise<number[]> {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => b.id - a.id);\n      deps.forEach((x) => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  protected async _getWebMapLayerItem(): Promise<NgwWebmapItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<NgwWebmapItem>((resolve) => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.setViewDelay = this.options.setViewDelay;\n          options.order = this.options.order;\n          options.ratio = this.options.ratio;\n          options.crossOrigin = this.options.crossOrigin;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new this.NgwWebmapItem(\n            this.options.webMap,\n            webmap.root_item,\n            options,\n            this.options.connector,\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    const data = await this.options.connector.getResource(id);\n    if (data) {\n      this.response = data;\n      const webmap = data[\n        this.webmapClassName as keyof ResourceItem\n      ] as WebmapResource;\n      if (data.basemap_webmap && data.basemap_webmap.basemaps.length) {\n        this._setBasemaps(data.basemap_webmap);\n      } else if (this.options.defaultBasemap) {\n        const webMap = this.options.webMap;\n        webMap.addBaseLayer('OSM', {\n          id: 'webmap-default-baselayer',\n          name: 'OpenStreetMap',\n        });\n      }\n      if (webmap) {\n        this._extent = [\n          webmap.extent_left,\n          webmap.extent_bottom,\n          webmap.extent_right,\n          webmap.extent_top,\n        ];\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    }\n  }\n\n  private _setBasemaps(baseWebmap: BasemapWebmap) {\n    const webMap = this.options.webMap;\n    let enabledAlreadySet = false;\n    baseWebmap.basemaps.forEach((x) => {\n      createOnFirstShowNgwAdapter({\n        webMap,\n        connector: this.options.connector,\n        item: x,\n        adapterOptions: { crossOrigin: this.options.crossOrigin },\n      }).then((adapter) => {\n        // to avoid set many basemaps on init\n        const visibility = enabledAlreadySet ? false : x.enabled;\n        webMap.addBaseLayer(adapter, {\n          name: x.display_name,\n          opacity: x.opacity,\n          visibility,\n        });\n        if (x.enabled) {\n          enabledAlreadySet = true;\n        }\n      });\n    });\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem,\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map((x) =>\n            this._updateItemsParams(x, webMap, data),\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.connector.options.baseUrl +\n            '/api/component/render/image',\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = (params) =>\n          updateImageParams(params, resourceId);\n        const adapter = item.layer_adapter.toUpperCase() as NgwLayerAdapterType;\n        const layerAdapterOptions = getLayerAdapterOptions(\n          {\n            adapter,\n            resource: resourceId,\n          },\n          webMap,\n          this.options.connector.options.baseUrl || '',\n        ) as RasterAdapterOptions;\n        item = {\n          ...item,\n          ...layerAdapterOptions,\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: NgwWebmapItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector.getResource(id).then((y) => {\n            if (y) {\n              const parentId = Number(y.resource.parent.id);\n              item.parentId = parentId;\n              return parentId;\n            }\n          });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter((x) => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n}\n","import {\n  WebMap,\n  Type,\n  MainLayerAdapter,\n  AdapterOptions,\n} from '@nextgis/webmap';\nimport NgwConnector, { BasemapWebmapItem } from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from './createAsyncAdapter';\n\ninterface CreateOnFirstShowAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  item: BasemapWebmapItem;\n  adapterOptions?: Record<string, any>;\n  idPrefix?: string;\n}\n\nexport async function createOnFirstShowNgwAdapter({\n  webMap,\n  connector,\n  item,\n  adapterOptions = {},\n  idPrefix = 'basemapwebmap',\n}: CreateOnFirstShowAdapterOptions): Promise<Type<MainLayerAdapter>> {\n  class OnFirstShowAdapter implements MainLayerAdapter {\n    options: AdapterOptions = {};\n    layer: MainLayerAdapter[] = [];\n    _removed = false;\n\n    addLayer() {\n      return this.layer;\n    }\n\n    removeLayer() {\n      this._removed = true;\n      this.layer.forEach((x) => webMap.removeLayer(x));\n    }\n\n    showLayer() {\n      this.options.visibility = true;\n      if (this.layer.length) {\n        this.layer.forEach((x) => {\n          webMap.showLayer(x);\n        });\n      } else {\n        createAsyncAdapter(\n          {\n            resource: item.resource_id,\n            adapterOptions: {\n              name: item.display_name,\n              opacity: item.opacity,\n            },\n          },\n          webMap,\n          connector,\n        ).then((Adapter) => {\n          if (Adapter) {\n            const adapter = new Adapter(webMap.mapAdapter.map, {\n              ...adapterOptions,\n              baselayer: false,\n            });\n            adapter.addLayer({}).then((baselayer: MainLayerAdapter) => {\n              adapter.options.baselayer = false;\n              Object.assign(adapter.options, adapterOptions);\n              adapter.id = idPrefix + '-' + item.resource_id;\n              adapter.layer = baselayer;\n              if (this._removed) {\n                webMap.removeLayer(adapter);\n              }\n              if (this.options.visibility) {\n                webMap.showLayer(adapter);\n              }\n              this.layer.push(adapter);\n            });\n          }\n        });\n      }\n    }\n\n    hideLayer() {\n      this.options.visibility = false;\n      if (this.layer) {\n        this.layer.forEach((x) => webMap.hideLayer(x));\n      }\n    }\n  }\n  return OnFirstShowAdapter;\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\nimport { fetchNgwResourceExtent } from './utils/fetchNgwExtent';\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  protected _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await fetchNgwResourceExtent(\n        this.item,\n        this.connector,\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem,\n} from '@nextgis/ngw-connector';\nimport { WebMap } from '@nextgis/webmap';\nimport { Type, applyMixins } from '@nextgis/utils';\n\nimport {\n  ResourceAdapter,\n  NgwLayerOptions,\n  GetClassAdapterCallback,\n  GetClassAdapterByType,\n  GetClassAdapter,\n  GetClassAdapterOptions,\n  ClassAdapter,\n  ResourceNgwLayerOptions,\n} from '../interfaces';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createNgwWebmapAdapter';\nimport { NgwResource } from '../NgwResource';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\nimport { createBasemapLayerAdapter } from './createBasemapLayerAdapter';\n\nexport const classAdapters: Record<string, GetClassAdapter> = {};\n\nconst supportCls: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'basemap_layer',\n  'vector_layer',\n  'raster_layer',\n  'webmap',\n  // in tms branch\n  'tmsclient_layer',\n];\n\nasync function createAdapterFromFirstStyle({\n  layerOptions,\n  webMap,\n  connector,\n  item,\n}: GetClassAdapterOptions) {\n  const parent = item.resource.id;\n  const childrenStyles = await connector.get('resource.collection', null, {\n    parent,\n  });\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...layerOptions, resource: firstStyle.resource.id },\n      webMap,\n      connector,\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector,\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: ClassAdapter | undefined;\n  let item: ResourceItem | undefined;\n  const adapterType = options.adapter;\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  if (resourceId) {\n    const resourceOptions = options as ResourceNgwLayerOptions;\n    const itemFromResOpt = resourceOptions.resource as ResourceItem;\n    if (\n      itemFromResOpt &&\n      itemFromResOpt.resource &&\n      itemFromResOpt.resource.id !== undefined\n    ) {\n      item = itemFromResOpt;\n    } else {\n      item = await connector.getResource(resourceId);\n    }\n    if (item) {\n      const cls = item.resource.cls;\n      const layerOptions: NgwLayerOptions = {\n        ...options,\n        resource: resourceId,\n      };\n\n      const adapterOptions: GetClassAdapterOptions = {\n        layerOptions,\n        webMap,\n        connector,\n        item,\n      };\n\n      if (supportCls.indexOf(cls) !== -1) {\n        if (cls === 'webmap') {\n          adapter = createWebMapAdapter(adapterOptions);\n        } else if (cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(adapterOptions);\n            } else {\n              return createAdapterFromFirstStyle(adapterOptions);\n            }\n          } else {\n            adapter = createGeoJsonAdapter(adapterOptions);\n          }\n        } else if (cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(adapterOptions);\n        } else if (cls === 'basemap_layer') {\n          adapter = createBasemapLayerAdapter(adapterOptions);\n        } else {\n          if (adapterType === 'GEOJSON') {\n            const parentItem = await connector.getResource(\n              item.resource.parent.id,\n            );\n            if (parentItem) {\n              const parentOptions: NgwLayerOptions = {\n                ...options,\n                resource: item.resource.parent.id,\n              };\n              adapter = createGeoJsonAdapter({\n                ...adapterOptions,\n                item: parentItem,\n                layerOptions: parentOptions,\n              });\n            }\n          } else {\n            adapter = createRasterAdapter(adapterOptions);\n          }\n        }\n      } else if (classAdapters[cls]) {\n        const getClassAdapter = classAdapters[cls];\n        let classAdapter: GetClassAdapterCallback | undefined;\n        if (adapterType && typeof classAdapter !== 'function') {\n          classAdapter = (getClassAdapter as GetClassAdapterByType)[\n            adapterType\n          ];\n        } else {\n          classAdapter = getClassAdapter as GetClassAdapterCallback;\n        }\n        if (classAdapter) {\n          adapter = classAdapter(adapterOptions);\n        }\n      } else {\n        throw `Resource class '${cls}' not yet supported.`;\n      }\n    } else {\n      throw 'Resource item is not found';\n    }\n  }\n\n  if (adapter) {\n    return adapter.then((x) => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        if (item) {\n          resourceAdapter.prototype.item = item;\n          resourceAdapter.prototype.resourceId = item.resource.id;\n          resourceAdapter.prototype.connector = connector;\n        }\n\n        applyMixins(resourceAdapter, [NgwResource], { replace: false });\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { Type } from '@nextgis/webmap';\nimport { GetClassAdapterOptions } from '../interfaces';\nimport { NgwWebmapLayerAdapter as NWLayerAdapter } from '../NgwWebmapLayerAdapter';\nimport { resourceIdFromLayerOptions } from '../utils/resourceIdFromLayerOptions';\n\nexport async function createWebMapAdapter({\n  layerOptions: options,\n  webMap,\n  connector,\n}: GetClassAdapterOptions): Promise<Type<NWLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class NgwWebmapLayerAdapter extends NWLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        url: '',\n        webMap,\n        resourceId,\n        connector,\n      });\n    }\n  };\n}\n","import { Type, MainLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { GetClassAdapterOptions } from '../interfaces';\n\nexport async function createBasemapLayerAdapter({\n  webMap,\n  item,\n}: GetClassAdapterOptions): Promise<Type<MainLayerAdapter> | undefined> {\n  if (item.basemap_layer) {\n    const qms = item.basemap_layer.qms;\n    const url = item.basemap_layer.url;\n    if (qms) {\n      const adapter = Promise.resolve(QmsKit.utils.createQmsAdapter(webMap));\n      adapter.then((x) => {\n        if (x && item) {\n          const qms_ = JSON.parse(qms);\n          x.prototype.qms = qms_;\n          x.prototype.baselayer = true;\n        }\n      });\n      return adapter;\n    } else if (url) {\n      const TileAdapter = webMap.mapAdapter.layerAdapters.TILE as Type<\n        MainLayerAdapter<any, any, TileAdapterOptions>\n      >;\n      if (TileAdapter) {\n        class BasemapTileAdapter extends TileAdapter {\n          async addLayer(opt: TileAdapterOptions) {\n            return super.addLayer({ ...opt, url });\n          }\n        }\n        return BasemapTileAdapter;\n      }\n    }\n  }\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport {\n  WebMap,\n  StarterKit,\n  Type,\n  LayerAdapterCreators,\n} from '@nextgis/webmap';\n\nimport { extendNgwWebmapLayerAdapter } from './utils/utils';\nimport { NgwWebmapLayerAdapter } from './NgwWebmapLayerAdapter';\nimport { classAdapters } from './adapters/createAsyncAdapter';\n\nimport {\n  NgwKitOptions,\n  NgwWebmapAdapterOptions,\n  GetClassAdapter,\n} from './interfaces';\n\nexport class NgwKit implements StarterKit {\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl || '';\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth,\n      });\n    }\n  }\n\n  static addClassAdapters(cls: string, adapter: GetClassAdapter): void {\n    classAdapters[cls] = adapter;\n  }\n\n  async onLoadSync(webMap: WebMap): Promise<NgwWebmapLayerAdapter | undefined> {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: Partial<NgwWebmapAdapterOptions> = {\n            resourceId: r,\n            connector: this.connector,\n            webMap,\n          };\n          const layer = (await webMap.addLayer(NgwWebmapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            pixelRadius: this.options.pixelRadius,\n            ...options,\n          })) as NgwWebmapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap)),\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<NgwWebmapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendNgwWebmapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl,\n    });\n  }\n}\n","import { fetchNgwLayerItem, IdentifyItemOptions } from '.';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport type { NgwFeatureItemResponse } from '.';\nimport type { GeoJsonObject, Geometry, Feature } from 'geojson';\nimport type {\n  FeatureItemExtensions,\n  FeatureLayerFields,\n  FeatureResource,\n  LayerFeature,\n  VectorLayerResourceItem,\n} from '@nextgis/ngw-connector';\nimport type NgwConnector from '@nextgis/ngw-connector';\n\nexport class IdentifyItem<F = FeatureLayerFields, G extends Geometry = Geometry>\n  implements LayerFeature {\n  readonly id: number;\n  readonly label: string;\n  readonly layerId: number;\n  readonly parent: string;\n  readonly fields: FeatureLayerFields;\n  geom?: GeoJsonObject;\n  extensions?: FeatureItemExtensions;\n\n  private connector: NgwConnector;\n  private _item?: NgwFeatureItemResponse<F, G>;\n  private _geojson?: Feature<G, F>;\n  private _resource?: VectorLayerResourceItem;\n\n  constructor(options: IdentifyItemOptions) {\n    const f = options.feature;\n    this.id = f.id;\n    this.label = f.label;\n    this.layerId = f.layerId;\n    this.parent = f.parent;\n    this.fields = f.fields;\n    this.geom = f.geom;\n    this.connector = options.connector;\n  }\n\n  identify(): CancelablePromise<NgwFeatureItemResponse<F, G>> {\n    if (this._item) {\n      return CancelablePromise.resolve(this._item);\n    }\n    return fetchNgwLayerItem<G, F>({\n      connector: this.connector,\n      featureId: this.id,\n      resourceId: this.layerId,\n      fields: null,\n      extensions: ['attachment', 'description'],\n    }).then((resp) => {\n      this._item = resp;\n      this.geom = resp.geom;\n      this.extensions = resp.extensions;\n      return resp;\n    });\n  }\n\n  resource(): CancelablePromise<FeatureResource> {\n    if (this._resource) {\n      return CancelablePromise.resolve(this._resource.feature_layer);\n    }\n    return this.connector.getResource(this.layerId).then((resp) => {\n      this._resource = resp as VectorLayerResourceItem;\n      return this._resource.feature_layer;\n    });\n  }\n\n  geojson(): CancelablePromise<Feature<G, F>> {\n    if (this._geojson) {\n      return CancelablePromise.resolve(this._geojson);\n    }\n    return this.identify().then((resp) => {\n      return resp.toGeojson().then((geojson) => {\n        this._geojson = geojson;\n        return geojson;\n      });\n    });\n  }\n}\n","import CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  JsonMap,\n  degrees2meters,\n  getCirclePolygonCoordinates,\n  deprecatedMapClick,\n} from '@nextgis/utils';\nimport { createGeoJsonFeature } from './featureLayerUtils';\nimport { fetchNgwLayerFeature } from './fetchNgwLayerFeature';\nimport { fetchNgwLayerItem } from './fetchNgwLayerItem';\n\nimport type { Geometry, Feature, GeoJsonProperties } from 'geojson';\nimport type { MapClickEvent } from '@nextgis/webmap';\nimport type {\n  LayerFeature,\n  FeatureLayersIdentify,\n  FeatureLayerFields,\n} from '@nextgis/ngw-connector';\nimport type {\n  GetIdentifyGeoJsonOptions,\n  NgwIdentify,\n  NgwIdentifyItem,\n  IdentifyRequestOptions,\n  FeatureIdentifyRequestOptions,\n  NgwFeatureItemResponse,\n  IdentifyItemOptions,\n} from '../interfaces';\nimport { IdentifyItem } from '../IdentifyItem';\n\nexport function getIdentifyItems(\n  identify: NgwIdentify,\n  multiple = false,\n): NgwIdentifyItem[] {\n  let params:\n    | { resourceId: number; featureId: number; feature: LayerFeature }\n    | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort((a, b) => {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const identifyItem = identify[l];\n    if ('features' in identifyItem) {\n      const layerFeatures = identifyItem.features;\n      const resourceId = Number(l);\n      const feature: LayerFeature | undefined = layerFeatures[0];\n      if (feature) {\n        params = {\n          featureId: feature.id,\n          resourceId,\n          feature,\n        };\n        paramsList.push(params);\n        if (!multiple) {\n          break;\n        }\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function fetchIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      if ('features' in item) {\n        const withGeom = item.features.find((x) => x.geom);\n\n        if (withGeom && withGeom.geom) {\n          const geom = withGeom.geom as Geometry;\n          return CancelablePromise.resolve(\n            createGeoJsonFeature({\n              ...withGeom,\n              geom,\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerFeature({ connector, ...params[0] });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\nexport function fetchIdentifyItem<\n  G extends Geometry = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n  const { connector, identify } = options;\n\n  const params = getIdentifyItems(identify);\n  if (params && params.length) {\n    return fetchNgwLayerItem({\n      connector,\n      ...options.requestOptions,\n      ...params[0],\n    });\n  }\n  return CancelablePromise.resolve(undefined);\n}\n\n/**\n * @deprecated use {@link fetchIdentifyGeoJson} instead\n */\nexport function getIdentifyGeoJson<\n  G extends Geometry = Geometry,\n  P extends JsonMap = JsonMap\n>(\n  options: GetIdentifyGeoJsonOptions,\n): CancelablePromise<Feature<G, P> | undefined> {\n  return fetchIdentifyGeoJson(options);\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions,\n  // webMap: WebMap\n): CancelablePromise<FeatureLayersIdentify> {\n  deprecatedMapClick(ev);\n  const [lng, lat] = ev.lngLat;\n\n  let geom: number[][] = [];\n\n  if (options.geom) {\n    const polygon =\n      options.geom.type === 'Feature'\n        ? options.geom.geometry\n        : options.geom.type === 'Polygon'\n        ? options.geom\n        : false;\n    if (polygon) {\n      geom = polygon.coordinates[0];\n    }\n  }\n  if (!geom.length) {\n    geom = getCirclePolygonCoordinates(lng, lat, options.radius);\n  }\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers,\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\nexport function createIdentifyItem<\n  F = FeatureLayerFields,\n  G extends Geometry = Geometry\n>(opt: IdentifyItemOptions): IdentifyItem {\n  return new IdentifyItem<F, G>(opt);\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport { CompanyLogoOptions } from '../interfaces';\n\nexport async function getCompanyLogo(\n  connector: NgwConnector,\n  options?: CompanyLogoOptions,\n): Promise<HTMLElement | undefined> {\n  const settings = await connector.get('pyramid.settings', null, {\n    component: 'pyramid',\n  });\n  if (settings && settings.company_logo && settings.company_logo.enabled) {\n    const anchor = document.createElement('a');\n    anchor.style.position = 'absolute';\n    anchor.style.bottom = '0';\n    anchor.style.right = '0';\n    anchor.style.padding = options?.padding ?? '10px';\n    anchor.className = 'ngw-map-logo';\n    if (options && options.cssClass) {\n      anchor.className += ' ' + options.cssClass;\n    }\n    const img = new Image();\n    img.style.maxHeight = '100px';\n    img.style.maxWidth = '100px';\n    img.src = '';\n    try {\n      const src = await connector.get('pyramid.company_logo', {\n        responseType: 'blob',\n      });\n      const urlCreator = window.URL || window.webkitURL;\n      const imageUrl = urlCreator.createObjectURL(src);\n      img.src = imageUrl;\n    } catch (er) {\n      console.log(er);\n    }\n\n    if (\n      settings.company_logo.link !== null &&\n      settings.company_logo.link.trim() !== ''\n    ) {\n      anchor.href = settings.company_logo.link;\n      anchor.target = '_blank';\n      if (settings.company_logo.link.search(/:\\/\\/nextgis/) !== -1) {\n        img.alt = 'Get your own Web GIS at nextgis.com';\n      }\n    }\n    anchor.appendChild(img);\n    return anchor;\n  }\n}\n","import type {\n  NgwLayerOptionsAdditional,\n  NgwLayerOptions,\n} from '@nextgis/ngw-kit';\nimport type { NgwResourceDefinition } from '../interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: NgwLayerOptionsAdditional,\n  overwriteOptions?: NgwLayerOptionsAdditional,\n): void {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resource,\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({\n      ...defOptions,\n      resource: resourceId,\n      id,\n      ...overwriteOptions,\n    });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n","import { deepmerge } from '@nextgis/utils';\nimport { StarterKit, MapOptions } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { QmsKit } from '@nextgis/qms-kit';\nimport { NgwKit } from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from '../interfaces';\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  whitlabel: false,\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"https://nextgis.com\" target=\"_blank\">©NextGIS</a>',\n      ],\n    },\n  },\n  pixelRadius: 10,\n};\n\nexport function prepareWebMapOptions(options: NgwMapOptions): MapOptions {\n  const kits: StarterKit[] = [new QmsKit()];\n  if (options.starterKits) {\n    options.starterKits.forEach((x) => {\n      kits.push(x);\n    });\n  }\n\n  if (!options.connector) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl || '',\n      auth: options.auth,\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  options = deepmerge(OPTIONS, options);\n\n  if (!options.center && !options.bounds) {\n    options.bounds = [-179, -90, 180, 90];\n    options.maxBounds = options.bounds;\n  }\n\n  if (options.connector) {\n    kits.push(\n      new NgwKit({\n        connector: options.connector,\n        auth: options.auth,\n      }),\n    );\n  }\n  options = {\n    ...options,\n    starterKits: kits,\n    create: false,\n  };\n  return options;\n}\n","import StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { defined, isObject } from '@nextgis/utils';\nimport { WebMap } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\n\nimport {\n  addNgwLayer,\n  fetchNgwLayerItem,\n  fetchNgwLayerItems,\n  fetchNgwLayerFeature,\n  fetchNgwLayerFeatureCollection,\n  fetchIdentifyGeoJson,\n  fetchNgwResourceExtent,\n  sendIdentifyRequest,\n  getCompanyLogo,\n  fetchIdentifyItem,\n  getIdentifyItems,\n  createIdentifyItem,\n} from '@nextgis/ngw-kit';\nimport { deprecatedWarn } from '@nextgis/utils';\nimport { getIcon } from '@nextgis/icons';\n\nimport { appendNgwResources } from './utils/appendNgwResources';\nimport { prepareWebMapOptions } from './utils/prepareWebMapOptions';\n\nimport type { JsonMap } from '@nextgis/utils';\nimport type {\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureItem,\n  FeatureLayersIdentifyItems,\n  LayerFeature,\n} from '@nextgis/ngw-connector';\nimport type {\n  ControlPosition,\n  MapControls,\n  WebMapEvents,\n  LayerDef,\n  MapClickEvent,\n  LayerAdapter,\n  FilterOptions,\n  OnLayerClickOptions,\n  FitOptions,\n} from '@nextgis/webmap';\nimport type {\n  ResourceAdapter,\n  NgwWebmapItem,\n  NgwIdentify,\n  NgwFeatureItemResponse,\n  NgwFeatureRequestOptions,\n} from '@nextgis/ngw-kit';\nimport type { PropertiesFilter } from '@nextgis/properties-filter';\nimport type { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport type {\n  NgwLayerOptions,\n  NgwLayerOptionsAdditional,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions,\n} from '@nextgis/ngw-kit';\nimport type {\n  Geometry,\n  Feature,\n  FeatureCollection,\n  GeoJsonProperties,\n} from 'geojson';\nimport type { NgwMapOptions, NgwMapEvents, NgwLayers } from './interfaces';\n\ntype PromiseGroup = 'select' | 'identify';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import { NgwMap } from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap({\n *   mapAdapter: new MapAdapter(),\n *   target: 'map',\n *   qmsId: 448,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n * @public\n */\nexport class NgwMap<\n  M = unknown,\n  L = unknown,\n  C = unknown,\n  O extends NgwMapOptions<C> = NgwMapOptions<C>\n> extends WebMap<M, L, C, NgwMapEvents, O> {\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwMapEvents\n  > = new EventEmitter();\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private $$selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private $$selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n  private _promises: Record<PromiseGroup, CancelablePromise[]> = {\n    select: [],\n    identify: [],\n  };\n\n  constructor(options: O) {\n    super(prepareWebMapOptions(options) as O);\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      if (this.options.whitlabel) {\n        this._whiteLabel();\n      }\n    });\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param options - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPosition,\n    options?: MapControls[K],\n  ): Promise<any> {\n    await this.onLoad('controls:create');\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource id.\n   * @param options - set layer identification parameters and render method.\n   *\n   * @example\n   * ```javascript\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resourceId: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resourceId: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  async addNgwLayer(\n    options: NgwLayerOptions,\n  ): Promise<ResourceAdapter | undefined> {\n    await this.onMapLoad();\n    // @ts-ignore for backward compatibility\n    const keyname = (options as KeynamedNgwLayerOptions).keyname;\n    // @ts-ignore for backward compatibility\n    const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n\n    if (keyname || resourceId !== undefined) {\n      deprecatedWarn(\n        'set `resource` options instead of `keyname` or `resourceId`',\n      );\n    }\n\n    const resource = options.resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resource, resourceId or keyname is required parameter to add NGW layer',\n      );\n    }\n    if (this.options.baseUrl || this.options.baseUrl === '') {\n      try {\n        if (defined(this.options.setViewDelay)) {\n          options.adapterOptions = options.adapterOptions || {};\n          if (!defined(options.adapterOptions.setViewDelay)) {\n            options.adapterOptions.setViewDelay = this.options.setViewDelay;\n          }\n        }\n        const adapter = addNgwLayer(options, this, this.connector);\n\n        const layer = (await this.addLayer(adapter, {\n          visibility: true,\n          // TODO: do not merge options, use only `adapterOptions`\n          ...options,\n          ...options.adapterOptions,\n        })) as ResourceAdapter;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baselayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n        return layer;\n      } catch (er) {\n        const resId =\n          isObject(resource) && 'id' in resource\n            ? resource.id\n            : keyname || resourceId || resource;\n        console.error(`Can't add NGW layer ${resId}.`, er);\n      }\n    }\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit(): void {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  fetchNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return fetchNgwLayerItem({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions,\n  ): CancelablePromise<FeatureItem[]> {\n    return fetchNgwLayerItems({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends JsonMap = JsonMap\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return fetchNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends JsonMap = JsonMap\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return fetchNgwLayerFeatureCollection({\n      connector: this.connector,\n      ...options,\n    });\n  }\n\n  fetchIdentifyItem<\n    G extends Geometry = Geometry,\n    P extends GeoJsonProperties = GeoJsonProperties\n  >(\n    identify: NgwIdentify,\n    requestOptions?: NgwFeatureRequestOptions,\n    // multiple = false\n  ): CancelablePromise<NgwFeatureItemResponse<P, G> | undefined> {\n    const promise = fetchIdentifyItem<G, P>({\n      identify,\n      connector: this.connector,\n      requestOptions,\n      // multiple,\n    });\n\n    this._addPromise('identify', promise);\n    return promise;\n  }\n\n  fetchIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    const promise = fetchIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple,\n    });\n    if (promise && 'then' in promise) {\n      this._addPromise('identify', promise);\n      return promise;\n    } else {\n      return CancelablePromise.resolve(promise);\n    }\n  }\n\n  /**\n   * @deprecated use {@link fetchIdentifyGeoJson} instead\n   */\n  getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false,\n  ): CancelablePromise<Feature | undefined> {\n    return this.fetchIdentifyGeoJson(identify, multiple);\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some((x) => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as NgwWebmapItem[];\n        const dependFit = dependLayers.find((x) => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.fitLayer(ngwLayer);\n   * ngwMap.fitLayer('ngw_layer_name');\n   * ```\n   */\n  async fitLayer(layerDef: LayerDef, options?: FitOptions): Promise<void> {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent, options);\n        }\n      } else {\n        let item: ResourceItem | undefined;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.getResource(resourceId);\n        }\n        if (item) {\n          fetchNgwResourceExtent(item, this.connector).then((extent) => {\n            if (extent) {\n              this.fitBounds(extent, options);\n            }\n          });\n        }\n      }\n    } else {\n      super.fitLayer(layerDef, options);\n    }\n  }\n\n  /** @deprecated use {@link NgwMap.fitLayer} instead */\n  async zoomToLayer(layerDef: string | ResourceAdapter): Promise<void> {\n    return this.fitLayer(layerDef);\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef): void {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection(): void {\n    if (!this.$$selectFromNgwRaster) {\n      this.$$selectFromNgwRaster = (ev: MapClickEvent) => {\n        const count = this.emitter.listenerCount('ngw:select');\n        if (count) {\n          this._selectFromNgwRaster(ev);\n        }\n      };\n      this.$$selectFromNgwVector = (ev: OnLayerClickOptions) => {\n        if (this.emitter.listenerCount('ngw:select')) {\n          this._selectFromNgwVector(ev);\n        }\n      };\n      this.emitter.on('click', this.$$selectFromNgwRaster);\n      this.emitter.on('layer:click', this.$$selectFromNgwVector);\n    }\n  }\n\n  disableSelection(): void {\n    if (this.$$selectFromNgwRaster) {\n      this.emitter.removeListener('click', this.$$selectFromNgwRaster);\n      this.emitter.removeListener('click', this._selectFromNgwVector);\n      this.$$selectFromNgwRaster = undefined;\n      this.$$selectFromNgwVector = undefined;\n    }\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItem} instead\n   */\n  getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return this.fetchNgwLayerItem(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerItems} instead\n   */\n  getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions,\n  ): CancelablePromise<FeatureItem[]> {\n    return this.fetchNgwLayerItems(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeature} instead\n   */\n  getNgwLayerFeature<\n    G extends Geometry = Geometry,\n    P extends JsonMap = JsonMap\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return this.fetchNgwLayerFeature(options);\n  }\n\n  /**\n   * @deprecated use {@link NgwMap.fetchNgwLayerFeatures} instead\n   */\n  getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends JsonMap = JsonMap\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions,\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return this.fetchNgwLayerFeatures(options);\n  }\n\n  /** @deprecated use {@link NgwMap.cancelPromises} instead */\n  cancelPromise(...args: PromiseGroup[]): void {\n    this.cancelPromises(...args);\n  }\n\n  cancelPromises(...args: PromiseGroup[]): void {\n    if (!args.length) {\n      args = Object.keys(this._promises) as PromiseGroup[];\n    }\n    args.forEach((name) => {\n      const group = this._promises[name];\n      if (group) {\n        group.forEach((x) => x.cancel());\n        this._promises[name] = [];\n      }\n    });\n  }\n\n  private _addPromise(groupName: PromiseGroup, promise: CancelablePromise) {\n    const group = this._promises[groupName];\n    if (group && group.indexOf(promise) === -1) {\n      const removeFromGroup = () => {\n        const index = group.indexOf(promise);\n        if (index !== -1) {\n          group.splice(index, 1);\n        }\n      };\n      promise.then(removeFromGroup);\n      promise.catch(removeFromGroup);\n      group.push(promise);\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create();\n    if (this.options.qmsId) {\n      this.addQmsBaseLayer();\n    }\n    if (this.options.osm) {\n      this.addOsmBaseLayer();\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed,\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach((x) => {\n        const overwriteOptions = {} as NgwLayerOptionsAdditional;\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n    for (const r of resources) {\n      try {\n        await this.addNgwLayer(r);\n      } catch (er) {\n        console.log(er);\n      }\n    }\n    this._emitStatusEvent('ngw-map:create', this);\n    this.enableSelection();\n  }\n\n  private addOsmBaseLayer() {\n    this.addBaseLayer('OSM');\n  }\n\n  private addQmsBaseLayer() {\n    let qmsId: number;\n    let qmsLayerName: string | undefined;\n    if (Array.isArray(this.options.qmsId)) {\n      qmsId = this.options.qmsId[0];\n      qmsLayerName = this.options.qmsId[1];\n    } else {\n      qmsId = Number(this.options.qmsId);\n    }\n    const qmsLayerOptions: Partial<QmsAdapterOptions> = {\n      qmsId,\n    };\n    if (qmsLayerName) {\n      qmsLayerOptions.id = qmsLayerName;\n    }\n\n    this.addBaseLayer('QMS', qmsLayerOptions);\n  }\n\n  private _selectFromNgwVector(\n    ev: OnLayerClickOptions,\n  ): FeatureLayersIdentify | undefined {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties,\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry,\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature],\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items,\n        };\n        this._emitStatusEvent(\n          'ngw:select',\n          this._prepareToIdentify({\n            ...identify,\n            resources: [id],\n            sourceType: 'vector',\n          } as NgwIdentify),\n        );\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    const layers = Object.values(this._ngwLayers);\n    layers.sort((a, b) => {\n      if (a.layer.order && b.layer.order) {\n        return b.layer.order - a.layer.order;\n      }\n      return 1;\n    });\n    layers.forEach((l) => {\n      const layer = l.layer;\n      const identFunc =\n        typeof layer.getIdentificationIds === 'function'\n          ? layer.getIdentificationIds\n          : false;\n      if (identFunc && layer.options.selectable && this.isLayerVisible(layer)) {\n        promises.push(identFunc.call(layer));\n      }\n    });\n    const getIdsPromise = Promise.all(promises);\n    const getIds = await getIdsPromise;\n    const ids: number[] = [];\n    getIds.forEach((x) => {\n      if (x) {\n        x.forEach((y) => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    let zoom = this.getZoom();\n    zoom = zoom !== undefined ? zoom : 20;\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n\n    const selectPromise = sendIdentifyRequest(ev, {\n      layers: ids,\n      connector: this.connector,\n      radius,\n    }).then((resp) => {\n      this._emitStatusEvent(\n        'ngw:select',\n        this._prepareToIdentify({\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev,\n        }),\n      );\n      return resp;\n    });\n    this._addPromise('select', selectPromise);\n    return selectPromise;\n  }\n\n  private _prepareToIdentify(identify: NgwIdentify) {\n    const getIdentifyItems_ = () => {\n      return getIdentifyItems(identify, true).map((x) => {\n        return createIdentifyItem({\n          feature: x.feature,\n          connector: this.connector,\n        });\n      });\n    };\n    return {\n      ...identify,\n      getIdentifyItems: getIdentifyItems_,\n    };\n  }\n\n  private async _whiteLabel() {\n    const container = this.getContainer();\n    if (container) {\n      const logo = await getCompanyLogo(\n        this.connector,\n        this.options.companyLogoOptions,\n      );\n      if (logo) {\n        container.appendChild(logo);\n      }\n    }\n  }\n}\n","import type {\n  Expression,\n  Paint,\n  PropertiesPaint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintCallback,\n  IconPaint,\n} from './interfaces';\n\nexport function isExpression(value: unknown): value is Expression {\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPropertiesPaint(paint: Paint): paint is PropertiesPaint {\n  if (Array.isArray(paint)) {\n    return true;\n  }\n  return false;\n}\n\nexport function isPaint(paint: Paint): paint is VectorAdapterLayerPaint {\n  if (Object.prototype.toString.call(paint) === '[object Object]') {\n    return true;\n  }\n  return false;\n}\n\nexport function isBasePaint(paint: Paint): paint is GeometryPaint {\n  if (isPaint(paint)) {\n    if (paint.type === 'get-paint' || paint.type === 'icon') {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function isPaintCallback(paint: Paint): paint is GetPaintCallback {\n  if (typeof paint === 'function') {\n    return true;\n  }\n  return false;\n}\n\nexport function isIcon(paint: IconPaint): paint is IconPaint {\n  return paint.type === 'icon' || 'html' in paint;\n}\n","import { isExpression } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  Expression,\n  ExpressionName,\n} from './interfaces';\n\ntype ExpressionFun = (feature: Feature, args: any[]) => SimpleType;\n\nfunction get(feature: Feature, args: any[]) {\n  const field = args[0];\n  return feature.properties && feature.properties[field];\n}\n\nfunction match(feature: Feature, args: any[]) {\n  const [lookup, ...cases] = args;\n  let property = lookup;\n  if (Array.isArray(lookup)) {\n    property = featureExpression(feature, lookup as Expression);\n  }\n  // remove last odd item from cases array\n  const defValue = cases.splice(-1, cases.length % 2)[0];\n  for (let fry = 0; fry < cases.length - 1; fry += 2) {\n    const key = cases[fry];\n    if (key === property) {\n      return cases[fry + 1];\n    }\n  }\n  return defValue;\n}\n\nconst expressions: { [key in ExpressionName]: ExpressionFun } = {\n  get,\n  match,\n};\n\ntype SimpleType = string | number | boolean | undefined;\n\ntype PropertyExpressionCb = (feature: Feature) => SimpleType;\n\nfunction featureExpression(feature: Feature, expression: Expression) {\n  const [name, ...args] = expression;\n  const expressionFun = expressions[name];\n  if (expressionFun) {\n    return expressionFun(feature, args);\n  }\n  return undefined;\n}\n\nfunction createPropertyExpressionCb(\n  expression: Expression,\n): PropertyExpressionCb {\n  return (feature: Feature) => {\n    return featureExpression(feature, expression);\n  };\n}\n\nconst excludeExpressionList = ['iconSize', 'iconAnchor'];\n\nexport function createExpressionCallback(\n  paint: VectorAdapterLayerPaint,\n): GetPaintCallback | undefined {\n  let withExpression = false;\n  const expressions: {\n    [key: string]: PropertyExpressionCb;\n  } = {};\n  for (const p in paint) {\n    if (excludeExpressionList.indexOf(p) === -1) {\n      const p_ = p as keyof VectorAdapterLayerPaint;\n      const val = paint[p_];\n      if (isExpression(val)) {\n        withExpression = true;\n        expressions[p_] = createPropertyExpressionCb(val);\n      }\n    }\n  }\n  if (withExpression) {\n    return (feature: Feature) => {\n      const fromCb: any = {};\n      for (const p in expressions) {\n        fromCb[p] = expressions[p](feature);\n      }\n      return { ...paint, ...fromCb };\n    };\n  }\n  return;\n}\n","import { featureFilter } from '@nextgis/properties-filter';\n\nimport { createExpressionCallback } from './fromPaintExpression';\nimport { isPaintCallback, isPropertiesPaint } from './typeHelpers';\n\nimport type { Feature } from 'geojson';\nimport type {\n  Paint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintFunction,\n  GetCustomPaintOptions,\n  PropertiesPaint,\n  PropertyPaint,\n  GetPaintCallback,\n} from './interfaces';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nfunction createPropertiesPaint(\n  propertiesPaint: PropertiesPaint,\n): GetPaintFunction {\n  let mask: VectorAdapterLayerPaint = {};\n  const paintsFilters: PropertyPaint[] = [];\n  propertiesPaint.forEach((x) => {\n    if (x) {\n      if (Array.isArray(x)) {\n        paintsFilters.push(x);\n      } else {\n        mask = x as VectorAdapterLayerPaint;\n      }\n    }\n  });\n\n  return (feature: Feature) => {\n    const paint = paintsFilters.find((x) => featureFilter(feature, x[0]));\n    if (paint) {\n      return { ...mask, ...paint[1] };\n    }\n    return mask;\n  };\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint?: GeometryPaint,\n  getPaintFunctions?: { [name: string]: GetPaintFunction },\n): Paint {\n  if (!paint) {\n    throw new Error('paint is empty');\n  }\n  let newPaint: Paint = { ...defaultPaint };\n  if (isPaintCallback(paint)) {\n    const getPaintFunction: GetPaintCallback = (feature: Feature) => {\n      const getPaint = preparePaint(\n        paint(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n      getPaint.type = paint.type;\n      return getPaint;\n    };\n    getPaintFunction.type = paint.type;\n    return getPaintFunction;\n  } else if (isPropertiesPaint(paint)) {\n    return (feature: Feature) => {\n      return preparePaint(\n        createPropertiesPaint(paint)(feature),\n        defaultPaint,\n        getPaintFunctions,\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    const expressionCallback = createExpressionCallback(paint);\n    if (expressionCallback) {\n      return (feature: Feature) => {\n        return preparePaint(\n          expressionCallback(feature),\n          defaultPaint,\n          getPaintFunctions,\n        ) as VectorAdapterLayerPaint;\n      };\n    }\n\n    newPaint = { ...newPaint, ...paint };\n    newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n    newPaint.stroke =\n      newPaint.stroke !== undefined\n        ? newPaint.stroke\n        : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  }\n\n  if (isPaintCallback(newPaint)) {\n    return newPaint;\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import { reEscape } from '@nextgis/utils';\n\nimport type { Feature, GeoJsonProperties } from 'geojson';\n/**\n * gt - greater (\\>)\n * lt - lower (\\<)\n * ge - greater or equal (\\>=)\n * le - lower or equal (\\<=)\n * eq - equal (=)\n * ne - not equal (!=)\n * like - LIKE SQL statement (for strings compare)\n * ilike - ILIKE SQL statement (for strings compare)\n */\nexport type Operations =\n  | 'gt'\n  | 'lt'\n  | 'ge'\n  | 'le'\n  | 'eq'\n  | 'ne'\n  | 'in'\n  | 'notin'\n  | 'like'\n  | 'ilike';\n\ntype Properties = GeoJsonProperties;\n\n/**\n * field, operation, value\n * ['foo', 'eq', 'bar']\n * ['count', 'ge', 20]\n */\nexport type PropertyFilter<T extends Properties = Properties> = [\n  keyof T | string,\n  Operations,\n  any,\n];\n\nexport type PropertiesFilter<T extends Properties = Properties> = (\n  | 'all'\n  | 'any'\n  | PropertyFilter<T>\n  | PropertiesFilter<T>\n)[];\n\nfunction like(b: string, a: string, iLike?: boolean): boolean {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${reEscape(a)}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operations]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  },\n};\n\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string,\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function featureFilter(\n  feature: Feature,\n  filters: PropertiesFilter,\n): boolean {\n  const properties: GeoJsonProperties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter(\n  properties: { [field: string]: any },\n  filters: PropertiesFilter,\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (checkIfPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        if (operation === 'like' || operation === 'ilike') {\n          if (typeof field === 'string') {\n            let prop = '';\n            const value_ = field.replace(/^%?(\\w+)%?$/, (match, cleanField) => {\n              prop = properties[cleanField];\n              return field.replace(cleanField, value);\n            });\n            return operationExec(prop, value_);\n          }\n        }\n        return operationExec(properties[field], value);\n      }\n      return false;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter((x) => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n","import type { LayerAdaptersOptions, AdapterOptions } from '@nextgis/webmap';\n\nimport type { QmsBasemap, QmsLayerType } from '../interfaces';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE',\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap,\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  let serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  if (!qms.y_origin_top) {\n    serviceUrl = serviceUrl.replace('{y}', '{-y}');\n  }\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min,\n  };\n}\n","import { fixUrlStr } from '@nextgis/utils';\n\nexport function loadJson<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","import { mixinProperties } from '@nextgis/utils';\nimport { alias, updateQmsOptions } from './updateQmsOptions';\nimport { loadJson } from './loadJson';\nimport { getSubdomainsOriginUrl } from './getSubmodulesFromOriginUrl';\n\nimport type { Type } from '@nextgis/utils';\nimport type { WebMap, MainLayerAdapter } from '@nextgis/webmap';\nimport type {\n  QmsAdapterOptions,\n  QmsBasemap,\n  QmsAdapter as QA,\n} from '../interfaces';\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com',\n): Type<MainLayerAdapter> {\n  class QmsAdapter<M = any> implements MainLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baselayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        try {\n          this.qms = await loadJson<QmsBasemap>(\n            url + '/api/v1/geoservices/' + options.qmsId,\n          );\n        } catch (er) {\n          console.error(er);\n        }\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          mixinProperties(QmsAdapter, webMapAdapter, [\n            'showLayer',\n            'hideLayer',\n          ]);\n          if (type === 'TILE') {\n            options = {\n              order: 0,\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms),\n            };\n            if (qms.origin_url) {\n              const [url, subdomains] = getSubdomainsOriginUrl(qms.origin_url);\n              if (subdomains.length) {\n                options.subdomains = subdomains;\n                options.url = url;\n              }\n            }\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","export function getSubdomainsOriginUrl(originUrl: string): [string, string[]] {\n  const submodules: string[] = [];\n  originUrl = originUrl.replace(/{switch:(.*?)}/, (m, group) => {\n    if (typeof group === 'string') {\n      group.split(',').forEach((s) => submodules.push(s));\n    }\n    return '{s}';\n  });\n  return [originUrl, submodules];\n}\n","import { createQmsAdapter } from './utils/createQmsAdapter';\n\nimport type {\n  WebMap,\n  StarterKit,\n  Type,\n  MainLayerAdapter,\n  LayerAdapterCreators,\n} from '@nextgis/webmap';\nimport type { QmsOptions } from './interfaces';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter,\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com',\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters(): Promise<LayerAdapterCreators[]> {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap)),\n      },\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<MainLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n"],"sourceRoot":""}